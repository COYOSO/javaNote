# 第一章 数据结构

## 2.1 数据结构有什么用？

当你用着java里面的容器类很爽的时候，你有没有想过，怎么ArrayList就像一个无限扩充的数组，也好像链表之类的。好用吗？好用，这就是数据结构的用处，只不过你在不知不觉中使用了。

现实世界的存储，我们使用的工具和建模。每种数据结构有自己的优点和缺点，想想如果Google的数据用的是数组的存储，我们还能方便地查询到所需要的数据吗？而算法，在这么多的数据中如何做到最快的插入，查找，删除，也是在追求更快。

我们java是面向对象的语言，就好似自动档轿车，C语言好似手动档吉普。数据结构呢？是变速箱的工作原理。你完全可以不知道变速箱怎样工作，就把自动档的车子从 A点 开到 B点，而且未必就比懂得的人慢。写程序这件事，和开车一样，经验可以起到很大作用，但如果你不知道底层是怎么工作的，就永远只能开车，既不会修车，也不能造车。当然了，数据结构内容比较多，细细的学起来也是相对费功夫的，不可能达到一蹴而就。我们将常见的数据结构：堆栈、队列、数组、链表和红黑树 这几种给大家介绍一下，作为数据结构的入门，了解一下它们的特点即可。

![](D:\Java\笔记\图片\1-16【数据结构】\数据结构比喻.png)

## 2.2 常见的数据结构

数据存储的常用结构有：栈、队列、数组、链表和红黑树。我们分别来了解一下：

#### 栈

* **栈**：**stack**,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。

简单的说：采用该结构的集合，对元素的存取有如下的特点

* 先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。

* 栈的入口、出口的都是栈的顶端位置。

  ![](D:\Java\笔记\图片\1-16【数据结构】\堆栈.png)

这里两个名词需要注意：

* **压栈**：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。
* **弹栈**：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。


#### 队列

* **队列**：**queue**,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。

简单的说，采用该结构的集合，对元素的存取有如下的特点：

* 先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。
* 队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。

![](D:\Java\笔记\图片\1-16【数据结构】\队列图.bmp)

#### 数组

* **数组**:**Array**,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。

简单的说,采用该结构的集合，对元素的存取有如下的特点：

* 查找元素快：通过索引，可以快速访问指定位置的元素

  ![](D:\Java\笔记\图片\1-16【数据结构】\数组查询快.png)

* 增删元素慢

  * **指定索引位置增加元素**：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图![](D:\Java\笔记\图片\1-16【数据结构】\数组添加.png)
  * **指定索引位置删除元素：**需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图![](D:\Java\笔记\图片\1-16【数据结构】\数组删除.png)



####  链表

* **链表**:**linked list**,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是**单向链表**。

  ![](D:\Java\笔记\图片\1-16【数据结构】\单链表结构特点.png)

简单的说，采用该结构的集合，对元素的存取有如下的特点：

* 多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。

  ![](D:\Java\笔记\图片\1-16【数据结构】\单链表结构.png)

* 查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素

* 增删元素快：

  * 增加元素：只需要修改连接下个元素的地址即可。

    ![](D:\Java\笔记\图片\1-16【数据结构】\增加结点.png)

  * 删除元素：只需要修改连接下个元素的地址即可。

    ![](D:\Java\笔记\图片\1-16【数据结构】\删除结点.bmp)

#### 红黑树

* **二叉树**：**binary tree** ,是每个结点不超过2的有序**树（tree）** 。

简单的理解，就是一种类似于我们生活中树的结构，只不过每个结点上都最多只能有两个子结点。

二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。

如图：

![](D:\Java\笔记\图片\1-16【数据结构】\二叉树.bmp)

我们要说的是二叉树的一种比较有意思的叫做**红黑树**，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。

红黑树的约束:

1. 节点可以是红色的或者黑色的


2. 根节点是黑色的


3. 叶子节点(特指空节点)是黑色的
4. 每个红色节点的子节点都是黑色的
5. 任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同

红黑树的特点:

​	速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍



# 第一章 哈希表

哈希法又称散列法、杂凑法以及关键字地址计算法等，相应的表称为哈希表。这种方法的基本思想是：首先在元素的关键字*k*和元素的存储位置*p*之间建立一个对应关系*f*，使得*p=f(k)*，*f*称为哈希函数。

创建哈希表时，把关键字为*k*的元素直接存入地址为*f(k)*的单元；以后当查找关键字为*k*的元素时，再利用哈希函数计算出该元素的存储位置*p=f(k)*，从而达到按关键字直接存取元素的目的。

当关键字集合很大时，关键字值不同的元素可能会映象到哈希表的同一地址上，即 *k1*≠*k2* ，但 *H*（*k1*）*=H*（*k2*），这种现象称为**冲突，**此时称*k1*和*k2*为**同义词。**实际中，冲突是不可避免的，只能通过改进哈希函数的性能来减少冲突。

综上所述，哈希法主要包括以下两方面的内容：

1. 如何构造哈希函数
2. 如何处理冲突。

## 1.1 哈希函数的构造方法

构造哈希函数的原则是：①函数本身便于计算；②计算出来的地址分布均匀，即对任一关键字*k*，*f(k)* 对应不同地址的概率相等，目的是尽可能减少冲突。

下面介绍构造哈希函数常用的五种方法。

### 数字分析法

取关键字或关键字的某个线性函数值为哈希地址。即H(key)=key 或 H(key)=a*key+b  (a,b为常数)。

* 举例1：统计1-100岁的人口，其中年龄作为关键字，哈希函数取关键字自身。查找年龄25岁的人口有多少，则直接查表中第25项。

  | 地址 | 01          02         03   ...           25          26            27  ...   100 |
  | ---- | ------------------------------------------------------------ |
  | 年龄 | 1             2            3   ...            25          26           27   ...   .... |
  | 人数 | 3000    2000  .............             1050                 |
  | ...  |                                                              |

* 举例2：统计解放以后出生人口，其中年份作为关键字，哈希函数取关键字自身加一个常数H(key)=key+(-1948).查找1970年出生的人数，则直接查(1970-1948)=22项即可。

  | 地址 | 01          02         03   ...           22          23            24  ... |
  | ---- | ------------------------------------------------------------ |
  | 年份 | 1949     1950      1951   ...     1970                       |
  | 人数 | .............            15000                               |
  | ...  |                                                              |

### 平方取中法

取关键字平方后的中间几位为哈希地址。（较常用的一种）

* 举例：为BASIC源程序中的标识符键一个哈希表（假设BASIC语言允许的标识符为一个字母或者一个字母和一个数字两种情况，在计算机内可用两位八进制数表示字母和数字），假设表长为512，则可取关键字平方后的中间9位二进制数为哈希地址。（每3个二进制位可表示1位八进制位，即3个八进制位为9个二进制位）

  A ：01 （A的ASCII码值为65,65的八进制为101，取后两位表示关键字）

  B：02 （B的ASCII码值为66,66的八进制为102，取后两位表示关键字）

  ...

  Z：32（Z的ASCII码值为90,90的八进制为132，取后两位表示关键字）

  ...

  0：60（0的ASCII码值为48,48的八进制为60，取后两位表示关键字）

  ...

  

  9：71（9的ASCII码值为57,57的八进制为71，取后两位表示关键字）

  | 记录 | 关键字 | 关键字的平方      | 哈希地址（![2^{17}](https://private.codecogs.com/gif.latex?2%5E%7B17%7D)~![2^{9}](https://private.codecogs.com/gif.latex?2%5E%7B9%7D)） |
  | ---- | ------ | ----------------- | ------------------------------------------------------------ |
  | A    | 0100   | 0***\*010\****000 | 010                                                          |
  | I    | 1100   | 1***\*210\****000 | 210                                                          |
  | P1   | 2061   | 4***\*310\****541 | 310                                                          |
  | Q2   | 2162   | 4***\*741\****304 | 741                                                          |



### 分段叠加法

这种方法是按哈希表地址位数将关键字分成位数相等的几部分（最后一部分可以较短），然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。具体方法有**折叠法**与**移位法。**

移位法是将分割后的每部分低位对齐相加，折叠法是从一端向另一端沿分割界来回折叠（奇数段为正序，偶数段为倒序），然后将各段相加。

例如：*key=12360324711202065,*哈希表长度为*1000*，则应把关键字分成*3*位一段，在此舍去最低的两位*65*，分别进行移位叠加和折叠叠加，求得哈希地址为*105*和*907*，如图*8.24*所示。

![](D:\Java\笔记\图片\1-16【数据结构】\1分段叠加法.png)



### 除留余数法

取关键字为某个不大于哈希表表长m的数p除后所得余数为哈希地址（p为素数）

`H（key）=key  MOD  p`p<=m   （最简单，最常用）p的选取很重要

一般情况，p可以选取为质数或者不包含小于20的质因数的合数（合数指自然数中除了能被1和本身整除外，还能被其他数（0除外）整除的数）。

假设哈希表长为*m*，*p*为小于等于*m*的最大素数，则哈希函数为`h（k）=k % p` ，其中*%*为模*p*取余运算。

* 例如，已知待散列元素为（*18*，*75*，*60*，*43*，*54*，*90*，*46*），表长*m=10*，*p=7*，则有

  *h(18)=18 % 7=4  h(75)=75 % 7=5  h(60)=60 % 7=4*  

  *h(43)=43 % 7=1  h(54)=54 % 7=5  h(90)=90 % 7=6*  

  *h(46)=46 % 7=4*

  此时冲突较多。为减少冲突，可取较大的*m*值和*p*值，如*m=p=13*，结果如下：

  *h(18)=18 % 13=5  h(75)=75 % 13=10  h(60)=60 % 13=8*   

  *h(43)=43 % 13=4  h(54)=54 % 13=2  h(90)=90 % 13=12*  

  *h(46)=46 % 13=7*

### 伪随机数法

采用一个伪随机函数做哈希函数，即*`h(key)=random(key)`*。

在实际应用中，应根据具体情况，灵活采用不同的方法，并用实际数据测试它的性能，以便做出正确判定。通常应考虑以下五个因素 ：

* 计算哈希函数所需时间 （简单）。

* 关键字的长度。

* 哈希表大小。

* 关键字分布情况。

* 记录查找频率

## 1.2 处理哈希冲突的方法

虽然我们不希望发生冲突，但实际上发生冲突的可能性仍是存在的。

当关键字值域远大于哈希表的长度，而且事先并不知道关键字的具体取值时。冲突就难免会发 生。另外，当关键字的实际取值大于哈希表的长度时，而且表中已装满了记录，如果插入一个新记录，不仅发生冲突，而且还会发生溢出。

因此，处理冲突和溢出是 哈希技术中的两个重要问题。常用的解决冲突方法有以下几种：

### 开放定址法

用开放定址法解决冲突的做法是：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。 沿此序列逐个单元地查找，直到找到给定 的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。查找时探查到开放的 地址则表明表中无待查的关键字，即查找失败。

>  注意：
>
> 1. 用开放定址法建立散列表时，建表前须将表中所有单元(更严格地说，是指单元中存储的关键字)置空。
> 2. 空单元的表示与具体的应用相关。

按照形成探查序列的方法不同，可将开放定址法区分为线性探查法、线性补偿探测法、随机探测等 。

#### 线性探查法(Linear Probing)

该方法的基本思想是：将散列表T[0..m-1]看成是一个循环向量，若初始探查的地址为d(即h(key)=d)，则最长的探查序列为：`d，d+l，d+2，…，m-1，0，1，…，d-1`即:探查时从地址d开始，首先探查T[d]，然后依次探查T[d+1]，…，直到T[m-1]，此后又循环到T[0]，T[1]，…，直到探查到T[d-1]为止。

探查过程终止于三种情况：

* 若当前探查的单元为空，则表示查找失败（若是插入则将key写入其中）；
* 若当前探查的单元中含有key，则查找成功，但对于插入意味着失败；
* 若探查到T[d-1]时仍未发现空单元也未找到key，则无论是查找还是插入均意味着失败(此时表满)。

利用开放地址法的一般形式，线性探查法的探查序列为： `h i =(h(key)+i)％m 0≤i≤m-1 //即d i =i`

用线性探测法处理冲突，思路清晰，算法简单，但存在下列缺点：

1. 处理溢出需另编程序。一般可另外设立一个溢出表，专门用来存放上述哈希表中放不下的记录。此溢出表最简单的结构是顺序表，查找方法可用顺序查找。
2. 按上述算法建立起来的哈希表，删除工作非常困难。假如要从哈希表 HT 中删除一个记录，按理应将这个记录所在位置置为空，但我们不能这样做，而只能标上已被删除的标记，否则，将会影响以后的查找。
3. 线性探测法很容易产生堆聚现象。所谓堆聚现象，就是存入哈希表的记录在表中连成一片。按照线性探测法处理冲突，如果生成哈希地址的连续序列愈长 ( 即不同关键字值的哈希地址相邻在一起愈长 ) ，则当新的记录加入该表时，与这个序列发生冲突的可能性愈大。因此，哈希地址的较长连续序列比较短连续序列生长得快，这就意味着，一旦出现堆聚 ( 伴随着冲突 ) ，就将引起进一步的堆聚。

####    二次探测再散列

$$
di=1^2，-1^2，2^2，-2^2，…，k^2，-k^2    ( k<=m/2 )
$$

这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。

#### 随机探测

di=伪随机数序列；

具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），生成一个伪随机序列，并给定一个随机数做起点，每次去加上这个伪随机数++就可以了。

### 拉链法

拉链法解决冲突的方法是：将所有关键字为同义词的结点链接在同一个单链表中 。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于 1，但一般均取α≤1。

与开放定址法相比，拉链法有如下几个优点：

1. 拉链法处理冲突简单 ，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；
2. 由于拉链法中各链表上的 结点空间是动态申请的 ，故它更适合于造表前无法确定表长的情况；
3. 开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；
4. 在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。

拉链法的缺点如下：
指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。

### 再散列法

再散列法其实很简单，就是再使用哈希函数去散列一个输入的时候，输出是同一个位置就再次散列，直至不发生冲突位置

缺点：每次冲突都要重新散列，计算时间增加。

# 第二章 链表

## 2.1 单链表

### 单链表的实现

```java
/*
 *定义节点
 *  链表由节点构成
 */
public class Node<E> {
    private E e;   //数据data
    private Node<E> next; //指向下一个节点

    public Node() {

    }

    public Node(E e) {
        this.e = e;
    }

    public Node<E> getNext() {
        return next;
    }

    public void setNext(Node<E> next) {
        this.next = next;
    }

    public E getE() {
        return e;
    }

    public void setE(E e) {
        this.e = e;
    }
}
```

```java
/*
 * 定义实现类MyLinkedList　*　实现链表的基本功能：增删改查
 */
public class MyLinkedList<E> {
    //声明头节点尾节点
    private Node<E> head;
    private Node<E> last;
    //链表的大小
    private int size;
    private int modcount; //计算被修改的次数

    public MyLinkedList() {
        head = new Node<E>();//实例化头结点
        last = head;
    }

    /*
     *返回单链表中存储的元素总数
     */
    public int size() {
        return size;
    }

    /*
     *获取指定索引位置的节点对象
     */
    public Node<E> get(int index) {
        if (index < 0 || index > size - 1)
            return null;
        Node<E> node = head.getNext();//将头结点的下一个节点赋给Node
        for (int i = 0; i < index; i++) {
            node = node.getNext();//获取node的下一个节点
        }
        return node;
    }

    /*
     *获取指定索引位置的数据
     */
    public E getValue(int index) {
        if (index < 0 || index > size - 1)
            return null;
        Node<E> node = get(index);
        return node.getE();
    }

    /*
     *增加元素
     */
    public void add(E e) {
        Node<E> node = new Node<E>(e); //以e实例化一个节点
        last.setNext(node);//往尾节点后追加节点
        last = node;//该节点设为最后一个节点
        size++;
        modcount++;
    }

    /*
     *指定位置插入元素,返回插入的节点数据
     */
    public E add(int index, E e) {
        if (index < 0 || index > size - 1)
            return null;
        Node<E> node = new Node<E>(e); //实例化一个节点
        //找到插入的原节点
        Node<E> oldNode = get(index);
        if (index == 0) {//当索引为0时
            head.setNext(node);
        } else {
            //找到插入节点的上一个
            Node<E> bNode = get(index - 1);
            bNode.setNext(node);
        }
        node.setNext(oldNode);
        size++;
        modcount++;
        return oldNode.getE();
    }

    /*
     *删除指定的节点e,并返回删除节点的数据
     */
    public E delete(int index) {
        if (index < 0 || index > size - 1)
            return null;
        if (index == 0) {//当索引为1，令头结点的下一个节点为头结点
            Node<E> node = head.getNext();
            head.setNext(node.getNext());
        }
        //获取要删除节点的前一个节点
        Node<E> bNode = get(index - 1);
        //获取要删除的节点
        Node<E> Node = bNode.getNext();
        //获取要删除节点的下一个节点
        Node<E> nNode = Node.getNext();
        //删除该节点
        bNode.setNext(nNode);
        //清除Node的下一个节点
        Node.setNext(null);
        size--;
        modcount++;
        return Node.getE();//返回节点中的数据域
    }

    /*
     *修改指定位置的数据域并返回修改后的数据
     */
    public E set(int index, E e) {
        if (index < 0 || index > size - 1)
            return null;
        //获取指定位置的原节点
        Node<E> node = get(index);
        node.setE(e);
        modcount++;
        return node.getE();
    }
}
```

```java
package 数据结构算法.链表;

/*
 *定义测试类
 */
public class MyLinkedListTest {
    public static void main(String[] args) {
        MyLinkedList<String> list = new MyLinkedList<>();

        //测试add
        list.add("one");
        list.add("two");
        list.add("three");
        list.add("four");
        list.add(0,"newone");
        list.add(1,"newtwo");
        for (int i = 0; i < list.size(); i++) {
            System.out.print(list.getValue(i)+" ");
        }

        //测试set
        System.out.println();
        list.set(0, "111");
        list.set(1, "222");
        System.out.println(list.getValue(0) + "   " + list.getValue(1));

        //测试delete
        System.out.println();
        list.delete(1);
        for (int i = 0; i < list.size(); i++) {
            System.out.print(list.getValue(i)+" ");
        }
    }
}
```

# 第三章 树

## 3.1 二叉树

求二叉树深度：

```java
static class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    public TreeNode(int val) {
        this.val = val;
    }
}

/**
     * 递归求深度
     * @param root
     * @return
     */
public static int treeDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    // 计算左子树的深度
    int left = treeDepth(root.left);
    // 计算右子树的深度
    int right = treeDepth(root.right);
    // 树root的深度=路径最长的子树深度 + 1
    return left >= right ? (left + 1) : (right + 1);
}
```

```java
public int treeDepth2(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int depth = 0;
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    
    while (!root.isEmpty()) {
        depth++;
        int size = stack.size();
        while (size > 0) {
            TreeNode current = stack.pop();
            if (current.right != null) {
                stack.push(current.right);
            }
            if (current.left != null) {
                stack.push(current.left);
            }
            size--;
        }
    }
    return depth;
}
```

# 第四章 Comparator

Comparator接口可以实现自定义排序，实现Comparator接口时，要重写compare方法：
int compare(Object o1, Object o2) 返回一个基本类型的整型

* 如果要按照升序排序,则o1 小于o2，返回-1（负数），相等返回0，01大于02返回1（正数）
* 如果要按照降序排序,则o1 小于o2，返回1（正数），相等返回0，01大于02返回-1（负数）



# 命名规则

### 链表

有dummy哑结点

有cur现在的节点，不要让head节点移动，直接复制给cur，让cur节点移动
