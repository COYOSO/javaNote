# 第一章网络编程入门

## 1.1 软件结构

<!--P403-->

<!--Clinet 客户端   Server 服务器-->

* **C/S结构**：全称为`Clinet/Server`结构，是指客户端和服务器结构。常用程序有QQ、迅雷等软件。

![Clinet/Server结构](..\图片\1-11【网络编程】\1.png)

* **B/S结构**：全程为`Browser/Server`结构，是指浏览器和服务器结构。常用的浏览器有谷歌，Edge，火狐等。

![Browser/Server结构](..\图片\1-11【网络编程】\2.png)

两种架构各有优势，但是无论哪种架构，都离不开网络的支持。

**网络编程**，就是在一定的协议下，实现两台计算机的通信的程序。

## 1.2 网络通信协议

<!--P404-->

**网络通信协议：**网络通信协议是一种网络通用语言，为连接不同操作系统和不同硬件体系结构的互联网络提供通信支持，是一种网络通用语言。

例如，网络中一个微机用户和一个大型主机的操作员进行通信，由于这两个数据终端所用字符集不同，因此操作员所输入的命令彼此不认识。为了能进行通信，规定每个终端都要将各自字符集中的字符先变换为标准字符集的字符后，才进入网络传送，到达目的终端之后，再变换为该终端字符集的字符。因此，网络通信协议也可以理解为网络上各台计算机之间进行交流的一种语言。

常见的网络通信协议有：TCP/IP协议、IPX/SPX协议、NetBEUI协议等。 

TCP/IP协议是一个协议簇。里面包括很多协议的，UDP只是其中的一个， 之所以命名为TCP/IP协议，因为TCP、IP协议是两个很重要的协议，就用他两命名了。 

* **TCP/IP**（`Transmission Control Protocol/Internet Protocol`,传输控制协议/网际协议） 协议具有很强的灵活性，支持任意规模的网络，几乎可连接所有服务器和工作站。在使用TCP/IP协议时需要进行复杂的设置，每个结点至少需要一个“IP地址”、一个“子网掩码”、一个“默认网关”、一个“主机名”，对于一些初学者来说使用不太方便。 

  ![](..\图片\1-11【网络编程】\3.png)

 *TCP/IP*（*Transmission Control Protocol/Internet Protocol*）即传输控制协议*/*网间协议，定义了主机如何连入因特网及数据如何再它们之间传输的标准。

从字面意思来看TCP/IP是TCP和IP协议的合称，但实际上TCP/IP协议是指因特网整个TCP/IP协议族。不同于ISO模型的七个分层，TCP/IP协议参考模型把所有的TCP/IP系列协议归类到四个抽象层中

- 应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等
- 传输层：TCP，UDP
- 网络层：IP，ICMP，OSPF，EIGRP，IGMP
- 数据链路层：SLIP，CSLIP，PPP，MTU

每一抽象层建立在低一层提供的服务上，并且为高一层提供服务，看起来大概是这样子的

​     ![img](..\图片\1-11【网络编程】\Center)

![img](..\图片\1-11【网络编程】\Center1)

## 1.3 协议分类

<!--P405-->

`java.net`包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。

`java.net`包中提供了两种常见的网络协议的支持：

* **TCP（Transmission Control Protocol，传输控制协议）**是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。 一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂， 只简单的描述下这三次对话的简单过程：

  1. 主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；
  2. 主机B向主机A发送同意连接和要求同步 （同步就是两台主机一个在发送，一个在接收，协调工作）的数据包 ：“可以，你什么时候发？”，这是第二次对话；
  3. 主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”， 这是第三次对话。

  > **三次“对话”的目的是使数据包的发送和接收同步， 经过三次“对话”之后，主机A才向主机B正式发送数据。**

* **UDP（User Data Protocol，用户数据报协议）**

  1. UDP是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。 在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、 计算机的能力和传输带宽的限制； 在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。
  2.  由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等， 因此一台服务机可同时向多个客户机传输相同的消息。
  3. UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。
  4. 吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、 源端和终端主机性能的限制。
  5. UDP使用尽最大努力交付，即不保证可靠交付， 因此主机不需要维持复杂的链接状态表（这里面有许多参数）。
  6. UDP是面向报文的。发送方的UDP对应用程序交下来的报文， 在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界， 因此，应用程序需要选择合适的报文大小。

  我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常。

  > **ping命令**是用来探测主机到主机之间是否可通信，如果不能**ping**到某台主机，表明不能和这台主机建立连接。
  >
  > **ping命令**是使用 IP 和网络控制信息协议 (ICMP)，因而没有涉及到任何传输协议(UDP/TCP) 和应用程序。它发送icmp回送请求消息给目的主机。
  >
  > ICMP协议规定：目的主机必须返回ICMP回送应答消息给源主机。如果源主机在一定时间内收到应答，则认为主机可达。

* 小结TCP与UDP的区别：

  1. 基于连接与无连接；
  2. 对系统资源的要求（TCP较多，UDP少）；
  3. UDP程序结构较简单；
  4. 流模式与数据报模式 ；
  5. TCP保证数据正确性，UDP可能丢包；
  6. TCP保证数据顺序，UDP不保证。

## 1.4 三次握手与四次挥手详解

连接三次握手与断开四次挥手详解

### 名词解释

序列号seq
确认号ack
确认ACK
同步SYN
终止FIN

![](..\图片\1-11【网络编程】\三次握手四次挥手1.png)

- 序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。

- 确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。

- 确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效

  ACK 是TCP报头的控制位之一，对数据进行确认。确认由目的端发出， 用它来告诉发送端这个序列号之前的数据段都收到了。 比如确认号为X，则表示前X-1个数据段都收到了，只有当ACK=1时,确认号才有效，当ACK=0时，确认号无效，这时会要求重传数据，保证数据的完整性。

- 同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。

  SYN 同步序列号，TCP建立连接时将这个位置1。

- 终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接

  FIN 发送端完成发送任务位，当TCP完成数据传输需要断开时,，提出断开连接的一方将这位置1

>  PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。

![](..\图片\1-11【网络编程】\三次握手四次挥手2.png)

**TCP（Transmission Control Protocol，传输控制协议）**是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。

**TCP三次握手过程**

第一次握手：主机A通过向主机B发送一个含有同步序列号的标志位的数据段给主机B，向主机B 请求建立连接，通过这个数据段， 主机A告诉主机B 两件事：我想要和你通信；你可以用哪个序列号作为起始数据段来回应我。

第二次握手：主机B 收到主机A的请求后，用一个带有确认应答（ACK）和同步序列号（SYN）标志位的数据段响应主机A，也告诉主机A两件事：我已经收到你的请求了，你可以传输数据了；你要用那个序列号作为起始数据段来回应我

第三次握手：主机A收到这个数据段后，再发送一个确认应答，确认已收到主机B 的数据段："我已收到回复，我现在要开始传输实际数据了，这样3次握手就完成了，主机A和主机B 就可以传输数据了。

**3次握手的特点**

没有应用层的数据 ,SYN这个标志位只有在TCP建立连接时才会被置1 ,握手完成后SYN标志位被置0。

**TCP建立连接要进行3次握手，而断开连接要进行4次**

第一次： 当主机A完成数据传输后,将控制位FIN置1，提出停止TCP连接的请求 ；

第二次： 主机B收到FIN后对其作出响应，确认这一方向上的TCP连接将关闭,将ACK置1；

第三次： 由B 端再提出反方向的关闭请求,将FIN置1 ；

第四次： 主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束.。

由TCP的三次握手和四次断开可以看出，TCP使用面向连接的通信方式， 大大提高了数据通信的可靠性，使发送数据端和接收端在数据正式传输前就有了交互， 为数据正式传输打下了可靠的基础。

### 三次握手过程理解

序列号seq
确认号ack
确认ACK
同步SYN
终止FIN

- 序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。

- 确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。

- 确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效

  ACK 是TCP报头的控制位之一，对数据进行确认。确认由目的端发出， 用它来告诉发送端这个序列号之前的数据段都收到了。 比如确认号为X，则表示前X-1个数据段都收到了，只有当ACK=1时,确认号才有效，当ACK=0时，确认号无效，这时会要求重传数据，保证数据的完整性。

- 同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。

  SYN 同步序列号，TCP建立连接时将这个位置1。

- 终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接

  FIN 发送端完成发送任务位，当TCP完成数据传输需要断开时,，提出断开连接的一方将这位置1

![](..\图片\1-11【网络编程】\三次握手.png)

1. 第一次握手：建立连接时，客户端发送SYN包（SYN=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。

2. 第二次握手：服务器收到SYN包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

3. 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。


### 四次挥手过程理解 

序列号seq
确认号ack
确认ACK
同步SYN
终止FIN

![](..\图片\1-11【网络编程】\四次挥手.png)

1. 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。

    TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。 

2. 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。 

   客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。

3. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。 

4. 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。 

   服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。 


### 常见面试题

【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？

​	**答**：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

​		    因为当 Server 端收到 Client 端的`SYN`连接请求报文后，可以直接发送`SYN+ACK`报文。**但是在关闭连接时，当 Server 端收到 Client 端发出的连接释放报文时，很可能并不会立即关闭 SOCKET**，所以 Server 端先回复一个`ACK`报文，告诉 Client 端我收到你的连接释放报文了。只有等到 Server 端所有的报文都发送完了，这时 Server 端才能发送连接释放报文，之后两边才会真正地断开连接。故需要四次挥手。

【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

​	**答**：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假想网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。
​			在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。
​			如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

> 所谓的2MSL是两倍的MSL(`Maximum Segment Lifetime`)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。

- **保证 A 发送的最后一个 ACK 报文段能够到达 B**。这个`ACK`报文段有可能丢失，B 收不到这个确认报文，就会超时重传连接释放报文段，然后 A 可以在`2MSL`时间内收到这个重传的连接释放报文段，接着 A 重传一次确认，重新启动 2MSL 计时器，最后 A 和 B 都进入到`CLOSED`状态，若 A 在`TIME-WAIT`状态不等待一段时间，而是发送完 ACK 报文段后立即释放连接，则无法收到 B 重传的连接释放报文段，所以不会再发送一次确认报文段，B 就无法正常进入到`CLOSED`状态。
- **防止已失效的连接请求报文段出现在本连接中**。A 在发送完最后一个`ACK`报文段后，再经过 2MSL，就可以使这个连接所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现旧的连接请求报文段。

【问题3】为什么不能用两次握手进行连接？

​	**答**：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。

​       现在把三次握手改成仅需要两次握手，死锁是可能发生的。

​		作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。

> ​		这主要是为了防止两次握手情况下**已失效的连接请求报文段突然又传送到服务端**，而产生了错误。考虑这样一种情况：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送ack包。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。
>
> ​		还有一种说法是：三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。**如果只是两次握手， 至多只有连接发起方的起始序列号能被确认**， 另一方选择的序列号则得不到确认

【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？

​	**答**：TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

## 1.5 网络编程三要素

### 协议

<!--P406-->

* **协议：**计算机网络通信必须遵守的规则。

### IP地址

* **IP地址：指互联网协议地址，俗称IP**。IP地址用来给一个网络中的计算机设备做为一个编号。加入我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就是“电话号码”。

**IP地址分类**

* IPv4：是一个32位的二进制数，通常别分为4个字节，表示成`a.b.c.d`的形式，例如`192.168.65.100`。其中a,b,c,d都是0~255之间的十进制整数，那么最多可以表示42亿个。

* IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但网络地址资源有限，是的IP的分配越发紧张。

  为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节为一组，分为8组十六进制数，表示成`ABCD:EF01:2345:6789:ABCD:EF01:2345:6789`，号称可以为全世界的每一粒沙子编一个网址，这样就解决了网络地址资源数量不够的问题。

**常用命令**

* 查看本机IP地址，在控制台输入：

  ```ABAP
  ipconfig
  ```

  对于Linux操作系统则不同，有的是：`ip addr`。

* 检查网络是否连通，在控制台输入：

  ```asciiarmor
  ping 空格 IP地址
  ping 220.182.34.23
  ```

**特殊的IP地址**

* 本机IP地址：`127.0.0.1`、`localhost`。

### 端口号

<!--P407-->

网络的通信，本质上是两个进程（应用程序）的通信，每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？

如果说**IP地址**可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的进程（应用程序）了。

* **端口号：用两个字节表示的整数，它的取值范围是0~65535。**其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或者应用所占用，会导致当前程序启动失败。

利用`协议`+`IP地址`+`端口号`三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其他进程进行交互。

![端口号](..\图片\1-11【网络编程】\4.png)

# 第二章 TCP通信程序

## 2.1 概述

<!--P408-->

<!--P409-->

TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。

**两端通信时步骤：**

1. 服务端程序，需要事先启动，等待客户端的连接。
2. 客户端主动连接服务器端，连接成功才能通信，服务端不可以主动连接客户端。

**在java中，提供了两个类用于事先TCP通信程序：**

1. 客户端：`java.net.Socket`类表示。创建`Socket`对象，向服务端发送连接请求，服务端响应请求，两者建立连接开始通信。
2. 服务端：`java.net.ServerSocket`类表示。创建`ServerSocket`对象，相当于开启一个服务，并等待服务端的连接。

![TCP通信程序](..\图片\1-11【网络编程】\5.png)

## 2.2 Socket

我们知道两个进程如果需要进行通讯最基本的一个前提能能够唯一的标示一个进程，在本地进程通讯中我们可以使用PID来唯一标示一个进程，但PID只在本地唯一，网络中的两个进程PID冲突几率很大，这时候我们需要另辟它径了，我们知道IP层的ip地址可以唯一标示主机，而TCP层协议和端口号可以唯一标示主机的一个进程，这样我们可以利用ip地址＋协议＋端口号唯一标示网络中的一个进程。

能够唯一标示网络中的进程后，它们就可以利用socket进行通信了，什么是socket呢？我们经常把socket翻译为套接字，socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。

![img](..\图片\1-11【网络编程】\Center2)

　Socket又称为套接字，它是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。当我们使用不同的协议进行通信时就得使用不同的接口，还得处理不同协议的各种细节，这就增加了开发的难度，软件也不易于扩展(就像我们开发一套公司管理系统一样，报账、会议预定、请假等功能不需要单独写系统，而是一个系统上多个功能接口，不需要知道每个功能如何去实现的)。

于是UNIX BSD就发明了socket这种东西，socket屏蔽了各个协议的通信细节，使得程序员无需关注协议本身，直接使用socket提供的接口来进行互联的不同主机间的进程的通信。这就好比操作系统给我们提供了使用底层硬件功能的系统调用，通过系统调用我们可以方便的使用磁盘（文件操作），使用内存，而无需自己去进行磁盘读写，内存管理。socket其实也是一样的东西，就是提供了tcp/ip协议的抽象，对外提供了一套接口，同过这个接口就可以统一、方便的使用tcp/ip协议的功能了。

　　其实站在你的角度上看，socket就是一个模块。我们通过调用模块中已经实现的方法建立两个进程之间的连接和通信。也有人将socket说成ip+port，因为ip是用来标识互联网中的一台主机的位置，而port是用来标识这台机器上的一个应用程序。 所以我们只要确立了ip和port就能找到一个应用程序，并且使用socket模块来与之通信。

**socket通信流程如下：**

socket是"打开—读/写—关闭"模式的实现，以使用TCP协议通讯的socket为例，其交互流程大概是这样子的

![img](..\图片\1-11【网络编程】\Center3)



- 服务器根据地址类型（ipv4,ipv6）、socket类型、协议创建socket
- 服务器为socket绑定ip地址和端口号
- 服务器socket监听端口号请求，随时准备接收客户端发来的连接，这时候服务器的socket并没有被打开
- 客户端创建socket
- 客户端打开socket，根据服务器ip地址和端口号试图连接服务器socket
- 服务器socket接收到客户端socket请求，被动打开，开始接收客户端请求，直到客户端返回连接信息。这时候socket进入**阻塞**状态，所谓阻塞即accept()方法一直到客户端返回连接信息后才返回，开始接收下一个客户端谅解请求
- 客户端连接成功，向服务器发送连接状态信息
- 服务器accept方法返回，连接成功
- 客户端向socket写入信息
- 服务器读取信息
- 客户端关闭
- 服务器端关闭

**利用Socket建立网络连接的步骤**

建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。

套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。

1. 服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。
2. 客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。
   为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。

3. 连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。
   而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。

## 2.2 Socket类

<!--P410-->

<!--socket一般指套接字。 所谓套接字(Socket) -->

`Socket`类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。

**构造方法**

* `public Socket(String host, int port)`: 创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null，则相当于指定地址为回送地址。

  * `String host`: 服务器主机的名称/服务器的IP地址
* `int port`：服务器的端口号
  
> 小贴士：回送地址(127.x.x.x)是本机回送地址(Loopback Address)，主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。

构造举例，代码如下：

```java
Socket client = new Socket("127.0.0.1", 6666);
```

**成员方法**

* `OutputStream getOutputStream()`: 返回此套接字的输出流。
* `InputStream getInputStream()`: 返回此套接字的输入流。
* `void close()`: 关闭此套接字。

**实现步骤**

1. 创建一个客户端对象`Socket`，构造方法绑定服务器的IP地址和端口号。

2. 使用`Socket`对象中的方法`getOutputStream()`获取网络字节输出流`OutputStream`对象。

3. 使用网络字节输出流`OutputStream`对象中的方法`write`，给服务器发送数据。

4. 使用`Socket`对象中的方法`InputStream()`获取网络字节输入流`InputStream`对象。

5. 使用网络字节输入流`InputStream`对象中的方法`read`，读取服务器回写的数据。

6. 释放资源(Socket)

   > 注意：
   >
   > * 客户端和服务器进行交互，必须使用Socket中提供的网络流，不能使用自己创建的流对象。
   > * 当我们创建客户端对象Socket的时候，就会去请求服务器和服务器经过3次握手，建立连接通路。
   >   * 这时如果服务器没有启动会抛出异常。`java.net.ConnectException: Connection refused: connect`
   >   * 如果已经启动，可以进行交互。

## 2.3 ServerSocket类

<!--P411-->

**构造方法**

* `ServerSocket(int port)`: 创建绑定到特定端口的服务器套接字。

**成员方法**

* `Socket accept()`：侦听并接受此套接字的连接。

**实现步骤**

1. 创建服务器`ServerSocket`对象和系统要指定的端口号。
2. 使用`ServerSoket`对象中的方法`accept`，获取到请求的客户端对象`Socket`。
3. 使用`Socket`对象中的方法`getInputStream()`获取网络字节输入流`InputStream`对象。
4. 使用网络字节输入流`InputStream`对象的`read`方法，读取客户端发送的数据。
5. 使用Socket对象中的方法`getOutputStream()`获取网络字节输出流`OutputStream`对象。
6. 使用网络字节输出流`OutputStream`对象的`write`方法，回写数据。
7. 释放资源（Socket，ServerSocket）

## 2.4 简单的TCP网络程序

**客户端向服务器发送数据**

```java
public class Demo01TcpClient {
    public static void main(String[] args) throws IOException {
        // 1. 创建一个客户端对象Socket，构造方法绑定服务器的IP地址和端口号。
        Socket socket = new Socket("127.0.0.1", 1000);
        // 2. 使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象。
        OutputStream os = socket.getOutputStream();
        // 3. 使用网络字节输出流OutputStream对象中的方法write，给服务器发送数据。
        os.write("林炫你好".getBytes());
        // 4. 使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象。
        InputStream is = socket.getInputStream();
        // 5. 使用网络字节输入流InputStream对象中的方法read，读取服务器回写的数据。
        byte[] bytes = new byte[1024];
        int len = is.read(bytes);
        System.out.println(new String(bytes, 0, len));
        // 6. 释放资源(Socket)
        socket.close();
    }
}
```

**服务器向客户端回写数据**

```java
public class Demo01TCPServer {
    public static void main(String[] args) throws IOException {
        // 1. 创建服务器ServerSocket对象和系统要指定的端口号。
        ServerSocket serversocket = new ServerSocket(1000);
        // 2. 使用ServerSoket对象中的方法accept，获取到请求的客户端对象Socket。
        Socket socket = serversocket.accept();
        // 3. 使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象。
        InputStream is = socket.getInputStream();
        // 4. 使用网络字节输入流InputStream对象的read方法，读取客户端发送的数据。
        byte[] bytes = new byte[1024];
        int len = is.read(bytes);
        System.out.println(new String(bytes, 0, len));
        // 5. 使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象
        OutputStream os = socket.getOutputStream();
        // 6. 使用网络字节输出流OutputStream对象的write方法，回写数据
        os.write("收到谢谢".getBytes());
        // 7. 释放资源（Socket，ServerSocket）
        socket.close();
        serversocket.close();
    }
}
```

# 第三章 综合案例

## 3.1 文件上传案例

<!--P412-->

1. 【客户端】输入流，从硬盘读取文件数据到程序中。
2. 【客户端】输出流，写出文件数据到服务端。
3. 【服务端】输入流，读取文件数据到服务端程序。
4. 【服务端】输出流，写出文件数据到服务器硬盘中。

<!--P413-->

**客户端**

1. 创建一个本地字节输入流`FileInputStream`对象，构造方法中绑定要读取的数据源。
2. 创建一个客户端`Socket`对象，构造方法中绑定服务器的IP地址和端口号。
3. 使用`Socket`中的方法`getOutputStream`，获取网络字节输出流`OutputStream`对象。
4. 使用本地字节输入流`FileInputStream`对象的`read`方法，读取本地文件。
5. 使用网络字节输出流`OutputStream`对象中的`write`方法，把读取到的文件上传到服务器。
6. 使用`Socket`中的方法`getInputStream`，获取网络字节输入流`InputStream`对象。
7. 使用网络字节输入流`InputStream`对象中的read方法读取服务端回写的数据。
8. 释放资源（FileInputStream, Socket）。

```java
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;

// 客户端
public class TCPClient {
    public static void main(String[] args) throws IOException {
        // 1. 创建一个本地字节输入流FileInputStream对象，构造方法中绑定要读取的数据源。
        FileInputStream fis = new FileInputStream("D:\\图片\\动漫\\清纯诱惑\\12.jpg");
        // 2. 创建一个客户端Socket对象，构造方法中绑定服务器的IP地址和端口号。
        Socket socket = new Socket("127.0.0.1", 8888);
        // 3. 使用Socket中的方法getOutputStream，获取网络字节输出流OutputStream对象。
        OutputStream os = socket.getOutputStream();
        // 4. 使用本地字节输入流FileInputStream对象的read方法，读取本地文件。
        byte[] bytes = new byte[1024];
        int len = 0;
        while((len = fis.read(bytes)) != -1) {
            // 5. 使用网络字节输出流OutputStream对象中的write方法，把读取到的文件上传到服务器。
            os.write(bytes, 0, len);
        }

        // 6. 使用Socket中的方法getInputStream，获取网络字节输入流InputStream对象。
        InputStream is  = socket.getInputStream();
        // 7. 使用网络字节输入流InputStream对象中的read方法读取服务端回写的数据。
        len = 0;
        while((len = is.read(bytes)) != -1) {
            System.out.println(new String(bytes, 0, len));
        }
        // 8. 释放资源（FileInputStream, Socket）。
        fis.close();
        socket.close();
    }
}
```

<!--P414-->

**服务器端**

1. 创建一个服务器`ServerSocket`对象，和系统要指定的端口号。
2. 使用`ServerSocket`对象中的`accept`方法，获取到要请求的客户端`Socket`对象。
3. 判断文件夹是否存在，不存在则创建。
4. 使用`Socket`对象中的方法`getInputStream`，获取到网络字节输入流`InputStream`对象。
5. 使用网络字节输入流`InputStream`对象中的read方法，读取客户端上传的文件。
6. 创建一个本地字节输出流`FileOutputStream`对象，构造方法中绑定要输出的目的地。
7. 使用本地字节输出流`FileOutputStream`对象中的`write`方法，把读取到的文件保存到服务器的硬盘上。
8. 使用Socket对象中的方法`getOutputStream`，获取到网络字节输入流`OutputStream`对象。
9. 使用网络字节输出流`OutputStream`对象中的方法`write`，给客户端回写“上传成功”。
10. 释放资源（FileOutputStream, Socket, ServerSocket）。

```java
import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

public class TCPServer {
    public static void main(String[] args) throws IOException {
        // 1. 创建一个服务器ServerSocket对象，和系统要指定的端口号。
        ServerSocket serversocket = new ServerSocket(8888);
        // 2. 使用ServerSocket对象中的accept方法，获取到要请求的客户端Socket对象。
        Socket socket = serversocket.accept();
        // 3. 使用Socket对象中的方法getInputStream，获取到网络字节输入流InputStream对象。
        InputStream is = socket.getInputStream();
        // 4. 判断文件夹是否存在，不存在则创建。
        File file = new File("D:\\Java\\Upload");
        if (!file.exists()) {
            file.mkdirs();
        }
        // 5. 创建一个本地字节输出流FileOutputStream对象，构造方法中绑定要输出的目的地。
        FileOutputStream fos = new FileOutputStream(file + "\\1.jpg");
        // 6.使用网络字节输入流InputStream对象中的read方法，读取客户端上传的文件。
        byte[] bytes = new byte[1024];
        int len = 0;
        while((len = is.read(bytes)) != -1) {
            // 7. 使用本地字节输出流FileOutputStream对象中的write方法，把读取到的文件保存到服务器的硬盘上。
            fos.write(bytes, 0, len);
        }
        // 8. 使用Socket对象中的方法getOutputStream，获取到网络字节输入流OutputStream对象。
        OutputStream os = socket.getOutputStream();
        // 9. 使用网络字节输出流OutputStream对象中的方法write，给客户端回写“上传成功”。
        os.write("上传成功".getBytes());
        // 10. 释放资源（FileOutputStream, Socket, ServerSocket）。
        fos.close();
        socket.close();
        serversocket.close();
    }
}
```

<!--P415-->

**问题**

* 上传完文件后，一直不结束，陷入死循环，需要结束标记
* void shutdownOutput() 禁用此套接字的输出流
* 对于TCP套接字，任何以前写入对的数据将被发送，并且后跟TCP的正常终止序列。

```java
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;

// 客户端
public class TCPClient {
    public static void main(String[] args) throws IOException {
        // 1. 创建一个本地字节输入流FileInputStream对象，构造方法中绑定要读取的数据源。
        FileInputStream fis = new FileInputStream("D:\\图片\\动漫\\清纯诱惑\\12.jpg");
        // 2. 创建一个客户端Socket对象，构造方法中绑定服务器的IP地址和端口号。
        Socket socket = new Socket("127.0.0.1", 8888);
        // 3. 使用Socket中的方法getOutputStream，获取网络字节输出流OutputStream对象。
        OutputStream os = socket.getOutputStream();
        // 4. 使用本地字节输入流FileInputStream对象的read方法，读取本地文件。
        int len = 0;
        byte[] bytes = new byte[1024];
        while((len = fis.read(bytes)) != -1) {
            // 5. 使用网络字节输出流OutputStream对象中的write方法，把读取到的文件上传到服务器。
            os.write(bytes, 0, len);
        }

        // 上传完文件后，一直不结束，陷入死循环，需要结束标记
        // void shutdownOutput() 禁用此套接字的输出流
        // 对于TCP套接字，任何以前写入对的数据将被发送，并且后跟TCP的正常终止序列。
        socket.shutdownOutput();

        // 6. 使用Socket中的方法getInputStream，获取网络字节输入流InputStream对象。
        InputStream is  = socket.getInputStream();
        // 7. 使用网络字节输入流InputStream对象中的read方法读取服务端回写的数据。
        while((len = is.read(bytes)) != -1) {
            System.out.println(new String(bytes, 0, len));
        }
        // 8. 释放资源（FileInputStream, Socket）。
        fis.close();
        socket.close();
    }
}
```

## 3.2 文件上传优化分析

<!--P416 1.14-->

1. 文件名称写死问题

   服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一。

   ```java
   FileOutputStream fis = new FileOutputStream(System.currentTimeMillis()."jpg");// 文件名称
   BufferedOutputStream bos = new BufferedOutputStream(fis);
   ```

2. 循环接收的问题

   服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断接收不同用户的文件。

   ```java
   // 每次接收新的连接，创建一个新的Socket
   while (true) {
       Socket socket = new Socket.accept();
       ...
   }
   ```

3. 效率问题

   服务端，在接收大文件时，可能耗费几秒时间，此时不能接收其他用户上传，所以使用多线程技术优化。

   ```java
   while (true) {
       new Thread(new Runnable() {
           @Override
           public void run() {
               try{
                   ...
               } catch(IOException e) {
                   System.out.println(e);
               }
           }
       }).start();
   }
   ```

优化实现如下：

```java
import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Random;

// 服务器端
public class TCPServer {
    public static void main(String[] args) throws IOException {
        // 1. 创建一个服务器ServerSocket对象，和系统要指定的端口号。
        ServerSocket serversocket = new ServerSocket(8888);

        // 让服务器一直处于监听状态，一直运行，使用死循环
        while (true) {
            // 2. 使用ServerSocket对象中的accept方法，获取到要请求的客户端Socket对象。
            Socket socket = serversocket.accept();

            // 使用多线程的方式，让多个客户端上传文件
            new Thread(new Runnable() {
                // 重写run方法，完成文件的上传
                @Override
                public void run() {
                    try {
                        // 3. 使用Socket对象中的方法getInputStream，获取到网络字节输入流InputStream对象。
                        InputStream is = socket.getInputStream();
                        // 4. 判断文件夹是否存在，不存在则创建。
                        File file = new File("D:\\Java\\Upload");
                        if (!file.exists()) {
                            file.mkdirs();
                        }

                        // 服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一。
                        String filename = "com.cn" + System.currentTimeMillis() + new Random().nextInt(123456) + ".jpg";
                        // 5. 创建一个本地字节输出流FileOutputStream对象，构造方法中绑定要输出的目的地。
                        // FileOutputStream fos = new FileOutputStream(file + "\\12.jpg");
                        FileOutputStream fos = new FileOutputStream(file + "\\" + filename);

                        // 6.使用网络字节输入流InputStream对象中的read方法，读取客户端上传的文件。
                        byte[] bytes = new byte[1024];
                        int len = 0;
                        while((len = is.read(bytes)) != -1) {
                            // 7. 使用本地字节输出流FileOutputStream对象中的write方法，把读取到的文件保存到服务器的硬盘上。
                            fos.write(bytes, 0, len);
                        }
                        // 8. 使用Socket对象中的方法getOutputStream，获取到网络字节输入流OutputStream对象。
                        OutputStream os = socket.getOutputStream();
                        // 9. 使用网络字节输出流OutputStream对象中的方法write，给客户端回写“上传成功”。
                        os.write("上传成功".getBytes());
                        // 10. 释放资源（FileOutputStream, Socket, ServerSocket）。
                        fos.close();
                        socket.close();
                    } catch(IOException e) {
                        System.out.println(e);
                    }
                }
            }).start();
        }

        // 服务器不用关闭了，一直启动着
        // serversocket.close();
    }
}
```

## 3.2 模拟B/S服务器

<!--P417-->

模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。

1. 准备页面数据，web文件夹

   复制到我们Moudule中。

2. 我们模拟服务器端，ServerSocket类监听端口，使用浏览器访问。

<!--P418-->

```java
import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

// 创建B/S版本TCP服务器
public class TCPServer {
    public static void main(String[] args) throws IOException {
        // 创建一个服务器ServerSocket，并指定端口号
        ServerSocket serversocket = new ServerSocket(8080);

        // 浏览器解析服务器回写的HTML文件，如果有图片，那么会重新单独的开启一个线程
        // 所以我们需要让服务器一直处于监听状态，然后使用多线程
        while(true) {
            // 使用accept方法获取到请求的客户端对象（浏览器）
            Socket socket = serversocket.accept();

            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        // 使用soket对象中的getInputStream方法，获取到网络字节输入流InputStream对象
                        InputStream is = socket.getInputStream();
                        // 使用网络字节输入流InputStream对象中的方法read读取客户端的请求信息
            /*
                    byte[] bytes = new byte[1024];
                    int len = 0;
                    while ((len = is.read(bytes)) != -1) {
                        System.out.println(new String(bytes, 0, len));
                    }
            */


                        // 把is网络字节输入流对象，转换为字符缓冲输入流
                        BufferedReader br = new BufferedReader(new InputStreamReader(is));
                        // 把客户端请求信息的第一行读取出来 GET /11_Net/web/index.html HTTP/1.1
                        String line = br.readLine();
                        // 把读取的信息进行切割，只要中间部分 /11_Net/web/index.html
                        String[] array = line.split(" ");
                        // 把路径前面的/去掉，截取路径 11_Net/web/index.html
                        String htmlpath = array[1].substring(1);

                        // 创建一个本地输入流，构造方法中绑定要读取的HTML路径
                        FileInputStream fis = new FileInputStream(htmlpath);
                        // 使用Socket中的方法getOutputStream获取网络字节输出流OutputStream对象
                        OutputStream os = socket.getOutputStream();

                        // 写入HTTP协议响应开头，固定写法
                        os.write("HTTP/1.1 200 OK\r\n".getBytes());
                        os.write("Content-Type:text/html\r\n".getBytes());
                        // 必须写入空行，否则浏览器不会解析
                        os.write("\r\n".getBytes());

                        // 一读一写复制文件，把服务器读取的HTML文件回写到客户端
                        int len = 0;
                        byte[] bytes = new byte[1024];
                        while((len = fis.read(bytes)) != -1) {
                            os.write(bytes,0, len);
                        }

                        // 释放资源
                        fis.close();
                        socket.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }).start();
        }
        
        // 不用关闭服务器
        // serversocket.close();
    }
}
```

