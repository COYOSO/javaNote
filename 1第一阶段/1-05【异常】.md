# 第一章 异常

## 1.1 异常概念

异常，就是不正常的意思。在生活中：医生说，你的身体某个部位有异常，该部位和正常相比有点不同，该部位的功能将受到影响。在程序中的意思是：

* **异常**：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。

在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常并抛出一个异常对象。Java处理异常的方式是中断处理。

> 异常指的并不是语法错误，语法错了，编译不通过，不会产生字节码文件，根本不能运行。

## 1.2 异常体系

异常机制其实就是帮助我们**找到**程序中的问题，异常的根类是`java.lang.Throwable` ，其下有两个子类：`java.lang.Error`与`java.lang.Exception`，平常所说的异常指`java.lang.Exception`。 

<!-- throw 投; 掷; 抛; 扔; 摔; 丢; 猛推; 使劲撞; able 能够的; 能; 能够；--> 

<!-- exception 例外 -->

<!-- expect 预料 期待 期望-->

**Throwable体系：**

* **Error**：严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。
* **Exception**：表示异常，异常产生后程序员可以通过代码的方式修正，使程序继续执行，是必须要处理的。好比感冒、阑尾炎。

**Throwable中的常用方法：**

* `public void printStackTrace()`：打印异常的详细信息。

  包含了异常的类型，异常的原因，还包括异常出现的位置，在开发和调试阶段，都得使用printStackTrace。

* `public String getMessage()`：获取发生异常的原因。

  提示给用户的时候，就提示错误原因。

* `public String toString()`：获取异常的类型和异常描述信息(不用)。

**出现异常，不要紧张，把异常的简单类型名，拷贝到API中去查。**

## 1.3 异常分类

我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。

**异常(Exception)的分类**：根据在编译时期还是运行时期去检查异常？

* **编译时期异常**：checked异常。在编译时期，就会检查，如果没有处理异常，则编译失败。（如日期格式化异常）
* **运行时期异常**：runtime异常。在运行时期，检查异常。在编译时期，运行异常不会编译器检测（不报错）。（如科学异常）

**代码如下：**

```java
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class Demo01Exception {
    public static void main(String[] args) throws ParseException {
        // Exception:编译时期异常，进行编译（写代码）java程序出现的问题
        SimpleDateFormat sdf = new SimpleDateFormat("yyy-MM-dd");// 用来格式化日期
        // 出现异常，使用抛出异常的方式
        Date date = sdf.parse("1999-09-09");// 把字符串格式的日期，解析为Date格式的日期。
        System.out.println(date);
    }
}
```

```java
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class Demo01Exception {
    public static void main(String[] args) {
        // Exception:编译时期异常，进行编译（写代码）java程序出现的问题
        SimpleDateFormat sdf = new SimpleDateFormat("yyy-MM-dd");// 用来格式化日期
        // 出现异常，使用try-catch方式
        Date date = null;
        try {
            date = sdf.parse("1999-09-09");// 把字符串格式的日期，解析为Date格式的日期。
        } catch (ParseException e) {
            e.printStackTrace();
        }
        System.out.println(date);
    }
}
```

```java
public class Demo01Exception {
    public static void main(String[] args) {
        // RuntimeException:运行期异常，java程序运行过程中出现的问题
        int[] arr = {1, 2, 3};
        System.out.println(arr[0]);

        try {
            // 可能会出现异常的代码
            System.out.println(arr[3]);
        } catch(Exception e) {
            // 异常的处理逻辑
            System.out.println(e);
        }
        System.out.println("后续代码");
    }
}

```

```java
public class Demo01Exception {
    public static void main(String[] args) {
        /*
            Error:错误
            OutOfMemoryError：java heap space
            内存溢出的错误，创建的数组太大了，超过了给JVM分配的内存
         */
        // int[] arr = new int[1024 * 1024 * 1024];// 必须修改代码，创建的数组小一点
        int[] arr = new int[1024 * 1024];
        System.out.println("后续代码");

    }
}
```

## 1.4 异常的产生过程解析

<!--P290-->

先运行下面的程序，程序会产生一个数组索引越界异常`ArrayIndexOfBoundsException`。

![异常的产生过程解析](..\图片\1-05【异常】\1-1.4 异常的产生过程解析.png)

## 1.5 异常 中断与陷入

**中断/异常/陷入机制**是操作系统由用户态转为内核态的唯一途径，是操作系统的驱动力。

一个故事：小明在看书，突然来了个电话，接完电话继续看书，这是中断；小明在看书，感觉口渴了，喝了水接着看书，这是异常。

![](..\图片\1-05【异常】\2-中断与异常.jpg)

* 中断：中断是指 CPU 对系统发生某事件时的这样一种响应:

  CPU 暂停正在执行的程序，在保留现场后自动地转去执行该事件的中断处理程序；执行完后，再返回到原程序的断点处继续执行。

* 异常：异常是由当前正在执行的进程产生。

  异常包括很多方面，有出错（fault），有陷入（trap），也有可编程异常（programmable exception）。

### 中断

- 外中断——就是我们指的**中断**——是指由于外部设备事件所引起的中断，如通常的磁盘中断、打印机中断等；
- 内中断——就是**异常**——是指由于 CPU 内部事件所引起的中断，如程序出错(非法指令、地址越界)。
  内中断(trap)也被译为“**捕获**”或“**陷入**”。

![](..\图片\1-05【异常】\3-事件.png)

### 中断与异常

* **中断、异常的区别**

  - 中断属外部事件，是正在运行的程序所不期望的

  - 异常由正在执行的指令引发
  - **相同点：**都是**CPU**对**系统**发生的某**个事情**做出的**一种反应**。
  - **区别**：中断由外因引起，异常由CPU本身原因引起。

* **中断/异常的引入目的**

  - 中断的引入是为了CPU与设备之间的并行操作

  - 异常的引入是为了表示CPU执行指令时本身出现的问题

* **故障与陷入**

  - 缺页异常（page fault），由于是fault，所以当缺页异常处理完成之后，还会去尝试重新执行那条触发异常的指令（那时多半情况是不再缺页）

  - 断点处理，用于调试中，遇到断点会停下来等待你的处理，等到你让其重新执行了，就直接执行下一条指令

### 中断与陷入

* **中断与陷入的联系**
  * 外中断时指来自处理机和内存外部的中断,如I/O中断、定时器中断、外部信号中断等。狭义上也叫中断;
  * 内中断主要指在处理机和内存内部产生的中断，也称陷入，如校验错、页面失效、溢出、除数为零等。
* **中断与陷入的主要区别**
  * 陷入通常由处理机正在执行的现行指令引起，而中断则是由与现行指令无关的中断源引起的。
  * 陷阱处理程序提供的服务为当前进程所用，而中断处理程序提供的服务则不是为了当前进程的。
  * CPU 在执行完一条指令之后，下一条指令开始之前响应中断，而在一条指令执行中也可以响应陷阱。
  * 在有的系统中，陷入处理程序被规定在各自的进程上下文中执行，而中断处理程序则在系统上下文中执行。

# 第二章 异常的处理

Java异常处理的五个关键字：try、catch、finally、throw、throws

## 2.1 抛出异常throw

<!--P291-->

在编写程序的时候，我们必须要考虑程序出现的问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接收到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。

在Java中，提供了一个**throw**关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？

1. 创建一个异常对象。封装一些提示信息（信息可以自己编写）。

2. 需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw异常对象。

   throw**用在方法内**，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。

## 2.2 Objects非空判断

<!--P292-->

还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或者null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。

* `public static <T> T requireNonNull(T obj)`:查看指定引用对象不是null。

查看源码发现这里对为null的进行了抛出异常操作：

```java
public static <T> T requireNOnNUll(T Obj) {
    if (obj == null)
        throw new NullPointerException();
    return obj;
}
```

```java
import java.util.Objects;

public class Demo04Objects {
    public static void main(String[] args) {
        method(null);
    }

    public static void method(Object obj) {
        // 对传递过来的参数进行合法性判断，判断是否为null
        /*if (obj == null) {
            throw new NullPointerException("传递的对象的值是null");
        }*/

        // Objects.requireNonNull(obj);
        Objects.requireNonNull(obj, "传递的对象的值是null");
    }
}
```

## 2.3 声明异常throws

<!--P293-->

**声明异常**：将问题标识出来，报告给调用者，如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。

关键字**throws**运用于方法声明之上，用于表示当前方法不处理异常，而是提醒该方法的调用者来处理异常（抛出异常）。

**异常声明格式：**

`修饰符 返回值类型 方法名(参数) throws 异常类名1，异常类名2...{    }`

**throws关键字**：异常处理的第一种方式，交给别人来处理

**作用**：

* 当方法内部抛出异常对象的时候，那么我们就必须处理这个异常对象
* 可以使用throws关键字处理异常对象，会把异常对象声明抛出给方法的调用者处理（自己不处理，给别人处理），最终转交给JVM处理-->中断处理

**注意**：

* throws关键字必须写在方法声明处

* throws关键字后边声明的异常必须是Exception或者是Exception的子类

* 方法内部如果跑出了多个异常对象，那么throws后边必须也声明多个异常

  如果抛出的多个异常对象有子父类关系，那么直接声明父类异常即可

* 调用一个声明抛出异常的方法，我们就必须处理声明的异常

  要么继续使用throws声明抛出，交给方法的调用者处理，最终给JVM

  要么try...catch自己处理异常

```java
import java.io.FileNotFoundException;
import java.io.IOException;

public class Demo05Throws {

    // IOException是FileNotFoundException父类，所以只需抛出IOException
    public static void main(String[] args) throws IOException {
        readFile("c:\\a.txt");
    }

    /*
        定义一个方法，对传递的文件路径进行合法性判断
        如果路径不是“c:\a.txt”，那么我们就抛出文件找不到异常对象，告知方法的调用者
        注意：
            FileNotFoundException是编译异常，抛出了编译异常，就必须处理这个异常
            可以使用throws继续声明抛出FileNotFoundException这个异常对象，让方法的调用者处理
     */
    // IOException是FileNotFoundException父类，所以只需抛出IOException
    public static void readFile(String fileName) throws IOException {
        if (!fileName.equals("c:\\a.txt")) {
            throw new FileNotFoundException("传递的文件路径不是c:\\a.txt");
        }

        if (!fileName.endsWith(".txt")) {
            throw new IOException("文件名的后缀不对");
        }

        System.out.println("路径没有问题，读取文件");

    }
}
```

## 2.4 捕获异常try...catch

<!--P294-->

如果使用异常出现的话，会立刻终止程序，所以我们得处理异常：

1. 该方法不处理，而是声明抛出，由该方法的调用者来处理(throws)。
2. 在方法中使用try-catch的语句块来处理异常。

**try-catch**的方式就是捕获异常。

* **捕获异常**：java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。

捕获异常语法如下：

try...catch：异常处理的第二种方式，自己处理异常

```java
/*
    try {
        可能产生异常的代码
    } catch(定义一个异常的变量，用来接收try中抛出的异常对象) {
        异常的处理逻辑，异常对象之后，怎么处理异常对象
        一般在工作中，会把异常的信息记录到一个日志中
    }
    ...
    catch(异常类名 变量名) {

    }
*/
```

注意：

1. try中可能会抛出多个异常对象，那么就可以使用多个catch来处理这些异常对象

2. 如果try中产生了异常，那么就会执行catch中的异常处理逻辑，执行完毕catch中的处理逻辑，继续执行try...catch之后的代码

   如果try中没有产生异常，那么就不会执行catch中异常的处理逻辑，执行完try中的代码，继续执行try...catch之后的代码

```java
import java.io.IOException;

public class Demo01TryCatch {
    public static void main(String[] args) {
        try {
            // 可能产生异常的代码
            // d:\\a.txt和d:\\a.tx的结果是不一样的
            readFile("d:\\a.txt");
        } catch (IOException e) {// try中抛出什么异常对象，catch就定义什么异常变量，用来接收这个异常对象
            // 异常的处理逻辑，异常对象之后，怎么处理异常对象
            System.out.println("传递的文件不是.txt");
        }
        System.out.println("后续代码");
    }

    /*
        如果传递的路径，不是.txt结尾
        那么我们就抛出IO异常对象，告知方法的调用者，文件的后缀名不对
     */
    public static void readFile(String fileName) throws IOException {
        if (!fileName.endsWith(".txt")) {
            throw new IOException("文件名的后缀不对");
        }
        System.out.println("路径没有问题，读取文件");
    }
}
```

<!--P295-->

如何获取异常信息：

Throwable类中定义了一些查看方法：

* `public String getMessage`():获取异常的描述信息，原因（提示给用户的时候，就提示错误原因）。

* `public String toString`():获取异常的类型和异常描述信息（不用）。

* `public void printStackTrace`():打印异常的跟踪栈信息并输出到控制台。

  *包含了异常的类型，异常的原因，还包括异常出现的位置，在开发和调试的阶段，都得使用printStackTrace。*

```java
import java.io.IOException;

public class Demo01TryCatch {
    public static void main(String[] args) {
        try {
            // 可能产生异常的代码
            // d:\\a.txt和d:\\a.tx的结果是不一样的
            readFile("d:\\a.tx");
        } catch (IOException e) {// try中抛出什么异常对象，catch就定义什么异常变量，用来接收这个异常对象
            // 异常的处理逻辑，异常对象之后，怎么处理异常对象
            // System.out.println("传递的文件不是.txt");

            /*
                Throwable类中定义了3个异常处理的方法
                String getMessage() 返回此throwable的简短描述
                String toString() 返回此throwable的详细消息字符串
                void printStackTrace() JVM打印异常对象，默认此方法，打印的异常信息是最全面的
             */
            // System.out.println(e.getMessage());// 文件名的后缀不对
            // System.out.println(e.toString()); // 重写Object类的toString方法  java.io.IOException: 文件名的后缀不对
            // System.out.println(e);// java.io.IOException: 文件名的后缀不对

            /*
                java.io.IOException: 文件名的后缀不对
                    at cn.demo02.Demo01TryCatch.readFile(Demo01TryCatch.java:36)
                    at cn.demo02.Demo01TryCatch.main(Demo01TryCatch.java:10)
             */
            e.printStackTrace();

        }
        System.out.println("后续代码");
    }

    /*
        如果传递的路径，不是.txt结尾
        那么我们就抛出IO异常对象，告知方法的调用者，文件的后缀名不对
     */
    public static void readFile(String fileName) throws IOException {
        if (!fileName.endsWith(".txt")) {
            throw new IOException("文件名的后缀不对");
        }
        System.out.println("路径没有问题，读取文件");
    }
}
```

在开发中也可以在catch将编译器异常转化成运行期异常处理。

多个异常使用捕获又该如何处理呢？

1. 多个异常分别处理。
2. 多个异常一次捕获，多次处理。
3. 多个异常一次捕获一次处理。

## 2.4 finally代码块

<!--P296 12.22-->

**finally**：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。

什么时候的代码必须最终执行？

当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等)，我们都得在使用完之后，最终关闭打开的资源。

finally的语法：

try...catch...finally:自身需要处理异常，最终还得关闭资源。

> 注意：finally不能单独使用。

比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。

finally代码参考如下：

```java
/*
    try {
        可能产生异常的代码
    } catch(定义一个异常的变量，用来接收try中抛出的异常对象) {
        异常的处理逻辑，异常对象之后，怎么处理异常对象
        一般在工作中，会把异常的信息记录到一个日志中
    }
    ...
    catch(异常类名 变量名) {

    }finally {
        无论是否出现异常都会执行
    }
    注意：
        1.finally不能单独使用，必须和try一起使用
        2.finally一般用于资源释放(资源回收)，无论程序是否出现异常，最后都要资源释放(IO)
*/
```

```java
import java.io.IOException;

public class Demo02TryCatchFinally {

    public static void main(String[] args) {
        try {
            readFile("c:\\a.txt");
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            System.out.println("资源释放");
        }
    }

    public static void readFile(String fileName) throws IOException {
        if (!fileName.endsWith(".txt")) {
            throw new IOException("文件名的后缀不对");
        }
        System.out.println("路径没有问题，读取文件");
    }
}
```

## 2.5 异常注意事项

<!--P297-->

* 多个异常使用捕获又该如何处理呢？

  1. 多个异常分别处理。
  2. 多个异常一次捕获，多次处理。
  3. 多个异常一次捕获一次处理。

  一般我们时使用一次捕获多次处理方式，格式如下：

```java
	try {
        编写可能会出现异常的代码
    } catch(异常类型A e) {当try中出现A类型异常，就用该catch来捕获。
        处理异常的代码
        // 记录日志/打印异常信息/继续抛出异常
    } catch(异常类型B e) {当try中出现B类型异常，就用该catch来捕获。
        处理异常的代码
        // 记录日志/打印异常信息/继续抛出异常
    }
```

> 注意：这种异常处理方式，要求多个catch中的异常不能想同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。

```java
import java.util.List;

/*
    try {
        编写可能会出现异常的代码
    } catch(异常类型A e) {当try中出现A类型异常，就用该catch来捕获。
        处理异常的代码
        // 记录日志/打印异常信息/继续抛出异常
    } catch(异常类型B e) {当try中出现B类型异常，就用该catch来捕获。
        处理异常的代码
        // 记录日志/打印异常信息/继续抛出异常
    }
 */
public class Demo01Exception {
    public static void main(String[] args) {

        /*
            多个异常使用捕获又该如何处理呢？
                1. 多个异常分别处理。
                2. 多个异常一次捕获，多次处理。
                3. 多个异常一次捕获一次处理。
         */

        // 1.多个异常分别处理。
        /*try {
            int[] arr = {1, 2, 3};
            System.out.println(arr[3]);// ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println(e);
        }*/

        /*try {
            List<Integer> list = List.of(1, 2, 3);
            System.out.println(list.get(3));// IndexOutOfBoundsException :Index 3 out of bounds for length 3
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println(e);
        }*/

        // 2.多个异常一次捕获，多次处理
        /*
            一个try多个catch注意事项：
                catch里面定义的异常变量，如果有子父类关系，那么子类的异常白能量必须写在上面，否则就会报错
                ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException
         */
        /*try {
            int[] arr = {1, 2, 3};
            System.out.println(arr[3]);// ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3
            List<Integer> list = List.of(1, 2, 3);
            System.out.println(list.get(3));// IndexOutOfBoundsException :Index 3 out of bounds for length 3
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println(e);
        } catch (IndexOutOfBoundsException e) {
            System.out.println(e);
        }*/

        // 3.多个异常一次捕获一次处理
        try {
            int[] arr = {1, 2, 3};
            System.out.println(arr[3]);// ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3
            List<Integer> list = List.of(1, 2, 3);
            System.out.println(list.get(3));// IndexOutOfBoundsException :Index 3 out of bounds for length 3
        } catch (Exception e) {
            System.out.println(e);
        }
        System.out.println("后续代码！");

    }
}
```

* 运行时异常被抛出可以不处理。即不捕获也不声明抛出。

<!--P298-->

* 如果finally有return语句，永远返回finally中的结果，避免该情况。

```java
/*
    如果finally有return语句，永远返回finally中的结果，我们要避免这种情况的发生
 */
public class Demo02Exception {
    public static void main(String[] args) {
        int a = getA();
        System.out.println(a);
    }

    // 定义一个方法，返回变量a的值
    public static int getA() {
        int a = 10;

        try {
            return a;
        } catch(Exception e) {
            System.out.println(e);
        } finally {
            // 这是一定会执行的代码
            a = 100;
            return a;
        }
    }
}
```

<!--P299-->

* 如果父类抛出了多个异常，子类重写父类方法时，抛出和父类相同的异常或者是父类异常的子集或者不抛出异常。
* 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出
* 父类异常什么样子，子类异常就是什么样子

```java
/*
    - 如果父类抛出了多个异常，子类重写父类方法时，抛出和父类相同的异常或者是父类异常的子集或者不抛出异常。
    - 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出
    注意：
        父类异常什么样子，子类异常就是什么样子

 */
public class Fu {
    public void show01() throws NullPointerException, ClassCastException{}
    public void show02() throws IndexOutOfBoundsException{}
    public void show03() throws IndexOutOfBoundsException{}
    public void show04() {}
}

class Zi extends Fu {
    // 子类重写父类方法时，抛出和父类相同的异常
    public void show01() throws NullPointerException, ClassCastException{}
    // 子类重写父类方法时，抛出父类异常的子集
    public void show02() throws ArrayIndexOutOfBoundsException{}
    // 子类重写父类方法时，不抛出异常
    public void show03() {}

    /*
        父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。
        此时子类产生该异常，只能捕获处理，不能声明抛出
     */
    public void show04() {
        try {
            throw new Exception("编译期异常");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

* 在try/catch后可以追加finally代码块，其中的代码一定会被执行，通常用于资源回收。

# 第三章 自定义异常

## 3.1 概述

<!--P300-->

**为什么需要自定义异常类：**

我们说了java中不同的异常类，分别表示着某一种具体的异常情况，那么在开发中总是有些异常情况是SUN没有定义好的，此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题，考试成绩负数问题等等。

在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常，这些异常很可能在JDK中没有定义过，例如年龄负数问题，考试成绩负数问题等等。那么能不能自己定义异常呢？

**什么是自定义异常类：**

在开发中根据自己业务的异常情况来定义异常类。

自定义一个业务逻辑异常：**RegisterException**。一个注册异常类。

**异常类如何定义：**

1. 自定义一个编译器异常：自定义类 并继承与`java.lang.Exception`。
2. 自定义一个运行时期的异常类：自定义类 并继承与`java.lang.RuntimeException`。

```java
/*
    自定义异常类：
        java提供的异常类，不够我们使用，需要自己定义一些异常类
    格式：
        public class XXXException extends Exception / RuntimeException {
            添加一个空参数的构造方法
            添加一个带异常信息的构造方法
        }
    注意：
        1.自定义异常类一般都是以Exception结尾，说明该类是一个异常类
        2.自定义异常类，必须的继承Exception或者RuntimeException
            继承Exception：那么自定义异常类就是一个编译器异常，如果方法内部抛出了编译期异常，就必须处理这个异常，要么throws，要么try...catch
            继承RuntimeException：那么自定义的异常类就是一个运行期异常，无需处理，交给虚拟机处理（中断处理）
 */

public class RegisterException extends Exception{
    // 添加一个空参数的构造方法
    public RegisterException() {
        super();
    }

    /*
        添加一个带异常信息的构造方法
        查看源代码发现，所有的异常类都会有一个带异常信息的构造方法，方法内部会调用父类带异常信息的构造方法，让父类来处理这个异常信息
     */
    public RegisterException(String message) {
        super(message);
    }

}
```

## 3.2 自定义异常的练习

<!--P301-->

要求：我们模拟注册操作，如果用户名已经存在，则抛出异常并提示：亲，该用户名已经被注册。

首先定义一个登陆异常类RegisterException：

```java
import java.util.Scanner;

public class Demo01RegisterException {
    // 1.使用数组保存已经注册过的用户名
    static String[] usernames = {"张三", "李四", "王五"};

    public static void main(String[] args) /*throws RegisterException*/ {
        // 2.使用Scanner获取用户输入的注册的用户名
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入您要注册的用户名");
        String username = sc.next();
        checkUsername(username);
    }

    // 3.定义一个方法，对用户输入的注册的用户名进行判断
    public static void checkUsername(String username) /*throws RegisterException*/ {
        // 遍历存储已经注册过用户名的数组，获取每一个用户名
        for (String name: usernames) {
            // 使用获取到的用户名和用户输入的用户名进行比较
            if (name.equals(username)) {
                // true:用户名已存在，抛出RegisterException异常，告知用户“亲，该用户名已经被注册了”；
                try {
                    throw new RegisterException("亲，该用户名已经被注册了");
                } catch (RegisterException e) {
                    e.printStackTrace();
                    return;
                }
            }
        }

        // 循环结束，没有找到重复的用户名，提示用户“恭喜您，注册成功！”;
        System.out.println("恭喜您，注册成功！");
    }
}
```
