# 第一章 多线程

我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，如何处理？

用多进程或者多线程来解决。

## 1.1 并发与并行

* 并发：指两个或者多个事件在同一时间段内发生。
* 并行：指两个或者多个事件在同一时刻发生（同时发生）。

## 1.2 线程与进程

**进程是资源分配的最小单位，线程是CPU调度的最小单位**

* 进程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。

* 线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。


> 简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程。 

做个简单的比喻：进程=火车，线程=车厢

- 线程在进程下行进（单纯的车厢无法运行）
- 一个进程可以包含多个线程（一辆火车可以有多个车厢）
- 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
- 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
- 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
- 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
- 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）
- 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"
- 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”

**线程调度：**

* 分时调度

  所有线程轮流使用CPU的使用权，平均分配每个进程占用CPU的时间。

* 抢占式调度

  抢先让优先级高的线程使用CPU，如果线程优先级相同，那么会随机选择一个（线程随机性），java使用的为抢占式调度。

## 1.3 创建线程类

单线程java程序：

```java
public class Demo01Thread {

    public static void main(String[] args) {
        Person p1 = new Person("林炫");
        p1.run();

        System.out.println(0/0);// ArithmeticException: / by zero

        Person p2 = new Person("你好");
        p2.run();
    }
}

public class Person {

    private String name;

    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println(name + "-->" + i);
        }
    }

    public Person() {
    }

    public Person(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

java使用 `java.lang.Thread`类代表**线程**，所有的线程对象都必须是Thread类或者是其子类的实例。每个线程的作用是完成一定的任务，实际上是执行一段程序流即一段顺序执行的代码。java使用线程执行体来代表这段程序流。

java中通过继承Thread类来**创建**并**启动多线程**的步骤如下：

1. 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务，因此把`run()`方法定义成为线程执行体。
2. 创建Thread子类的实例，即创建了线程对象。
3. 调用线程对象的`start()`方法来启动该线程。

```java
// 1.创建一个Thread类的子类
public class MyThread extends Thread{

    // 2.在Thread类的子类中重写Thread类中的run方法，设置线程任务（开启线程要做什么）
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println("run:" + i);
        }
    }
}

public class Demo01Thread {

    public static void main(String[] args) {
        // 3.创建Thread类的子类对象
        MyThread mt = new MyThread();
        // 4.调用Thread类中的方法start方法，开启新的线程，执行run方法
        mt.start();

        for (int i = 0; i < 10; i++) {
            System.out.println("main:" + i);
        }
    }
}
```

# 第二章 创建线程

翻阅API后得知创建线程的方式总共有两种，一种是继承Thread类方式，一种是实现Runnable接口方式。

## 2.1 继承Thread类

API中定义了有关线程的一些方法，具体如下：

**构造方法：**

* `public Thread()`：分配一个新的线程对象。
* `public Thread(String name)`：分配一个指定名称的新的线程对象。
* `public Thread(Runnable target)`：分配一个带有指定目标新的线程对象。
* `public Thread(Runnable target, String name)`：分配一个带有指定目标新的线程对象并指定名字。

**常用方法：**

* `public String getName()`：获取当前线程名称。

  ```java
  // 定义一个Thread类的子类
  public class MyThread extends Thread{
      // 重写Thread类中的run方法，设置线程任务
      @Override
      public void run() {
          // 链式编程
          System.out.println(Thread.currentThread().getName());
      }
  }
  
  public class Demo01GetThreadName {
      public static void main(String[] args) {
          // 创建Thread类的子类
          MyThread mt = new MyThread();
          // 调用start方法，开启新线程，执行run方法
          mt.start();
      }
  }
  ```

* `public String setName()`:设置当前线程名称。

  ```java
  public class Demo01SetThreadName {
      public static void main(String[] args) {
          // 启动多线程
          MyThread mt = new MyThread();
          // 设置线程名称
          mt.setName("林炫");
          mt.start();
  
          // 第二种方法
          new MyThread("你好").start();
      }
  }
  
  public class MyThread extends Thread{
      public MyThread() {}
  
      public MyThread(String name) {
          super(name);
      }
  
      @Override
      public void run() {
          // 获取线程的名称
          System.out.println(Thread.currentThread().getName());
      }
  }
  ```

* `public void start()`：导致此线程开始执行，java虚拟机调用此线程的run方法。
* `public void run()`：此线程要执行的任务在此处定义代码。

* `public static void sleep(long millis)`:是当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。

  ```java
  public class Demo01Sleep {
      public static void main(String[] args) {
          // 模拟秒表
          for (int i = 1; i <= 60; i++) {
              System.out.println(i);
  
              // 使用Thread类中的sleep方法让程序睡眠1秒钟
              try {
                  Thread.sleep(1000);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          }
      }
  }
  ```

* `public static Thread currentThread()`：返回对当前正在执行的线程对象的引用。

## 2.2 实现Runnable接口

<!--runnable 就绪; 就绪状态; 可运行; 可运行状态; 可运行态 -->

采用`java.lang.Runnable`也是非常常见的一种，我们只需要重写run方法即可。

步骤如下：

1. 定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。
2. 创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该对象才是真正的线程对象。
3. 调用线程对象的start()方法来启动线程。

```java
// 1.创建一个Runnable接口的实现类
public class RunnableImpl implements Runnable{
    // 2.在实现类中重写Runnable接口的run方法，设置线程任务。
    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            System.out.println(Thread.currentThread().getName() + "-->" + i);
        }
    }
}

public class Demo01Runnable {

    public static void main(String[] args) {
        // 3.创建一个RUnnable接口的实现类对象
        RunnableImpl run = new RunnableImpl();
        // 4.创建Thread类对象，构造方法中传递Runnable接口的实现类
        Thread t = new Thread(run);
        // 5.调用Thread类中的start方法，开启新的线程执行run方法
        t.start();

        for (int i = 0; i < 20; i++) {
            System.out.println(Thread.currentThread().getName() + "-->" + i);
        }
    }
}
```

## 2.3 Thread和Runnable的区别

如果一个类继承Thread，则不适合资源共享，但是如果实现了Runnable接口的话，则很容易的实现资源共享。

**实现Runnable接口比继承Thread类所具有的优势：**

1. 适合多个相同的程序代码的线程去共享同一个资源。
2. 可以避免java中的单继承的局限性。
3. 增加程序的健壮性，实现解偶操作，代码可以被多个线程共享，代码和线程独立。
4. 线程池只能放入实现Runnable或者Callable类线程，不能直接放入继承Thread的类。

> 扩充：在java中，每次程序运行至少启动2个线程，一个是main线程，一个是垃圾收集线程，因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实就是在操作系统中启动了一个进程。

## 2.4 匿名内部类创建线程

使用线程的匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。

* 匿名：没有名字
* 内部类：写在其他类内部的类

* 匿名内部类作用：简化代码
  
  把子类继承父类，重写父类方法，创建子类对象 合成 一步完成
  
  把实现类实现接口，重写接口中的方法，创建实现类对象 合成 一步完成
* 匿名内部类的最终产物：子类/实现对象，而这个类没有名字

* 格式：

  ```java
  new 父类/接口() {
  	重写父类/接口中的方法
  };
  ```

```java
public class Demo01InnerClassThread {
    public static void main(String[] args) {
        // 线程的父类是Thread
        // new MyThread().start();
        new Thread() {
            // 重写线程方法，设置线程任务
            @Override
            public void run() {
                for (int i = 0; i < 10; i++) {
                    System.out.println(Thread.currentThread().getName() + "-->" + "林炫");
                }
            }
        }.start();

        // 线程的接口Runnable
        Runnable r = new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 10; i++) {
                    System.out.println(Thread.currentThread().getName() + "-->" + "你好");
                }
            }
        };
        new Thread(r).start();

        // 简化接口的方式
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 10; i++) {
                    System.out.println(Thread.currentThread().getName() + "-->" + "呀");
                }
            }
        }).start();
    }
}
```

# 第三章 线程安全

<!--ticket 票; 券; 车票; 戏票; 入场券; 奖券; 彩票; (商店中标明货物价格、尺码等的)标签; （交通违章）通知单，罚款单; 候选人名单;-->

如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。

我们通过一个案例，演示线程的安全问题：电影院要卖票，本次电影的座位共100个（本场电影只能卖100张票)。模拟电影院的售票窗口，实现多个窗口同时卖这场电影（多个窗口一起卖这100张票）。需要窗口，采用线程对象来模拟；需要票，Runnable接口子类来模拟。

```java
public class RunnableImpl implements Runnable{

    // 定义一个多个线程共享的票源
    private int ticket = 100;

    // 设置线程任务
    @Override
    public void run() {
        while(true) {
            if (ticket > 0) {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                System.out.println(Thread.currentThread().getName() + "-->正在卖第" + ticket + "张票");
                ticket--;
            }
        }
    }
}

public class Demo01Ticket {
    public static void main(String[] args) {
        // 创建Runnable接口的实现类对象
        RunnableImpl run = new RunnableImpl();
        // 创建Thread类对象，构造方法中传递Runnable接口的实现类对象
        Thread t0 = new Thread(run);
        Thread t1 = new Thread(run);
        Thread t2 = new Thread(run);
        // 调用start方法开启多线程
        t0.start();
        t1.start();
        t2.start();
    }
}
```

但是当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。

要解决上述多线程并发访问一个资源的安全性问题：也就是解决重复票与不存在票的问题，java中提供了同步机制（synchronized）来解决。

根据案例简述：窗口1线程进入操作的时候，窗口2和窗口3线程只能在外等着，窗口1操作结束，窗口1和窗口2和窗口3才有机会进入代码去执行。也就是说在某个个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。

为了保证每个线程都能正常执行原子操作，java引入了线程同步机制。

有三种方法完成同步操作：

1. **同步代码块。**
2. **同步方法。**
3. **锁机制。**

## 3.1 同步代码块

同步代码块：`synchronized`关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。

对象的同步锁只是一个概念，可以想象为在对象上标记了一个锁。

1. 锁对象可以是任意类型
2. 多个线程对象要使用同一把锁。

> 注意：在任何时候，最多允许一个线程拥有同步锁，谁拿到锁就进入代码块，其他的线程只能在外面等着（BLOCKED）。

使用同步代码块解决代码：

```java
public class RunnableImpl implements Runnable{

    // 定义一个多个线程共享的票源
    private int ticket = 100;

    // 创建一个锁对象
    Object obj = new Object();

    // 设置线程任务
    @Override
    public void run() {
        while(true) {
            // 同步代码块
            synchronized (obj) {
                // 判断票是否存在
                if (ticket > 0) {
                    // 提高安全问题出现的概率，让程序睡眠
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + "-->正在卖第" + ticket + "张票");
                    ticket--;
                }
            }
        }
    }
}
```

同步锁是谁？

- 对于非static方法，同步锁就是this。
- 对于static 方法，我们使用当前方法所在类的字节码对象(类名.class)。

## 3.2 同步方法

同步方法：使用`synchronized`修饰的方法，就叫做同步方法，保证A线程执行该方法的时候，其他线程只能在方法外面等着。

格式：

```java
public synchronized void method() {
    // 可能会产生线程安全问题的代码
}
```

使用同步方法代码如下：

```java
public class RunnableImpl implements Runnable{

    // 定义一个多个线程共享的票源
    private int ticket = 100;

    // 设置线程任务 卖票
    @Override
    public void run() {
        while(true) {
            payTicket();
        }
    }

    // 定义一个同步方法
    public synchronized void payTicket() {
        // 判断票是否存在
        if (ticket > 0) {
            // 提高安全问题出现的概率，让程序睡眠
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println(Thread.currentThread().getName() + "-->正在卖第" + ticket + "张票");
            ticket--;
        }
    }
}
```

## 3.3 Lock锁

`java.util.concurrent.locks.Lock`机制提供了比**synchronized**代码块和**synchronized**方法更广泛的锁定操作，同步代码块/同步方法具有的功能`Lock`锁都有，除此之外更加强大，更体现面向对象。

Lock锁也称同步锁，加锁与释放锁方法化了，如下：

* `public void lock()`：加同步锁。
* `public void unlock()`：释放同步锁。

```java
public class RunnableImpl implements Runnable{

    // 定义一个多个线程共享的票源
    private int ticket = 100;

    // 1,在成员位置创建一个Reentrantlock对象
    Lock l = new ReentrantLock();

    // 设置线程任务
    @Override
    public void run() {
        while(true) {

            // 2.在可能出现安全问题的代码前调用Lock接口中的方法Lock获取锁
            l.lock();

            // 判断票是否存在
            if (ticket > 0) {
                // 提高安全问题出现的概率，让程序睡眠
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                System.out.println(Thread.currentThread().getName() + "-->正在卖第" + ticket + "张票");
                ticket--;
            }

            // 3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁
            l.unlock();
        }
    }
}
```

# 第四章 线程状态与通信

## 4.1 线程状态

当线程被创建并且启动以后，他不是一启动就进入执行状态，也不是一直处于执行状态。在API中`java.lang.Thread.State`这个枚举中给出了六种线程状态：

| 线程状态                | 导致线程状态发生的条件                                       |
| ----------------------- | ------------------------------------------------------------ |
| NEW(新建)               | 线程刚被创建，但是没有启动。没有调用start方法。              |
| Runnable(可运行)        | 线程可以在java虚拟机中运行的状态，可能正在运行自己的代码，也可能没有，这取决于操作系统处理器 |
| Blocked(锁阻塞)         | 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。 |
| Waiting(无线等待)       | 一个线程在等待另一个线程执行一个(唤醒)动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。 |
| Timed Waiting(计时等待) | 同Waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接受到唤醒通知。带有超时参数的常用方法有Thread.sleep、Object.wait。 |
| Terminated(死亡状态)    | 已退出的线程处于这种状态                                     |

**Timed Waiting(计时等待)**

<!--API（应用程序交换程序接口）被定义为一个应用程序界面的标准与应用程序集界面或自定义软件为应用程序提供一个通用编程环境，以定制为可定制的运行程序。计算机企业的应用程序。-->

在API中的描述：一个正在限时等待另一个线程执行一个(唤醒)动作的线程处于这一状态。

之前已经接触过，run方法的sleep语句

当我们调用sleep方法后，当前执行的线程会进入到“休眠状态”,其实就是所谓的Timed Waiting(计时等待)。

![计时等待](..\图片\1-06【多线程】\1-1.png)



**BLOCKED(锁阻塞)**

![锁阻塞](..\图片\1-06【多线程】\1-2.png)



**Waiting(无线等待)**

![无线等待](..\图片\1-06【多线程】\1-3.png)

```java
public class Demo01WaitAndNotify {
    public static void main(String[] args) {
        // 创建锁对象，保证线程唯一
        Object obj = new Object();
        // 创建一个顾客线程(消费者)
        new Thread() {
            @Override
            public void run() {
                // 保证等待和唤醒的线程只能有一个执行，使用同步代码块
                synchronized (obj) {
                    System.out.println("告知老板吃的包子");
                    // 调用wait方法，放弃CPU的执行，进入到WAITING状态
                    try {
                        obj.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    // 唤醒后面的代码
                    System.out.println("开吃");
                }
            }
        }.start();

        // 创建一个老板线程（生产者）
        new Thread () {
            @Override
            public void run() {
                // 花费5秒做包子
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                // 保证等待和唤醒只能有一个执行，使用同步技术
                synchronized (obj) {
                    System.out.println("5秒后，做好了");
                    // 做好包子了，调用notify方法，唤醒顾客吃包子
                    obj.notify();
                }
            }
        }.start();
    }
}
```

## 4.2 线程间通信

**概念：**多个线程在处理同一个资源，但是处理的动作（线程的任务）不相同。

比如：线程A是生成包子的，线程B是来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。

**为什么要处理线程间通信**：多个线程并发执行时，在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行，那么多个线程之间需要一些协调通信，以此来帮助我们达到多线程共同操作一份数据。

如何保证线程间通信有效利用资源： 多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。就是多个线程在操作同一份数据时，避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即一一**等待唤酲机制。**

## 4.3 等待唤醒机制

这是多个线程间的一种**协作**机制。谈到线程我们经常想到的是线程间的**竞争（race）**，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。

就是在一个线程进行了规定操作后，就进入等待**状态（wait()）**，等待其他线程执行完他们的指定代码过后再将其唤醒（**notify()**）；在有多个线程进行等待时，如果需要，可以使用`notifyAll()`来唤醒所有的等待线程。

`wait/notify`就是线程间的一种协作机制。

**等待唤酲中的方法**

等待唤酲机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下

1. `wait`：线程不再活动，不再参与调度，进入`wait set`中，因此不会浪费CPU资源，也不会去竟争锁了，这时的线程状态即是`WAITING`。它还要等着别的线程执行一个**特别的动作**，也即是**通知（notify）**，通知等待的线程从`wait set`中释放出来，重新进入到调度队列（ready queue）中
2. `notify`：则选取所通知对象的`wait set`中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。
3. `notifyAll`：则释放所通知对象的`wait set`上的全部线程。

哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以它需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用wait方法之后的地方恢复执行。

* 如果能获取锁，线程就从`WAITING`状态变成`RUNNABLE`状态，
* 否则，从`wait set`出来，又进入`entry set`，线程就从`WAITING`状态又变成`BLOCKED`状态

**调用wait和notify方法需要注意的细节**

1. `wait`方法与`notify`方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过`notify`唤酲使用同一个锁对象调用的`wait`方法后的线程。
2. `wait`方法与`notify`方法是属于`Object`类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了`Object`类的。
3. `wait`方法与`notify`方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。



# 第二章 线程池

## 2.1 线程池思想概述

使得线程可以复用，执行完一个任务，并不被销毁，可以继续执行其他的任务

## 2.2 线程池概念

<!--P333-->

* 线程池：其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。

![](D:\Java\笔记\图片\1-06【多线程】\2-2.png)

线程池工作原理：

![](D:\Java\笔记\图片\1-06【多线程】\2-3.png)

合理利用线程池有三个好处：

1. 降低资源消耗。
2. 提高响应速度。
3. 提高线程的可管理性。

## 2.3 线程池的作用

java里面线程池的顶级接口是`java.util.concurrent.Executor`，但是严格意义上讲`Executor`并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是`java.util.concurrent.ExecutorService`。

要配置一个线程池比较复杂，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在`java.util.concurrent.Executors`线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。<font color = "red">**官方建议使用`Executors`工程类来创建线程池对象**</font>：

`Executors`类中有个创建线程池的方法如下：

* `public static ExecutorService newFixedThreadPool(int nThreads)`：返回线程池对象。（创建的是有界线程池，也就是池中的线程个数可以指定最大数量）

获取到了一个线程池`ExecutorService`对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：

* `public Future<?> submit(Runnable task)`:获取线程池中的某一个线程对象，并执行

> Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。

使用线程池中线程对象的步骤：

1. 创建线程池对象。
2. 创建`Runnable`接口子类对象。（task）
3. 提交`Runnable`接口子类对象。（take task）
4. 关闭线程池（一般不做）。

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
/*
    线程池的使用步骤：
        1.使用线程池的工厂类Executors里边提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池
        2.创建一个类，实现Runnable接口，重写run方法，设置线程任务
        3.调用ExecutorsService中的方法submit，传递线程任务（实现类），开启现场，执行run方法。
        4.调用ExecutorsService中的方法shutdown销毁线程池（不建议执行）
 */
public class Demo01ThreadPool {
    public static void main(String[] args) {
        // 1.使用线程池的工厂类Executors里边提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池
        ExecutorService es = Executors.newFixedThreadPool(2);
        // 3.调用ExecutorsService中的方法submit，传递线程任务（实现类），开启线程，执行run方法。
        // 线程池会一直开启，使用完了线程，会自动把线程归还给线程池，线程可以继续使用
        es.submit(new RunnableImpl());
        es.submit(new RunnableImpl());
        es.submit(new RunnableImpl());

        // 4.调用ExecutorsService中的方法shutdown销毁线程池（不建议执行）
        es.shutdown();

        es.submit(new RunnableImpl());// 抛出异常，线程池已经没有了，就不能获取线程了
    }
}



// 2.创建一个类，实现Runnable接口，重写run方法，设置线程任务
public class RunnableImpl implements Runnable{

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + "创建了一个新的线程执行");
    }
}
```

## 2.4 线程池的创建与使用

线程池的创建方法总共有 7 种，但总体来说可分为 2 类：

* 一类是通过 `ThreadPoolExecutor` 创建的线程池；
* 另一个类是通过 `Executors` 创建的线程池。

![](D:\Java\笔记\图片\1-06【多线程】\2-4.png)


线程池的创建方式总共包含以下 7 种（其中 6 种是通过 `Executors` 创建的，1 种是通过`ThreadPoolExecutor` 创建的）：

1. `Executors.newFixedThreadPool`：创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待；
2. `Executors.newCachedThreadPool`：创建一个可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程；
3. `Executors.newSingleThreadExecutor`：创建单个线程数的线程池，它可以保证先进先出的执行顺序；
4. `Executors.newScheduledThreadPool`：创建一个可以执行延迟任务的线程池；
5. `Executors.newSingleThreadScheduledExecutor`：创建一个单线程的可以执行延迟任务的线程池；
6. `Executors.newWorkStealingPool`：创建一个抢占式执行的线程池（任务执行顺序不确定）【JDK 1.8 添加】。
7. `ThreadPoolExecutor`：最原始的创建线程池的方式，它包含了 7 个参数可供设置，后面会详细讲。

**单线程池的意义**从以上代码可以看出 `newSingleThreadExecutor` 和`newSingleThreadScheduledExecutor` 创建的都是单线程池，那么单线程池的意义是什么呢？

答：<font color = "red">**虽然是单线程池，但提供了工作队列，生命周期管理，工作线程维护等功能。**</font>

那接下来我们来看每种线程池创建的具体使用。

### FixedThreadPool

创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待。

使用示例如下：

```java
public static void fixedThreadPool() {
    // 创建 2 个数据级的线程池
    ExecutorService threadPool = Executors.newFixedThreadPool(2);

    // 创建任务
    Runnable runnable = new Runnable() {
        @Override
        public void run() {
            System.out.println("任务被执行,线程:" + Thread.currentThread().getName());
        }
    };

    // 线程池执行任务(一次添加 4 个任务)
    // 执行任务的方法有两种:submit 和 execute
    threadPool.submit(runnable);  // 执行方式 1:submit
    threadPool.execute(runnable); // 执行方式 2:execute
    threadPool.execute(runnable);
    threadPool.execute(runnable);
}
```

执行结果如下：

![](D:\Java\笔记\图片\1-06【多线程】\2-5FixedThreadPool线程池.jpg)


如果觉得以上方法比较繁琐，还用更简单的使用方法，如下代码所示：

```java
public static void fixedThreadPool() {
    // 创建线程池
    ExecutorService threadPool = Executors.newFixedThreadPool(2);
    // 执行任务
    threadPool.execute(() -> {
        System.out.println("任务被执行,线程:" + Thread.currentThread().getName());
    });
}
```

### CachedThreadPool

创建一个可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程。

使用示例如下：

```java
public static void cachedThreadPool() {
    // 创建线程池
    ExecutorService threadPool = Executors.newCachedThreadPool();
    // 执行任务
    for (int i = 0; i < 10; i++) {
        threadPool.execute(() -> {
            System.out.println("任务被执行,线程:" + Thread.currentThread().getName());
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
            }
        });
    }
}
```


执行结果如下：

![](D:\Java\笔记\图片\1-06【多线程】\2-6CachedThreadPool.jpg)


从上述结果可以看出，线程池创建了 10 个线程来执行相应的任务。

### SingleThreadExecutor

创建单个线程数的线程池，它可以保证先进先出的执行顺序。

使用示例如下：

```java
public static void singleThreadExecutor() {
    // 创建线程池
    ExecutorService threadPool = Executors.newSingleThreadExecutor();
    // 执行任务
    for (int i = 0; i < 10; i++) {
        final int index = i;
        threadPool.execute(() -> {
            System.out.println(index + ":任务被执行");
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
            }
        });
    }
}
```

执行结果如下：

![](D:\Java\笔记\图片\1-06【多线程】\2-7SingleThreadExecutor.png)

### ScheduledThreadPool

创建一个可以执行延迟任务的线程池。

使用示例如下：

```java
public static void scheduledThreadPool() {
    // 创建线程池
    ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(5);
    // 添加定时执行任务(1s 后执行)
    System.out.println("添加任务,时间:" + new Date());
    threadPool.schedule(() -> {
        System.out.println("任务被执行,时间:" + new Date());
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
        }
    }, 1, TimeUnit.SECONDS);
}
```


执行结果如下：

![](D:\Java\笔记\图片\1-06【多线程】\2-8ScheduledThreadPool.png)

从上述结果可以看出，任务在 1 秒之后被执行了，符合我们的预期。

### SingleThreadScheduledExecutor

创建一个单线程的可以执行延迟任务的线程池。

使用示例如下：

```java
public static void SingleThreadScheduledExecutor() {
    // 创建线程池
    ScheduledExecutorService threadPool = Executors.newSingleThreadScheduledExecutor();
    // 添加定时执行任务(2s 后执行)
    System.out.println("添加任务,时间:" + new Date());
    threadPool.schedule(() -> {
        System.out.println("任务被执行,时间:" + new Date());
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
        }
    }, 2, TimeUnit.SECONDS);
}
```

执行结果如下：

![](D:\Java\笔记\图片\1-06【多线程】\2-9SingleThreadScheduledExecutor.png)


从上述结果可以看出，任务在 2 秒之后被执行了，符合我们的预期。

### newWorkStealingPool

创建一个抢占式执行的线程池（任务执行顺序不确定），注意此方法只有在 JDK 1.8+ 版本中才能使用。

使用示例如下：

```java
public static void workStealingPool() {
    // 创建线程池
    ExecutorService threadPool = Executors.newWorkStealingPool();
    // 执行任务
    for (int i = 0; i < 10; i++) {
        final int index = i;
        threadPool.execute(() -> {
            System.out.println(index + " 被执行,线程名:" + Thread.currentThread().getName());
        });
    }
    // 确保任务执行完成
    while (!threadPool.isTerminated()) {
    }
}
```


执行结果如下：

![](D:\Java\笔记\图片\1-06【多线程】\2-10newWorkStealingPool.jpg)


从上述结果可以看出，任务的执行顺序是不确定的，因为它是抢占式执行的。

### ThreadPoolExecutor

最原始的创建线程池的方式，它包含了 7 个参数可供设置。

使用示例如下：

```java
public static void myThreadPoolExecutor() {
    // 创建线程池
    ThreadPoolExecutor threadPool = new ThreadPoolExecutor(5, 10, 100, TimeUnit.SECONDS, new LinkedBlockingQueue<>(10));
    // 执行任务
    for (int i = 0; i < 10; i++) {
        final int index = i;
        threadPool.execute(() -> {
            System.out.println(index + " 被执行,线程名:" + Thread.currentThread().getName());
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
    }
}
```

执行结果如下：

![](D:\Java\笔记\图片\1-06【多线程】\2-11ThreadPoolExecutor.jpg)

## 2.5 ThreadPoolExecutor参数

ThreadPoolExecutor 最多可以设置 7 个参数，如下代码所示：

```java
 public ThreadPoolExecutor(int corePoolSize,
                           int maximumPoolSize,
                           long keepAliveTime,
                           TimeUnit unit,
                           BlockingQueue<Runnable> workQueue,
                           ThreadFactory threadFactory,
                           RejectedExecutionHandler handler) {
     // 省略...
 }
```

7 个参数代表的含义如下：

### 参数 1：corePoolSize

核心线程数，线程池中始终存活的线程数。

### 参数 2：maximumPoolSize

最大线程数，线程池中允许的最大线程数，当线程池的任务队列满了之后可以创建的最大线程数。

### 参数 3：keepAliveTime

最大线程数可以存活的时间，当线程中没有任务执行时，最大线程就会销毁一部分，最终保持核心线程数量的线程。

### 参数 4：unit

单位是和参数 3 存活时间配合使用的，合在一起用于设定线程的存活时间 ，参数 `keepAliveTime` 的时间单位有以下 7 种可选：

* `TimeUnit.DAYS`：天
* `TimeUnit.HOURS`：小时
* `TimeUnit.MINUTES`：分
* `TimeUnit.SECONDS`：秒
* `TimeUnit.MILLISECONDS`：毫秒
* `TimeUnit.MICROSECONDS`：微妙
* `TimeUnit.NANOSECONDS`：纳秒

### 参数 5：workQueue

一个阻塞队列，用来存储线程池等待执行的任务，均为线程安全，它包含以下 7 种类型：

* `ArrayBlockingQueue`：一个由数组结构组成的有界阻塞队列。
* `LinkedBlockingQueue`：一个由链表结构组成的有界阻塞队列。
* `SynchronousQueue`：一个不存储元素的阻塞队列，即直接提交给线程不保持它们。
* `PriorityBlockingQueue`：一个支持优先级排序的无界阻塞队列。
* `DelayQueue`：一个使用优先级队列实现的无界阻塞队列，只有在延迟期满时才能从中提取元素。
* `LinkedTransferQueue`：一个由链表结构组成的无界阻塞队列。与`SynchronousQueue`类似，还含有非阻塞方法。
* `LinkedBlockingDeque`：一个由链表结构组成的双向阻塞队列。

较常用的是 `LinkedBlockingQueue` 和 `Synchronous`，线程池的排队策略与 `BlockingQueue` 有关。

### 参数 6：threadFactory

线程工厂，主要用来创建线程，默认为正常优先级、非守护线程。

### 参数 7：handler

拒绝策略，拒绝处理任务时的策略，系统提供了 4 种可选：

* `AbortPolicy`：拒绝并抛出异常。
* `CallerRunsPolicy`：使用当前调用的线程来执行此任务。
* `DiscardOldestPolicy`：抛弃队列头部（最旧）的一个任务，并执行当前任务。
* `DiscardPolicy`：忽略并抛弃当前任务。

默认策略为 `AbortPolicy`。

### 线程池的执行流程

`ThreadPoolExecutor` 关键节点的执行流程如下：

* 当线程数小于核心线程数时，创建线程。
* 当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列。
* 当线程数大于等于核心线程数，且任务队列已满：若线程数小于最大线程数，创建线程；若线程数等于最大线程数，抛出异常，拒绝任务。

线程池的执行流程如下图所示：

![](D:\Java\笔记\图片\1-06【多线程】\2-12ThreadPoolExecutor 执行流程.jpg)

### 线程拒绝策略

拒绝策略，拒绝处理任务时的策略，系统提供了 4 种可选：

* `AbortPolicy`：拒绝并抛出异常。
* `CallerRunsPolicy`：使用当前调用的线程来执行此任务。
* `DiscardOldestPolicy`：抛弃队列头部（最旧）的一个任务，并执行当前任务。
* `DiscardPolicy`：忽略并抛弃当前任务。

默认策略为 `AbortPolicy`。

我们来演示一下 `ThreadPoolExecutor` 的拒绝策略的触发，我们使用 `DiscardPolicy` 的拒绝策略，它会忽略并抛弃当前任务的策略，实现代码如下：

```java
public static void main(String[] args) {
    // 任务的具体方法
    Runnable runnable = new Runnable() {
        @Override
        public void run() {
            System.out.println("当前任务被执行,执行时间:" + new Date() +
                               " 执行线程:" + Thread.currentThread().getName());
            try {
                // 等待 1s
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    };
    // 创建线程,线程的任务队列的长度为 1
    ThreadPoolExecutor threadPool = 
        							new ThreadPoolExecutor(1, 1, 100, TimeUnit.SECONDS, 
                                    	new LinkedBlockingQueue<>(1),
                                    	new ThreadPoolExecutor.DiscardPolicy());
    // 添加并执行 4 个任务
    threadPool.execute(runnable);
    threadPool.execute(runnable);
    threadPool.execute(runnable);
    threadPool.execute(runnable);
}
```

我们创建了一个核心线程数和最大线程数都为 1 的线程池，并且给线程池的任务队列设置为 1，这样当我们有 2 个以上的任务时就会触发**拒绝策略**，执行的结果如下图所示：

![](D:\Java\笔记\图片\1-06【多线程】\2-13ThreadPoolExecutor 线程拒绝策略.jpg)


从上述结果可以看出只有两个任务被正确执行了，其他多余的任务就被舍弃并忽略了。其他拒绝策略的使用类似，这里就不一一赘述了。

### 自定义拒绝策略

除了 Java 自身提供的 4 种拒绝策略之外，我们也可以自定义拒绝策略，示例代码如下：

```java
public static void main(String[] args) {
    // 任务的具体方法
    Runnable runnable = new Runnable() {
        @Override
        public void run() {
            System.out.println("当前任务被执行,执行时间:" + new Date() +
                               " 执行线程:" + Thread.currentThread().getName());
            try {
                // 等待 1s
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    };
    // 创建线程,线程的任务队列的长度为 1
    ThreadPoolExecutor threadPool = 
        							new ThreadPoolExecutor(1, 1,100, TimeUnit.SECONDS, 
                                    	new LinkedBlockingQueue<>(1),
                                   		new RejectedExecutionHandler() {
        @Override
        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
            // 执行自定义拒绝策略的相关操作
            System.out.println("我是自定义拒绝策略~");
            }
        });
    
    // 添加并执行 4 个任务
    threadPool.execute(runnable);
    threadPool.execute(runnable);
    threadPool.execute(runnable);
    threadPool.execute(runnable);
}
```

程序的执行结果如下：

![](D:\Java\笔记\图片\1-06【多线程】\2-14ThreadPoolExecutor 自定义拒绝.jpg)

## 2.6 究竟选用哪种线程池？

经过以上的学习我们对整个线程池也有了一定的认识了，那究竟该如何选择线程池呢？

我们来看下阿里巴巴《Java开发手册》给我们的答案：

> 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。
>
> 说明：Executors 返回的线程池对象的弊端如下：
>
> 1. FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。
> 2. CachedThreadPool：允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。

所以综上情况所述，我们推荐使用 `ThreadPoolExecutor` 的方式进行线程池的创建，因为这种创建方式更可控，并且更加明确了线程池的运行规则，可以规避一些未知的风险。

