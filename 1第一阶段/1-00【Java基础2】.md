

# 第一章 常见的关键字

## 1.1 Static

关于 `static` 关键字的使用，它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属
于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。

被`static`修饰的成员可以并且建议通过类名直接访问。虽然也可以通过对象名访问静态成员，原因即多个对象均属 于一个类，共享使用同一个静态成员，但是不建议，会出现警告信息。

static 修饰的内容：

- 是随着类的加载而加载的，且只加载一次。
- 存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。
- 它优先于对象存在，所以，可以被所有对象共享。

![](D:\Java\笔记\图片\1-00【Java基础】\9静态原理.png)

### 1.1.1 类变量

类变量：使用 static关键字修饰的成员变量。定义格式为：`static 数据类型 变量名;`

当 `static` 修饰成员变量时，该变量称为类变量。该类的每个对象都共享同一个类变量的值。任何对象都可以更改 该类变量的值，但也可以在不创建该类的对象的情况下对类变量进行操作。

### 1.1.2 静态方法

类方法：使用 static关键字修饰的成员方法，习惯称为静态方法。

当 `static` 修饰成员方法时，该方法称为类方法 。静态方法在声明中有 `static` ，建议使用类名来调用，而不需要创建类的对象。调用方式非常简单。

```java
修饰符 static 返回值类型 方法名 (参数列表){
    // 执行语句
}
```

静态方法调用的注意事项：

- 静态方法可以直接访问类变量和静态方法。
- 静态方法不能直接访问普通成员变量或成员方法。反之，成员方法可以直接访问类变量或静态方法。
- 静态方法中，不能使用this关键字。

> 静态方法只能访问静态成员。

### 1.1.3 静态代码块

静态代码块：定义在成员位置，使用`static`修饰的代码块`{ }`。

- 位置：类中方法外。
- 执行：随着类的加载而执行且执行一次，优先于main方法和构造方法的执行。

```java
public class ClassName{
    static {
        // 执行语句
    }
}
```

作用：给类变量进行初始化赋值。用法演示，代码如下：

```java
public class Game {
    public static int number;
    public static ArrayList<String> list;
    static {
        // 给类变量赋值
        number = 2;
        list = new ArrayList<String>();
        // 添加元素到集合中
        list.add("张三");
        list.add("李四");
    }
}
```

> static 关键字，可以修饰变量、方法和代码块。在使用的过程中，其主要目的还是想在不创建对象的情况 下，去调用方法。下面将介绍两个工具类，来体现static 方法的便利。

## 1.2 abstract

父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了。我们把没有方法主体的方法称为抽象方法。Java语法规定，包含抽象方法的类就是抽象类。

- 抽象方法 ： 没有方法体的方法。

  使用 abstract 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。抽象方法修饰符不能是`private final static`

  ```java
  修饰符 abstract 返回值类型 方法名 (参数列表)；
  ```

- 抽象类：包含抽象方法的类。

  如果一个类包含抽象方法，那么该类必须是抽象类。

  ```java
  abstract class 类名字 {
  }
  ```

继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。

```java
public class Cat extends Animal {
    public void run (){
        System.out.println("小猫在墙头走~~~")；
    }
}
public class CatTest {
    public static void main(String[] args) {
        // 创建子类对象
        Cat c = new Cat();
        // 调用run方法
        c.run();
    }
}
输出结果：
    小猫在墙头走~~~
```

此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做实现方法。

抽象类的特点：

1. 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。
2. 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。抽象类的构造方法不能定义成私有（子类构造方法会调用父类构造方法）
3. 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
4. 抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。
5. 抽象类不能使用final修饰，final修饰的类不能被继承

## 1.3 interface

接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是封装了方法，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法（JDK 9）。

接口的定义，它与定义类方式相似，但是使用 `interface` 关键字。它也会被编译成`.class`文件，但一定要明确它并不是类，而是另外一种引用数据类型。

> 引用数据类型：数组，类，接口。

接口的使用，它不能创建对象，但是可以被实现（ `implements` ，类似于被继承）。一个实现接口的类（可以看做是接口的子类），需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象类。

```java
public interface 接口名称 {
    // 抽象方法
    // 默认方法
    // 静态方法
    // 私有方法
}
```

* **抽象方法**
  使用 `abstract` 关键字修饰，可以省略，没有方法体。该方法供子类实现使用。

  ```java
  public interface InterFaceName {
      public abstract void method();
  }
  ```

* **默认方法**
  使用 `default` 修饰，不可省略，供子类调用或者子类重写。

  ```java
  public interface InterFaceName {
      public default void method() {
          // 执行语句
      }
  }
  ```

* **静态方法**
  使用 `static` 修饰，供接口直接调用。

  ```java
  public interface InterFaceName {
      public static void method2() {
          // 执行语句
      }
  }
  ```

* **私有方法**
  使用 `private` 修饰，供接口中的默认方法或者静态方法调用。

  ```java
  public interface InterFaceName {
      private void method() {
          // 执行语句
      }
  }
  ```

### 1.3.1 基本的实现

类与接口的关系为实现关系，即类实现接口，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 `implements` 关键字。

非抽象子类实现接口：
1. 必须重写接口中所有抽象方法。
2. 继承了接口的默认方法，即可以直接调用，也可以重写。

```java
class 类名 implements 接口名 {
    // 重写接口中抽象方法【必须】
    // 重写接口中默认方法【可选】
}
```

**抽象方法使用**

必须全部实现，代码如下：

```java
public interface LiveAble {
    // 定义抽象方法
    public abstract void eat();
    public abstract void sleep();
}
```

```java
public class Animal implements LiveAble {
    @Override
    public void eat() {
        System.out.println("吃东西");
    }
    @Override
    public void sleep() {
        System.out.println("晚上睡");
    }
}
```

**默认方法的使用**

可以继承，可以重写，二选一，但是只能通过实现类的对象来调用。

1. 继承默认方法，代码如下：

   ```java
   public interface LiveAble {
       public default void fly(){
           System.out.println("天上飞");
       }
   }
   ```

   ```java
   public class Animal implements LiveAble {
       // 继承，什么都不用写，直接调用
   }
   ```

2. 重写默认方法，代码如下：

   ```java
   public interface LiveAble {
       public default void fly(){
           System.out.println("天上飞");
       }
   }
   ```

   ```java
   public class Animal implements LiveAble {
       @Override
       public void fly() {
           System.out.println("自由自在的飞");
       }
   }
   ```

**静态方法的使用**

静态与`.class` 文件相关，只能使用接口名调用，不可以通过实现类的类名或者实现类的对象调用，代码如下：

```java
public interface LiveAble {
    public static void run(){
        System.out.println("跑起来~~~");
    }
}
```

```java
public class Animal implements LiveAble {
    // 无法重写静态方法
}
```

```java
public class InterfaceDemo {
    public static void main(String[] args) {
        // Animal.run(); // 【错误】无法继承方法,也无法调用
        LiveAble.run(); //
    }
}
```

**私有方法的使用**

- 私有方法：只有默认方法可以调用。
- 私有静态方法：默认方法和静态方法可以调用。

如果一个接口中有多个默认方法，并且方法中有重复的内容，那么可以抽取出来，封装到私有方法中，供默认方法去调用。从设计的角度讲，私有的方法是对默认方法和静态方法的辅助。

```java
public interface LiveAble {
    default void func(){
        func1();
        func2();
    }
    private void func1(){
        System.out.println("跑起来~~~");
    }
    private void func2(){
        System.out.println("跑起来~~~");
    }
}
```

### 1.3.2 接口的多实现

之前学过，在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的多实现。并且，一个类能继承一个父类，同时实现多个接口。

```java
class 类名 [extends 父类名] implements 接口名1,接口名2,接口名3... {
    // 重写接口中抽象方法【必须】
    // 重写接口中默认方法【不重名时可选】
}
```

**抽象方法**

接口中，有多个抽象方法时，实现类必须重写所有抽象方法。如果抽象方法有重名的，只需要重写一次。代码如下：

```java
interface A {
    public abstract void showA();
    public abstract void show();
}
interface B {
    public abstract void showB();
    public abstract void show();
}

```

```java
public class C implements A,B{
    @Override
    public void showA() {
        System.out.println("showA");
    }
    @Override
    public void showB() {
        System.out.println("showB");
    }
    @Override
    public void show() {
        System.out.println("show");
    }
}
```

**默认方法**

接口中，有多个默认方法时，实现类都可继承使用。如果默认方法有重名的，必须重写一次。代码如下：

```java
interface A {
    public default void methodA(){}
    public default void method(){}
}
interface B {
    public default void methodB(){}
    public default void method(){}
}
```

```java
public class C implements A,B{
    @Override
    public void method() {
        System.out.println("method");
    }
}
```

**静态方法**

接口中，存在同名的静态方法并不会冲突，原因是只能通过各自接口名访问静态方法。

### 1.3.3 接口多实现优先级

当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。代码如下：

```java
interface A {
    public default void methodA(){
        System.out.println("AAAAAAAAAAAA");
    }
}
```

```java
class D {
    public void methodA(){
        System.out.println("DDDDDDDDDDDD");
    }
}
```

```java
class C extends D implements A {
    // 未重写methodA方法
}
```

```java
public class Test {
    public static void main(String[] args) {
        C c = new C();
        c.methodA();
    }
}
```

### 1.3.4 接口多继承

一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。接口的继承使用 `extends` 关键字，子接口继承父接口的方法。如果父接口中的默认方法有重名的，那么子接口需要重写一次。代码如下：

```java
interface A {
    public default void method(){
        System.out.println("AAAAAAAAAAAAAAAAAAA");
    }
}
interface B {
    public default void method(){
        System.out.println("BBBBBBBBBBBBBBBBBBB");
    }
}
```

```java
interface D extends A,B{
    @Override
    public default void method() {
        System.out.println("DDDDDDDDDDDDDD");
    }
}
```

- 子接口重写默认方法时，default关键字可以保留。
- 子类重写默认方法时，default关键字不可以保留。

### 1.3.5 接口特点

- 接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用public static final修饰。
- 接口中，没有构造方法，不能创建对象。
- 接口中，没有静态代码块。
- 接口中没有构造器，不能被实例化
- 接口只能继承接口，不能继承类，接口支持多继承
- 接口中的定义的成员变量，默认是`public static final`修饰的静态常量
- 接口中定义的方法，默认是`public abstract`修饰的抽象方法
- 接口中定义的内部类，默认是`public static`修饰的静态内部类

### 1.3.6 抽象类和接口的区别

相同点：

1. 抽象类和接口都不能被实例化
2. 抽象类和接口都可以定义抽象方法，子类/实现类必须覆写这些抽象方法

不同点：

1. 抽象类有构造方法，接口没有构造方法
2. 抽象类可以包含普通方法，接口中只能是`public abstract`修饰抽象方法（Java8之后可以）
3. 抽象类只能单继承，接口可以多继承
4. 抽象类可以定义各种类型的成员变量，接口中只能是`public static final`修饰的静态常量

## 1.4 final

子类可以在父类的基础上改写父类内容，比如，方法重写。那么我们能不能随意的继承API中提供的类，改写其内容呢？显然这是不合适的。为了避免这种随意改写的情况，Java提供了 `final` 关键字，用于修饰不可改变内容。

final： 不可改变。可以用于修饰类、方法和变量。

- 类：被修饰的类，不能被继承。
- 方法：被修饰的方法，不能被重写。
- 变量：被修饰的变量，不能被重新赋值。

### 1.4.1 修饰类

```java
final class 类名 {
}
```

查询API发现像 `public final class String` 、 `public final class Math` 、 `public final class Scanner`等，很多我们学习过的类，都是被final修饰的，目的就是供我们使用，而不让我们所以改变其内容。

### 1.4.2 修饰方法

```java
修饰符 final 返回值类型 方法名(参数列表){
    //方法体
}
```

重写被 `final` 修饰的方法，编译时就会报错。

### 1.4.3 修饰变量

* **局部变脸——基本类型**
  基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改。代码如下：

  ```java
  public class FinalDemo1 {
      public static void main(String[] args) {
          // 声明变量，使用final修饰
          final int a;
          // 第一次赋值
          a = 10;
          // 第二次赋值
          a = 20; // 报错,不可重新赋值
          // 声明变量，直接赋值，使用final修饰
          final int b = 10;
          // 第二次赋值
          b = 20; // 报错,不可重新赋值
      }
  }
  ```

  看一下下面两个代码：
  
  ```java
  // 代码1
  final int c = 0;
  for (int i = 0; i < 10; i++) {
      c = i;
      System.out.println(c);
  }
  ```
  
  ```java
  // 代码2
  for (int i = 0; i < 10; i++) {
      final int c = i;
      System.out.println(c);
  }
  ```
  
  根据 `final` 的定义，代码1报错！代码2没有问题，为什么通过编译呢？因为每次循环，都是一次新的变量c。这也是大家需要注意的地方。
  
* **局部变量——引用类型**
  引用类型的局部变量，被final修饰后，只能指向一个对象，地址不能再更改。但是不影响对象内部的成员变量值的修改，代码如下：

  ```java
  public class FinalDemo2 {
      public static void main(String[] args) {
          // 创建 User 对象
          final User u = new User();
          // 创建 另一个 User对象
          u = new User(); // 报错，指向了新的对象，地址值改变。
          // 调用setName方法
          u.setName("张三"); // 可以修改
      }
  }
  ```

* **成员变量**
  成员变量涉及到初始化的问题，初始化方式有两种，只能二选一：

  ```java
  // 显示初始化
  public class User {
      final String USERNAME = "张三";
      private int age;
  }
  ```

  ```java
  // 构造方法初始化
  public class User {
      final String USERNAME ;
      private int age;
      public User(String username, int age) {
          this.USERNAME = username;
          this.age = age;
      }
  }
  ```

> 被final修饰的常量名称，一般都有书写规范，所有字母都大写。

## 1.5 权限修饰符

在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限，

- public：公共的。
- protected：受保护的
- default：默认的
- private：私有的

|                        | public | protected | default（空的） | private |
| ---------------------- | ------ | --------- | --------------- | ------- |
| 同一类中               | √      | √         | √               | √       |
| 同一包中(子类与无关类) | √      | √         | √               |         |
| 不同包的子类           | √      | √         |                 |         |
| 不同包中的无关类       | √      |           |                 |         |

可见，public具有最大权限。private则是最小权限。

编写代码时，如果没有特殊的考虑，建议这样使用权限：

- 成员变量使用 private ，隐藏细节。
- 构造方法使用 public ，方便创建对象。
- 成员方法使用 public ，方便调用方法。

> 不加权限修饰符，其访问能力与default修饰符相同

# 第二章 内部类

将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类。

## 2.1 成员内部类

成员内部类 ：定义在类中方法外的类。

```java
class 外部类 {
    class 内部类{
    }
}
```

在描述事物时，若一个事物内部还包含其他事物，就可以使用内部类这种结构。比如，汽车类 Car 中包含发动机类 Engine ，这时， Engine 就可以使用内部类来描述，定义在成员位置。

```java
class Car { //外部类
    class Engine { //内部类
    }
}
```

特点如下：

- 内部类可以直接访问外部类的成员，包括私有成员。
- 外部类要访问内部类的成员，必须要建立内部类的对象。

创建内部类格式：`外部类名.内部类名 对象名 = new 外部类型().new 内部类型()；`

```java
public class Person {
    private boolean live = true;
    class Heart {
        public void jump() {
            // 直接访问外部类成员
            if (live) {
                System.out.println("心脏在跳动");
            } else {
                System.out.println("心脏不跳了");
            }
        }
    }
    public boolean isLive() {
        return live;
    }
    public void setLive(boolean live) {
        this.live = live;
    }
}
```

```java
public class InnerDemo {
    public static void main(String[] args) {
        // 创建外部类对象
        Person p = new Person();
        // 创建内部类对象
        Heart heart = p.new Heart();
        // 调用内部类方法
        heart.jump();
        // 调用外部类方法
        p.setLive(false);
        // 调用内部类方法
        heart.jump();
    }
}
输出结果:
	心脏在跳动
    心脏不跳了
```

> 内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名 和$符号 。 比如，Person$Heart.class

## 2.2 匿名内部类

匿名内部类 ：是内部类的简化写法。它的本质是一个带具体实现的父类或者父接口的匿名的子类对象。

开发中，最常用到的内部类就是匿名内部类了。以接口举例，当你使用一个接口时，似乎得做如下几步操作，

1. 定义子类
2. 重写接口中的方法
3. 创建子类对象
4. 调用重写后的方法

我们的目的，最终只是为了调用方法，那么能不能简化一下，把以上四步合成一步呢？匿名内部类就是做这样的快捷方式。

匿名内部类必须继承一个父类或者实现一个父接口。

```java
new 父类名或者接口名(){
    // 方法重写
    @Override
    public void method() {
        // 执行语句
    }
};
```

使用方法如下：

```java
public abstract class FlyAble{
    public abstract void fly();
}
```

```java
public class InnerDemo {
    public static void main(String[] args) {
        /*
        1.等号右边:是匿名内部类，定义并创建该接口的子类对象
        2.等号左边:是多态赋值,接口类型引用指向子类对象
        */
        FlyAble f = new FlyAble(){
            public void fly() {
                System.out.println("我飞了~~~");
            }
        };
        //调用 fly方法,执行重写后的方法
        f.fly();
    }
}

```

通常在方法的形式参数是接口或者抽象类时，也可以将匿名内部类作为参数传递。代码如下：

```java
public class InnerDemo2 {
    public static void main(String[] args) {
        /*
        1.等号右边:定义并创建该接口的子类对象
        2.等号左边:是多态,接口类型引用指向子类对象
        */
        FlyAble f = new FlyAble(){
            public void fly() {
                System.out.println("我飞了~~~");
            }
        };
        // 将f传递给showFly方法中
        showFly(f);
    }
    public static void showFly(FlyAble f) {
        f.fly();
    }
}
```

以上两步，也可以简化为一步，代码如下：

```java
public class InnerDemo3 {
    public static void main(String[] args) {
        /*
        创建匿名内部类,直接传递给showFly(FlyAble f)
        */
        showFly( new FlyAble(){
            public void fly() {
                System.out.println("我飞了~~~");
            }
        });
    }
    public static void showFly(FlyAble f) {
        f.fly();
    }
}
```

# 第三章 引用类型用法

实际的开发中，引用类型的使用非常重要，也是非常普遍的。我们可以在理解基本类型的使用方式基础上，进一步
去掌握引用类型的使用方式。基本类型可以作为成员变量、作为方法的参数、作为方法的返回值，那么当然引用类
型也是可以的。

## 3.1 类作为成员变量

在定义一个类Role（游戏角色）时，代码如下：

```java
class Role {
    int id; // 角色id
    int blood; // 生命值
    String name; // 角色名称
}
```

使用 int 类型表示 角色id和生命值，使用 String 类型表示姓名。此时， String 本身就是引用类型，由于使用的方式类似常量，所以往往忽略了它是引用类型的存在。如果我们继续丰富这个类的定义，给 Role 增加武器，穿戴装备等属性，我们将如何编写呢？

定义武器类，将增加攻击能力：

```java
class Weapon {
    String name； // 武器名称
    int hurt； // 伤害值
}
```

定义穿戴盔甲类，将增加防御能力，也就是提升生命值：

```java
class Armour {
    String name；// 装备名称
    int protect；// 防御值
}
```

定义角色类：

```java
class Role {
    int id;
    int blood;
    String name;
    // 添加武器属性
    Weapon wp;
    // 添加盔甲属性
    Armour ar;
    // 提供get/set方法
    public Weapon getWp() {
        return wp;
    }
    public void setWeapon(Weapon wp) {
        this.wp = wp;
    }
    public Armour getArmour() {
        return ar;
    }
    public void setArmour(Armour ar) {
        this.ar = ar;
    }
    // 攻击方法
    public void attack(){
        System.out.println("使用"+ wp.getName() +", 造成"+wp.getHurt()+"点伤害");
    }
    // 穿戴盔甲
    public void wear(){
        // 增加防御,就是增加blood值
        this.blood += ar.getProtect();
        System.out.println("穿上"+ar.getName()+", 生命值增加"+ar.getProtect());
    }
}
```

测试类：

```java
public class Test {
    public static void main(String[] args) {
        // 创建Weapon 对象
        Weapon wp = new Weapon("屠龙刀" , 999999);
        // 创建Armour 对象
        Armour ar = new Armour("麒麟甲",10000);
        // 创建Role 对象
        Role r = new Role();
        // 设置武器属性
        r.setWeapon(wp);
        // 设置盔甲属性
        r.setArmour(ar);
        // 攻击
        r.attack();
        // 穿戴盔甲
        r.wear();
    }
}
输出结果:
	使用屠龙刀,造成999999点伤害
    穿上麒麟甲 ,生命值增加10000
```

> 类作为成员变量时，对它进行赋值的操作，实际上，是赋给它该类的一个对象。

## 3.2 接口作为成员变量

接口是对方法的封装，对应游戏当中，可以看作是扩展游戏角色的技能。所以，如果想扩展更强大技能，我们在Role 中，可以增加接口作为成员变量，来设置不同的技能。

```java
// 法术攻击
public interface FaShuSkill {
    public abstract void faShuAttack();
}
```

```java
public class Role {
    FaShuSkill fs;
    public void setFaShuSkill(FaShuSkill fs) {
        this.fs = fs;
    }
    // 法术攻击
    public void faShuSkillAttack(){
        System.out.print("发动法术攻击:");
        fs.faShuAttack();
        System.out.println("攻击完毕");
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        // 创建游戏角色
        Role role = new Role();
        // 设置角色法术技能
        role.setFaShuSkill(new FaShuSkill() {
            @Override
            public void faShuAttack() {
                System.out.println("纵横天下");
            }
        });
        // 发动法术攻击
        role.faShuSkillAttack();
        // 更换技能
        role.setFaShuSkill(new FaShuSkill() {
            @Override
            public void faShuAttack() {
                System.out.println("逆转乾坤");
            }
        });
        // 发动法术攻击
        role.faShuSkillAttack();
    }
}
输出结果:
	发动法术攻击:纵横天下
    攻击完毕
    发动法术攻击:逆转乾坤
    攻击完毕
```

> 我们使用一个接口，作为成员变量，以便随时更换技能，这样的设计更为灵活，增强了程序的扩展性。 接口作为成员变量时，对它进行赋值的操作，实际上，是赋给它该接口的一个子类对象。

## 3.3 接口作为方法参数和返回值

当接口作为方法的参数时,需要传递什么呢？当接口作为方法的返回值类型时，需要返回什么呢？对，其实都是它的子类对象。 ArrayList 类我们并不陌生，查看API我们发现，实际上，它是 java.util.List 接口的实现类。所以，当我们看见 List 接口作为参数或者返回值类型时，当然可以将 ArrayList 的对象进行传递或返回。

请观察如下方法：获取某集合中所有的偶数。

```java
public static List<Integer> getEvenNum(List<Integer> list) {
    // 创建保存偶数的集合
    ArrayList<Integer> evenList = new ArrayList<>();
    // 遍历集合list,判断元素为偶数,就添加到evenList中
    for (int i = 0; i < list.size(); i++) {
        Integer integer = list.get(i);
        if (integer % 2 == 0) {
            evenList.add(integer);
        }
    }
    /*
        返回偶数集合
        因为getEvenNum方法的返回值类型是List,而ArrayList是List的子类,
        所以evenList可以返回
    */
    return evenList;
}
```

```java
public class Test {
    public static void main(String[] args) {
        // 创建ArrayList集合,并添加数字
        ArrayList<Integer> srcList = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            srcList.add(i);
        }
        /*
            获取偶数集合
            因为getEvenNum方法的参数是List,而ArrayList是List的子类,
            所以srcList可以传递
        */
        List list = getEvenNum(srcList);
        System.out.println(list);
    }
}
```

> 接口作为参数时，传递它的子类对象。 接口作为返回值类型时，返回它的子类对象。

# 第四章 常见的类

首先来介绍一下API：`API(Application Programming Interface)`，应用程序编程接口。Java API是一本程序员的 字典 ，是JDK中提供给我们使用的类的说明文档。这些类将底层的代码实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可。所以我们可以通过查询API的方式，来学习Java提供的类，并得知如何使用它们。

使用步骤如下：

1. 打开帮助文档。
2. 点击显示，找到索引，看到输入框。
3. 你要找谁？在输入框里输入，然后回车。
4. 看包。java.lang下的类不需要导包，其他需要。
5. 看类的解释和说明。
6. 学习构造方法。

## 4.1 Scanner类

一个可以解析基本类型和字符串的简单文本扫描器。 例如，以下代码使用户能够从 `System.in` 中读取一个数：

```java
// System.in 系统输入指的是通过键盘录入数据。
Scanner sc = new Scanner(System.in);
int i = sc.nextInt();
```

使用步骤如下：

- **导包**
  使用import关键字导包，在类的所有代码之前导包，引入要使用的类型，java.lang包下的所有类无需导入。 格式：`import 包名.类名;` 例如：`import java.util.Scanner;`
- **创建对象**
  使用该类的构造方法，创建一个该类的对象。 格式：`数据类型 变量名 = new 数据类型(参数列表);`
- **调用方法**
  调用该类的成员方法，完成指定功能。 格式：`变量名.方法名();`

常见方法如下：

- `public Scanner(InputStream source)` : 构造一个新的 Scanner ，它生成的值是从指定的输入流扫描的。
- `public int nextInt()` ：将输入信息的下一个标记扫描为一个 int 值。

## 4.2 Random类

此类的实例用于生成伪随机数。

例如，以下代码使用户能够得到一个随机数：

```java
Random r = new Random();
int i = r.nextInt();
```

常见的方法如下：

- `public Random()` ：创建一个新的随机数生成器。
- `public int nextInt(int n)` ：返回一个伪随机数，范围在 0 （包括）和 指定值 n （不包括）之间的 int 值。

## 4.3 ArrayList类

我们想存储对象数据，选择的容器，只有对象数组。而数组的长度是固定的，无法适应数据变化的需求。为了解决这个问题，Java提供了另一个容器 java.util.ArrayList 集合类,让我们可以更便捷的存储和操作对象数据。

`java.util.ArrayList` 是大小可变的数组的实现，存储在内的数据称为元素。此类提供一些方法来操作内部存储的元素。 `ArrayList` 中可不断添加元素，其大小也自动增长。

### 4.3.1 泛型

`java.util.ArrayList  <E>` ，表示一种指定的数据类型，叫做泛型。 `E` ，取自Element（元素）的首字母。在出现 `E` 的地方，我们使用一种引用数据类型将其替换即可，表示我们将存储哪种引用类型的元素。

常用方法如下：

- `public ArrayList()` ：构造一个内容为空的集合。
- `public boolean add(E e)` ： 将指定的元素添加到此集合的尾部。
- `public boolean add(E e)` ：将指定的元素添加到此集合的尾部。
- `public E remove(int index)` ：移除此集合中指定位置上的元素。返回被删除的元素。
- `public E get(int index)` ：返回此集合中指定位置上的元素。返回获取的元素。
- `public int size()` ：返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界。

ArrayList对象不能存储基本类型，只能存储引用类型的数据。类似`<int>`不能写，但是存储基本数据类型对应的 包装类型是可以的。所以，想要存储基本类型数据， `<>` 中的数据类型，必须转换后才能编写，转换写法如下：

| 基本类型 | 基本类型包装类 |
| -------- | -------------- |
| byte     | Byte           |
| short    | Short          |
| int      | Integer        |
| long     | Long           |
| float    | Float          |
| double   | Double         |
| char     | Character      |
| boolean  | Boolean        |

### 4.3.2 自动拆箱装箱

**装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。**

```java
Integer i = 10; //装箱
int n = i;  //拆箱
```

![img](D:\Java\笔记\图片\Java版本\自动拆箱)

在Java中每种基本数据类型都会存在对应的包装器类型，为什么这么设计？

Java是一个面相对象的编程语言，基本类型并不具有对象的性质，为了让基本类型也具有对象的特征，就出现了包装类型（如我们在使用集合类型Collection时就一定要使用包装类型而非基本类型），它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。

看一下下面的题目：

```java
public class Main {
    public static void main(String[] args) {
         
        Integer i1 = 100;
        Integer i2 = 100;
        Integer i3 = 200;
        Integer i4 = 200;
         
        System.out.println(i1==i2);    //true
        System.out.println(i3==i4);    //false
    }
}
```

为什么会这样呢？看下Integer的valueOf方法的具体实现：

```java
public static Integer valueOf(int i) {
	final int offset = 128;
	if (i >= -128 && i <= 127) { // must cache 
	    return IntegerCache.cache[i + offset];
	}
        return new Integer(i);
    }
```

而其中`IntegerCache`类的实现为：

```java
private static class IntegerCache {
    private IntegerCache(){}
    static final Integer cache[] = new Integer[-(-128) + 127 + 1];
 
    static {
        for(int i = 0; i < cache.length; i++)
	    cache[i] = new Integer(i - 128);
    }
}
```

由上可知，Integer包装类型如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。

我们会联想到其他的包装类类型是否也有这样的规律，看下Double的valueof方法的实现：

```java
public static Double valueOf(double d) {
        return new Double(d);
}
```

想想原因很简单：在某个范围内的整型数值的个数是有限的，而浮点数却不是。

注意，Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的。Double、Float的valueOf方法的实现是类似的。

对于Boolean类型比较一下就一目了然：

```java
public class Main {
    public static void main(String[] args) {
         
        Boolean i1 = false;
        Boolean i2 = false;
        Boolean i3 = true;
        Boolean i4 = true;
         
        System.out.println(i1==i2);    //true
        System.out.println(i3==i4);    //true
    }
}
```

源码：

```java
public static Boolean valueOf(boolean b) {
        return (b ? TRUE : FALSE);
    }
```

TRUE和FALSE都是静态常量

```java
public static final Boolean TRUE = new Boolean(true);
 
public static final Boolean FALSE = new Boolean(false);
```

另外还有一点需要注意：当 "=="运算符的两个操作数都是包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程），对基础数据类型进行运算。对于包装器类型，equals方法并不会进行类型转换。

```java
public class Main {
    public static void main(String[] args) {
         
        Integer a = 1;
        Integer b = 2;
        Integer c = 3;
        Integer d = 3;
        Integer e = 321;
        Integer f = 321;
        Long g = 3L;
        Long h = 2L;
         
        System.out.println(c==d);            //true
        System.out.println(e==f);            //false
        System.out.println(c==(a+b));        //true
        System.out.println(c.equals(a+b));   //true
        System.out.println(g==(a+b));        //true
        System.out.println(g.equals(a+b));   //false
        System.out.println(g.equals(a+h));   //true
    }
}
```

equals()方法源码

```java
//Integer类中
public boolean equals(Object obj) {
	if (obj instanceof Integer) {
	    return value == ((Integer)obj).intValue();
	}
	return false;
}
 
//Long类中
public boolean equals(Object obj) {
    if (obj instanceof Long) {
	return value == ((Long)obj).longValue();
    }
	return false;
}
```

指定equals比较的是内容本身，并且我们也可以看到equals的参数是一个Object对象，我们传入的是一个int类型，所以首先会进行装箱，然后比较，之所以返回true，是由于它比较的是对象里面的value值。当内容和类型都相同时才会返回true。

## 4.4 String类

`java.lang.String` 类代表字符串。Java程序中所有的字符串文字（例如 "abc" ）都可以被看作是实现此类的实例。此类不需要导入。因为是lang包下面的。

类 `String` 中包括用于检查各个字符串的方法，比如用于比较字符串，搜索字符串，提取子字符串以及创建具有翻译为大写或小写的所有字符的字符串的副本。

特点如下：

1. 字符串不变：字符串的值在创建后不能被更改。

   ```java
   String s1 = "abc";
   s1 += "d";
   System.out.println(s1); // "abcd"
   // 内存中有"abc"，"abcd"两个对象，s1从指向"abc"，改变指向，指向了"abcd"。
   ```

2.  因为String对象是不可变的，所以它们可以被共享。

   ```java
   String s1 = "abc";
   String s2 = "abc";
   // 内存中只有一个"abc"对象被创建，同时被s1和s2共享。
   ```

3. `"abc"` 等效于 `char[] data={ 'a' , 'b' , 'c' }` 。

   ```java
   例如：
   String str = "abc";
   相当于：
   char data[] = {'a', 'b', 'c'};
   String str = new String(data);
   // String底层是靠字符数组实现的。
   ```

构造方法如下：

- `public String()` ：初始化新创建的 String对象，以使其表示空字符序列。
- `public String(char[] value)` ：通过当前参数中的字符数组来构造新的String。
- `public String(byte[] bytes)` ：通过使用平台的默认字符集解码当前参数中的字节数组来构造新的String。

判断功能的方法：

- `public boolean equals (Object anObject)` ：将此字符串与指定对象进行比较。
- `public boolean equalsIgnoreCase (String anotherString)` ：将此字符串与指定对象进行比较，忽略大小写。

获取功能的方法：

- `public int length ()` ：返回此字符串的长度。
- `public String concat (String str)` ：将指定的字符串连接到该字符串的末尾。
- `public char charAt (int index)` ：返回指定索引处的 char值。
- `public int indexOf (String str)` ：返回指定子字符串第一次出现在该字符串内的索引。
- `public String substring (int beginIndex)` ：返回一个子字符串，从beginIndex开始截取字符串到字符串结尾。
- `public String substring (int beginIndex, int endIndex)` ：返回一个子字符串，从beginIndex到endIndex截取字符串。含beginIndex，不含endIndex。

转换字符串的方法：

- `public char[] toCharArray ()` ：将此字符串转换为新的字符数组。
- `public byte[] getBytes ()` ：使用平台的默认字符集将该 String编码转换为新的字节数组。
- `public String replace (CharSequence target, CharSequence replacement)` ：将与target匹配的字符串使用replacement字符串替换。

分割字符串的方法：

- `public String[] split(String regex)` ：将此字符串按照给定的regex（规则）拆分为字符串数组。

## 4.5 Arrays类

`java.util.Arrays` 此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法，调用起来非常简单。

操作数组的方法：

- `public static String toString(int[] a)` ：返回指定数组内容的字符串表示形式。
- `public static void sort(int[] a)` ：对指定的 int 型数组按数字升序进行排序。

## 4.6 Math类

`java.lang.Math` 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。

基本方法如下：

- `public static double abs(double a)` ：返回 double 值的绝对值。
- `public static double ceil(double a)` ：返回大于等于参数的最小的整数。
- `public static double floor(double a)` ：返回小于等于参数最大的整数。
- `public static long round(double a)` ：返回最接近参数的 long。(相当于四舍五入方法）