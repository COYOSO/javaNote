# 第一章 数组

数组：Array，是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。

简单的说,采用该结构的集合，对元素的存取有如下的特点：

* 查找元素快：通过索引，可以快速访问指定位置的元素

* 增删元素慢：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。

创建方式如下：

```java
// 动态初始化：初始化时由程序员只指定数组长度，由系统为数组元素分配初始值
char c1[] = new char[5];
// 静态初始化： 初始化时由程序员显示置顶每个数组的初始值，由系统决定数组长度
char c2[] = new char[]{'E','D','U','Y','U'};
char c3[] = {'E','D','U','Y','U'};
```

特点如下：

- 内存地址连续，
- 可以通过下标的成员访问,下标访问的性能高
- 增删操作带来更大的性能消耗(保证数据越界的问题,需动态扩容)

返回空数组：

```java
return Arrays.asList(); // 返回空的List集合
```

```java
// 将list转为int数组
return arrayList.stream().mapToInt(Integer::intValue).toArray();
```

判断数组为空：

```java
if (strs == null || strs.length == 0) {
    return "";
}
```

# 第二章 栈

栈：stack，又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。

简单的说：采用该结构的集合，对元素的存取有如下的特点

* 先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。

* 栈的入口、出口的都是栈的顶端位置。

  ![](D:\Java\笔记\图片\5-01【数据结构】\1-堆栈.png)

这里两个名词需要注意：

* 压栈：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。
* 弹栈：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。

## 2.1 Stack

栈（Stack）是一种后进先出（LIFO：Last In First Out）的数据结构。

`Stack`只有入栈和出栈的操作：

- 把元素压栈：`push(E)`；
- 把栈顶的元素“弹出”：`pop()`；
- 取栈顶元素但不弹出：`peek()`。

在Java中，我们用`Deque`可以实现`Stack`的功能：

- 把元素压栈：`push(E)`/`addFirst(E)`；
- 把栈顶的元素“弹出”：`pop()`/`removeFirst()`；
- 取栈顶元素但不弹出：`peek()`/`peekFirst()`。

为什么Java的集合类没有单独的`Stack`接口呢？因为有个遗留类名字就叫`Stack`，出于兼容性考虑，所以没办法创建`Stack`接口，只能用`Deque`接口来“模拟”一个`Stack`了。

当我们把`Deque`作为`Stack`使用时，注意只调用`push()`/`pop()`/`peek()`方法，不要调用`addFirst()`/`removeFirst()`/`peekFirst()`方法，这样代码更加清晰。


# 第三章 队列

队列：queue，简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。

简单的说，采用该结构的集合，对元素的存取有如下的特点：

* 先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。
* 队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。

![](D:\Java\笔记\图片\5-01【数据结构】\1-1队列图.bmp)

## 3.1 Queue接口

队列（`Queue`）是一种经常使用的集合。`Queue`实际上是实现了一个先进先出（FIFO：First In First Out）的有序表。它和`List`的区别在于，`List`可以在任意位置添加和删除元素，而`Queue`只有两个操作：

- 把元素添加到队列末尾；
- 从队列头部取出元素。

在Java的标准库中，队列接口`Queue`定义了以下几个方法：

- `int size()`：获取队列长度；
- `boolean add(E)`/`boolean offer(E)`：添加元素到队尾；
- `E remove()`/`E poll()`：获取队首元素并从队列中删除；
- `E element()`/`E peek()`：获取队首元素但并不从队列中删除。

对于具体的实现类，有的Queue有最大队列长度限制，有的Queue没有。注意到添加、删除和获取队列元素总是有两个方法，这是因为在添加或获取元素失败时，这两个方法的行为是不同的。我们用一个表格总结如下：

|                    | throw Exception | 返回false或null    |
| :----------------- | :-------------- | ------------------ |
| 添加元素到队尾     | add(E e)        | boolean offer(E e) |
| 取队首元素并删除   | E remove()      | E poll()           |
| 取队首元素但不删除 | E element()     | E peek()           |

注意：不要把`null`添加到队列中，否则`poll()`方法返回`null`时，很难确定是取到了`null`元素还是队列为空。

## 3.2 PriorityQueue

优先队列：`PriorityQueue`。

`PriorityQueue`和`Queue`的区别在于，它的出队顺序与元素的优先级有关，对`PriorityQueue`调用`remove()`或`poll()`方法，返回的总是优先级最高的元素。

要使用`PriorityQueue`，我们就必须给每个元素定义“优先级”。我们以实际代码为例，先看看`PriorityQueue`的行为：

```java
public class Main {
    public static void main(String[] args) {
        Queue<String> q = new PriorityQueue<>();
        // 添加3个元素到队列:
        q.offer("apple");
        q.offer("pear");
        q.offer("banana");
        System.out.println(q.poll()); // apple
        System.out.println(q.poll()); // banana
        System.out.println(q.poll()); // pear
        System.out.println(q.poll()); // null,因为队列为空
    }
}
```

我们放入的顺序是`"apple"`、`"pear"`、`"banana"`，但是取出的顺序却是`"apple"`、`"banana"`、`"pear"`，这是因为从字符串的排序看，`"apple"`排在最前面，`"pear"`排在最后面。

因此，放入`PriorityQueue`的元素，必须实现`Comparable`接口，`PriorityQueue`会根据元素的排序顺序决定出队的优先级。

如果我们要放入的元素并没有实现`Comparable`接口怎么办？`PriorityQueue`允许我们提供一个`Comparator`对象来判断两个元素的顺序。我们以银行排队业务为例，实现一个`PriorityQueue`：

```java
public class Main {
    public static void main(String[] args) {
        Queue<User> q = new PriorityQueue<>(new UserComparator());
        // 添加3个元素到队列:
        q.offer(new User("Bob", "A1"));
        q.offer(new User("Alice", "A2"));
        q.offer(new User("Boss", "V1"));
        System.out.println(q.poll()); // Boss/V1
        System.out.println(q.poll()); // Bob/A1
        System.out.println(q.poll()); // Alice/A2
        System.out.println(q.poll()); // null,因为队列为空
    }
}
```

```java
class UserComparator implements Comparator<User> {
    public int compare(User u1, User u2) {
        if (u1.number.charAt(0) == u2.number.charAt(0)) {
            // 如果两人的号都是A开头或者都是V开头,比较号的大小:
            return u1.number.compareTo(u2.number);
        }
        if (u1.number.charAt(0) == 'V') {
            // u1的号码是V开头,优先级高:
            return -1;
        } else {
            return 1;
        }
    }
}
```

## 3.3 Deque

我们知道，`Queue`是队列，只能一头进，另一头出。

如果把条件放松一下，允许两头都进，两头都出，这种队列叫双端队列（Double Ended Queue），学名`Deque`。

Java集合提供了接口`Deque`来实现一个双端队列，它的功能是：

- 既可以添加到队尾，也可以添加到队首；
- 既可以从队首获取，又可以从队尾获取。

我们来比较一下`Queue`和`Deque`出队和入队的方法：

|                    | Queue                  | Deque                           |
| :----------------- | :--------------------- | ------------------------------- |
| 添加元素到队尾     | add(E e) / offer(E e)  | addLast(E e) / offerLast(E e)   |
| 取队首元素并删除   | E remove() / E poll()  | E removeFirst() / E pollFirst() |
| 取队首元素但不删除 | E element() / E peek() | E getFirst() / E peekFirst()    |
| 添加元素到队首     | 无                     | addFirst(E e) / offerFirst(E e) |
| 取队尾元素并删除   | 无                     | E removeLast() / E pollLast()   |
| 取队尾元素但不删除 | 无                     | E getLast() / E peekLast()      |

对于添加元素到队尾的操作，`Queue`提供了`add()`/`offer()`方法，而`Deque`提供了`addLast()`/`offerLast()`方法。添加元素到队首、取队尾元素的操作在`Queue`中不存在，在`Deque`中由`addFirst()`/`removeLast()`等方法提供。

注意到`Deque`接口实际上扩展自`Queue`：

```java
public interface Deque<E> extends Queue<E> {
    ...
}
```

因此，`Queue`提供的`add()`/`offer()`方法在`Deque`中也可以使用，但是，使用`Deque`，最好不要调用`offer()`，而是调用`offerLast()`：

```java
public class Main {
    public static void main(String[] args) {
        Deque<String> deque = new LinkedList<>();
        deque.offerLast("A"); // A
        deque.offerLast("B"); // A <- B
        deque.offerFirst("C"); // C <- A <- B
        System.out.println(deque.pollFirst()); // C, 剩下A <- B
        System.out.println(deque.pollLast()); // B, 剩下A
        System.out.println(deque.pollFirst()); // A
        System.out.println(deque.pollFirst()); // null
    }
}
```

如果直接写`deque.offer()`，我们就需要思考，`offer()`实际上是`offerLast()`，我们明确地写上`offerLast()`，不需要思考就能一眼看出这是添加到队尾。

因此，使用`Deque`，推荐总是明确调用`offerLast()`/`offerFirst()`或者`pollFirst()`/`pollLast()`方法。

`Deque`是一个接口，它的实现类有`ArrayDeque`和`LinkedList`。

我们发现`LinkedList`真是一个全能选手，它即是`List`，又是`Queue`，还是`Deque`。但是我们在使用的时候，总是用特定的接口来引用它，这是因为持有接口说明代码的抽象层次更高，而且接口本身定义的方法代表了特定的用途。

```java
// 不推荐的写法:
LinkedList<String> d1 = new LinkedList<>();
d1.offerLast("z");
// 推荐的写法：
Deque<String> d2 = new LinkedList<>();
d2.offerLast("z");
```

可见面向抽象编程的一个原则就是：尽量持有接口，而不是具体的实现类。




#  第四章 链表

链表：linked list，由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。

链表也是线性的顺序存储数据。只是在内存地址上不是连续的，每一个节点里存到下一个节点的指针 (Pointer)

刷算法题的时候记住：

- 有dummy哑结点
- 有cur现在的节点，不要让head节点移动，直接复制给cur，让cur节点移动

## 4.1 单链表

我们常说的链表结构有单向链表与双向链表，这里介绍的是单向链表。简单的说，采用该结构的集合，对元素的存取有如下的特点：

* 多个结点之间，通过地址进行连接。
* 查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素
* 增删元素快：只需要修改连接下个元素的地址即可。

单链表的实现如下：

```java
/*
 *	定义节点
 *  链表由节点构成
 */
public class ListNode<E> {
    private E e;   				//数据data
    private ListNode<E> next; 	 //指向下一个节点

    public ListNode() {
    }

    public ListNode(E e) {
        this.e = e;
    }

    public ListNode<E> getNext() {
        return next;
    }

    public void setNext(ListNode<E> next) {
        this.next = next;
    }

    public E getE() {
        return e;
    }

    public void setE(E e) {
        this.e = e;
    }
}
```

```java
/*
 * 定义实现类LinkedList　*　实现链表的基本功能：增删改查
 */
public class LinkedList<E> {
    // 声明头节点尾节点
    private ListNode<E> head;
    private ListNode<E> last;
    // 链表的大小
    private int size;

    /*
     * 构造函数，构建一个链表
     */
    public LinkedList() {
        head = new ListNode<E>();
        last = head;
    }

    /*
     * 返回单链表中存储的元素总数
     */
    public int size() {
        return size;
    }

    /*
     * 获取指定索引位置的节点对象
     */
    public ListNode<E> get(int index) {
        if (index < 0 || index > size - 1)
            return null;
        ListNode<E> node = head.getNext(); // 将头结点的下一个节点赋给Node
        for (int i = 0; i < index; i++) {
            node = node.getNext(); // 获取node的下一个节点
        }
        return node;
    }

    /*
     * 获取指定索引位置的数据
     */
    public E getValue(int index) {
        ListNode<E> node = get(index);
        return node.getE();
    }

    /*
     * 增加元素
     */
    public void add(E e) {
        ListNode<E> node = new ListNode<E>(e); // 以e实例化一个节点
        last.setNext(node); // 往尾节点后追加节点
        last = node; // 该节点设为最后一个节点
        size++;
    }

    /*
     * 指定位置插入元素,返回插入的节点数据
     */
    public E add(int index, E e) {
        if (index < 0 || index > size - 1)
            return null;
        ListNode<E> node = new ListNode<E>(e); // 实例化一个节点
        // 找到插入的原节点
        ListNode<E> oldNode = get(index);
        if (index == 0) {// 当索引为0时
            head.setNext(node);
        } else {
            // 找到插入节点的上一个
            ListNode<E> bNode = get(index - 1);
            bNode.setNext(node);
        }
        node.setNext(oldNode);
        size++;
        return oldNode.getE();
    }

    /*
     * 删除指定的节点e,并返回删除节点的数据
     */
    public E delete(int index) {
        if (index < 0 || index > size - 1)
            return null;
        if (index == 0) {// 当索引为1，令头结点的下一个节点为头结点
            ListNode<E> node = head.getNext();
            head.setNext(node.getNext());
        }
        // 获取要删除节点的前一个节点
        ListNode<E> bNode = get(index - 1);
        // 获取要删除的节点
        ListNode<E> Node = bNode.getNext();
        // 获取要删除节点的下一个节点
        ListNode<E> nNode = Node.getNext();
        // 删除该节点
        bNode.setNext(nNode);
        // 清除Node的下一个节点
        Node.setNext(null);
        size--;
        return Node.getE();// 返回节点中的数据域
    }

    /*
     * 修改指定位置的数据域并返回修改后的数据
     */
    public E set(int index, E e) {
        if (index < 0 || index > size - 1)
            return null;
        // 获取指定位置的原节点
        ListNode<E> node = get(index);
        node.setE(e);
        return node.getE();
    }
}
```

## 4.2 双向链表

双向链表(双链表)是链表的一种。和单链表一样，双链表也是由节点组成，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。

![](D:\Java\笔记\图片\5-01【数据结构】\2-1双链表.png)

```java
static final class Node {
    // 前一个节点
    volatile Node prev;
    // 后一个节点
    volatile Node next;
    // 链表节点存储的具体数据
    volatile Thread thread;
}
```

# 第五章 树

## 5.1 二叉树

二叉树：每个子节点只有两个节点的树，每个结点至多拥有两棵子树(即二叉树中不存在度大于2的结点)，并且，二叉树的子树有左右之分，其次序不能任意颠倒。顶上的叫根结点，两边被称作“左子树”和“右子树”。

![](D:\Java\笔记\图片\5-01【数据结构】\3-1二叉树.png)

二叉查找树也称为有序二叉查找树，满足二叉查找树的一般性质，是指一棵空树具有如下性质：

1. 任意节点左子树不为空,则左子树的值均小于根节点的值
2. 任意节点右子树不为空,则右子树的值均大于于根节点的值
3. 任意节点的左右子树也分别是二叉查找树
4. 没有键值相等的节点

二叉树又分为：完美二叉树，完全二叉树，完满二叉树

完美二叉树：又称为满二叉树，除了叶子节点之外的每一个节点都有两个孩子节点，每层都被完全填充

![](D:\Java\笔记\图片\5-01【数据结构】\3-2完美二叉树.png)

完全二叉树：除了最后一层之外的其他每一层都被完全填充，并且所有的节点都保持向左对齐

![](D:\Java\笔记\图片\5-01【数据结构】\3-3完全二叉树.png)

二叉树中的遍历规则有如下三种：

- 先序遍历：所谓的前序遍历就是先访问根节点，再访问左节点，最后访问右节点，即根-左-右遍历(前序)
- 中序遍历：所谓的中序遍历就是先访问左节点，再访问根节点，最后访问右节点，即左-根-右遍历
- 后序遍历：所谓的后序遍历就是先访问左节点，再访问右节点，最后访问根节点。即左-右-根遍历

一个二叉查找树是由n个节点随机构成，所以对于某些情况，二叉查找树会退化成一个有n个节点的线性链。

### 5.1.1 求二叉树深度

求二叉树深度：

```java
static class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    public TreeNode(int val) {
        this.val = val;
    }
}
```

```java
// 递归求深度
public static int treeDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    // 计算左子树的深度
    int left = treeDepth(root.left);
    // 计算右子树的深度
    int right = treeDepth(root.right);
    // 树root的深度=路径最长的子树深度 + 1
    return left >= right ? (left + 1) : (right + 1);
}
```

```java
// 使用队列来实现	
public int treeDepth2(TreeNode root) {
    if (root == null) return 0;

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int res = 0, size = 0;
    while (!queue.isEmpty()) {
        size = queue.size();
        while (size > 0) {
            TreeNode poll = queue.poll();
            if (poll.left != null) queue.offer(poll.left);
            if (poll.right != null) queue.offer(poll.right);
            size--;
        }
        res++;
    }
    return res;
}
```

### 5.1.2 树的遍历

中序遍历：左根右，inorderTraversal。

```java
public static void inorderTraversal(TreeNode root) {
    Deque<TreeNode> stack = new LinkedList<TreeNode>();
    while (!stack.isEmpty() || root != null) {
        while (root != null) {
            stack.push(root);
            root = root.left;
        }
        root = stack.pop();
        System.out.println(root.val);
        root = root.right;
    }
}
```

前序遍历 (preorder traversal) - 中序遍历 (inorder traversal) - 后序遍历 (postorder traversal)

## 5.2 BST二叉查找树



## 5.2 红黑树

红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。

红黑树的约束:

- 节点可以是红色的或者黑色的
- 根节点是黑色的
- 叶子节点(特指空节点)是黑色的
- 每个红色节点的子节点都是黑色的
- 任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同

红黑树的特点:

​	速度特别快，趋近平衡树，查找叶子元素最少和最多次数不多于二倍

## 5.2 B树

## 5.3 B+树

# 第六章 哈希表

哈希法又称散列法、杂凑法以及关键字地址计算法等，相应的表称为哈希表。这种方法的基本思想是：首先在元素的关键字*k*和元素的存储位置*p*之间建立一个对应关系*f*，使得*p=f(k)*，*f*称为哈希函数。

创建哈希表时，把关键字为*k*的元素直接存入地址为*f(k)*的单元；以后当查找关键字为*k*的元素时，再利用哈希函数计算出该元素的存储位置*p=f(k)*，从而达到按关键字直接存取元素的目的。

当关键字集合很大时，关键字值不同的元素可能会映象到哈希表的同一地址上，即 *k1*≠*k2* ，但 *H*（*k1*）*=H*（*k2*），这种现象称为**冲突，**此时称*k1*和*k2*为**同义词。**实际中，冲突是不可避免的，只能通过改进哈希函数的性能来减少冲突。

综上所述，哈希法主要包括以下两方面的内容：

1. 如何构造哈希函数
2. 如何处理冲突。

## 6.1 哈希函数的构造方法

构造哈希函数的原则是：①函数本身便于计算；②计算出来的地址分布均匀，即对任一关键字*k*，*f(k)* 对应不同地址的概率相等，目的是尽可能减少冲突。

下面介绍构造哈希函数常用的五种方法。

### 数字分析法

取关键字或关键字的某个线性函数值为哈希地址。即H(key)=key 或 H(key)=a*key+b  (a,b为常数)。

* 举例1：统计1-100岁的人口，其中年龄作为关键字，哈希函数取关键字自身。查找年龄25岁的人口有多少，则直接查表中第25项。

  | 地址 | 01          02         03   ...           25          26            27  ...   100 |
  | ---- | ------------------------------------------------------------ |
  | 年龄 | 1             2            3   ...            25          26           27   ...   .... |
  | 人数 | 3000    2000  .............             1050                 |
  | ...  |                                                              |

* 举例2：统计解放以后出生人口，其中年份作为关键字，哈希函数取关键字自身加一个常数H(key)=key+(-1948).查找1970年出生的人数，则直接查(1970-1948)=22项即可。

  | 地址 | 01          02         03   ...           22          23            24  ... |
  | ---- | ------------------------------------------------------------ |
  | 年份 | 1949     1950      1951   ...     1970                       |
  | 人数 | .............            15000                               |
  | ...  |                                                              |

### 平方取中法

取关键字平方后的中间几位为哈希地址。（较常用的一种）

* 举例：为BASIC源程序中的标识符键一个哈希表（假设BASIC语言允许的标识符为一个字母或者一个字母和一个数字两种情况，在计算机内可用两位八进制数表示字母和数字），假设表长为512，则可取关键字平方后的中间9位二进制数为哈希地址。（每3个二进制位可表示1位八进制位，即3个八进制位为9个二进制位）

  A ：01 （A的ASCII码值为65,65的八进制为101，取后两位表示关键字）

  B：02 （B的ASCII码值为66,66的八进制为102，取后两位表示关键字）

  ...

  Z：32（Z的ASCII码值为90,90的八进制为132，取后两位表示关键字）

  ...

  0：60（0的ASCII码值为48,48的八进制为60，取后两位表示关键字）

  ...

  

  9：71（9的ASCII码值为57,57的八进制为71，取后两位表示关键字）

  | 记录 | 关键字 | 关键字的平方      | 哈希地址（![2^{17}](https://private.codecogs.com/gif.latex?2%5E%7B17%7D)~![2^{9}](https://private.codecogs.com/gif.latex?2%5E%7B9%7D)） |
  | ---- | ------ | ----------------- | ------------------------------------------------------------ |
  | A    | 0100   | 0***\*010\****000 | 010                                                          |
  | I    | 1100   | 1***\*210\****000 | 210                                                          |
  | P1   | 2061   | 4***\*310\****541 | 310                                                          |
  | Q2   | 2162   | 4***\*741\****304 | 741                                                          |

### 分段叠加法

这种方法是按哈希表地址位数将关键字分成位数相等的几部分（最后一部分可以较短），然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。具体方法有**折叠法**与**移位法。**

移位法是将分割后的每部分低位对齐相加，折叠法是从一端向另一端沿分割界来回折叠（奇数段为正序，偶数段为倒序），然后将各段相加。

例如：*key=12360324711202065,*哈希表长度为*1000*，则应把关键字分成*3*位一段，在此舍去最低的两位*65*，分别进行移位叠加和折叠叠加，求得哈希地址为*105*和*907*，如图*8.24*所示。

![](D:\Java\笔记\图片\5-01【数据结构】\1分段叠加法.png)

### 除留余数法

取关键字为某个不大于哈希表表长m的数p除后所得余数为哈希地址（p为素数）

`H（key）=key  MOD  p`p<=m   （最简单，最常用）p的选取很重要

一般情况，p可以选取为质数或者不包含小于20的质因数的合数（合数指自然数中除了能被1和本身整除外，还能被其他数（0除外）整除的数）。

假设哈希表长为*m*，*p*为小于等于*m*的最大素数，则哈希函数为`h（k）=k % p` ，其中*%*为模*p*取余运算。

* 例如，已知待散列元素为（*18*，*75*，*60*，*43*，*54*，*90*，*46*），表长*m=10*，*p=7*，则有

  *h(18)=18 % 7=4  h(75)=75 % 7=5  h(60)=60 % 7=4*  

  *h(43)=43 % 7=1  h(54)=54 % 7=5  h(90)=90 % 7=6*  

  *h(46)=46 % 7=4*

  此时冲突较多。为减少冲突，可取较大的*m*值和*p*值，如*m=p=13*，结果如下：

  *h(18)=18 % 13=5  h(75)=75 % 13=10  h(60)=60 % 13=8*   

  *h(43)=43 % 13=4  h(54)=54 % 13=2  h(90)=90 % 13=12*  

  *h(46)=46 % 13=7*

### 伪随机数法

采用一个伪随机函数做哈希函数，即*`h(key)=random(key)`*。

在实际应用中，应根据具体情况，灵活采用不同的方法，并用实际数据测试它的性能，以便做出正确判定。通常应考虑以下五个因素 ：

* 计算哈希函数所需时间 （简单）。

* 关键字的长度。

* 哈希表大小。

* 关键字分布情况。

* 记录查找频率

## 6.2 处理哈希冲突的方法

虽然我们不希望发生冲突，但实际上发生冲突的可能性仍是存在的。

当关键字值域远大于哈希表的长度，而且事先并不知道关键字的具体取值时。冲突就难免会发 生。另外，当关键字的实际取值大于哈希表的长度时，而且表中已装满了记录，如果插入一个新记录，不仅发生冲突，而且还会发生溢出。

因此，处理冲突和溢出是 哈希技术中的两个重要问题。常用的解决冲突方法有以下几种：

### 开放定址法

用开放定址法解决冲突的做法是：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。 沿此序列逐个单元地查找，直到找到给定 的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。查找时探查到开放的 地址则表明表中无待查的关键字，即查找失败。

>  注意：
>
> 1. 用开放定址法建立散列表时，建表前须将表中所有单元(更严格地说，是指单元中存储的关键字)置空。
> 2. 空单元的表示与具体的应用相关。

按照形成探查序列的方法不同，可将开放定址法区分为线性探查法、线性补偿探测法、随机探测等 。

#### 线性探查法(Linear Probing)

该方法的基本思想是：将散列表T[0..m-1]看成是一个循环向量，若初始探查的地址为d(即h(key)=d)，则最长的探查序列为：`d，d+l，d+2，…，m-1，0，1，…，d-1`即:探查时从地址d开始，首先探查T[d]，然后依次探查T[d+1]，…，直到T[m-1]，此后又循环到T[0]，T[1]，…，直到探查到T[d-1]为止。

探查过程终止于三种情况：

* 若当前探查的单元为空，则表示查找失败（若是插入则将key写入其中）；
* 若当前探查的单元中含有key，则查找成功，但对于插入意味着失败；
* 若探查到T[d-1]时仍未发现空单元也未找到key，则无论是查找还是插入均意味着失败(此时表满)。

利用开放地址法的一般形式，线性探查法的探查序列为： `h i =(h(key)+i)％m 0≤i≤m-1 //即d i =i`

用线性探测法处理冲突，思路清晰，算法简单，但存在下列缺点：

1. 处理溢出需另编程序。一般可另外设立一个溢出表，专门用来存放上述哈希表中放不下的记录。此溢出表最简单的结构是顺序表，查找方法可用顺序查找。
2. 按上述算法建立起来的哈希表，删除工作非常困难。假如要从哈希表 HT 中删除一个记录，按理应将这个记录所在位置置为空，但我们不能这样做，而只能标上已被删除的标记，否则，将会影响以后的查找。
3. 线性探测法很容易产生堆聚现象。所谓堆聚现象，就是存入哈希表的记录在表中连成一片。按照线性探测法处理冲突，如果生成哈希地址的连续序列愈长 ( 即不同关键字值的哈希地址相邻在一起愈长 ) ，则当新的记录加入该表时，与这个序列发生冲突的可能性愈大。因此，哈希地址的较长连续序列比较短连续序列生长得快，这就意味着，一旦出现堆聚 ( 伴随着冲突 ) ，就将引起进一步的堆聚。

####    二次探测再散列

$$
di=1^2，-1^2，2^2，-2^2，…，k^2，-k^2    ( k<=m/2 )
$$

这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。

#### 随机探测

di=伪随机数序列；

具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），生成一个伪随机序列，并给定一个随机数做起点，每次去加上这个伪随机数++就可以了。

### 拉链法

拉链法解决冲突的方法是：将所有关键字为同义词的结点链接在同一个单链表中 。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于 1，但一般均取α≤1。

与开放定址法相比，拉链法有如下几个优点：

1. 拉链法处理冲突简单 ，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；
2. 由于拉链法中各链表上的 结点空间是动态申请的 ，故它更适合于造表前无法确定表长的情况；
3. 开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；
4. 在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。

拉链法的缺点如下：
指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。

### 再散列法

再散列法其实很简单，就是再使用哈希函数去散列一个输入的时候，输出是同一个位置就再次散列，直至不发生冲突位置

缺点：每次冲突都要重新散列，计算时间增加。
