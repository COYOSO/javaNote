计算机网络体系可以大致分为一下三种，OSI七层模型、TCP/IP四层模型和五层模型。

- OSI七层模型：大而全，但是比较复杂、而且是先有了理论模型，没有实际应用。
- TCP/IP四层模型：是由实际应用发展总结出来的，从实质上讲，TCP/IP只有最上面三层，最下面一层没有什么具体内容，TCP/IP参考模型没有真正描述这一层的实现。
- 五层模型：五层模型只出现在计算机网络教学过程中，这是对七层模型和四层模型的一个折中，既简洁又能将概念阐述清楚。

![](D:\Java\笔记\图片\5-13【网络模型-应用层】\1.1.png)

**OSI网络七层模型**

OSI网络七层模型是ISO组织定义的国际通用标准模型，其目的是为了制定全球统一的网络模型标准，让全球内的国家、组织可以实现网络互通。OSI网络七层模型分别为：**应用--表示--会话--传输--网络--数据链路--物理**

* **应用层**：给用户和抽象的网络之间提供一个接口，为应用程序提供交互服务。常见协议有：TELENT、HTTP、HTTPS、FTP、DNS、POP3、SMTP等。
* **表示层**：表示层提供各种数据的编码和转换功能，确保一个系统的应用层发送的数据能被另一个系统的应用层识别。例如：数据格式变化、数据加密与解密、数据压缩与解压等。常见协议有：Rlogin, SNMP, Gopher。
* **会话层**：会话层就是负责建立、管理和终止两个节点（应用程序）之间的通信会话。负责维护两个节点之间的传输联接，确保点到点传输不中断，以及管理数据交换等功能。
* **传输层**：传输层实现了网络中不同主机上的用户进程之间的数据通信，为用户提供了端到端的服务。定义了传输数据的协议端口号，以及流量控制和差错校验。常见协议有：TCP、UDP。
* **网络层**：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。IP协议是Internet的基础。常见协议有：IP, ICMP, ARP, RARP, AKP, UUCP。
* **数据链路层** ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。
* **物理层**：物理层的作用就是提供了网络的双向通讯，为双向传输提供了有保障的通路。考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

就像一个公司要分很多部门一样，每个部门各司其职，网络模型分层的目的也是为了这样，另外分层还能达到降低复杂性、统一标准、工程模块化、快速发展、易于学习掌握等目的。

公司的部门和部门之间肯定是有一定联系的。所以在OSI七层模型中，相邻层之间也都是有联系的，这个联系就叫做服务接入点，简称SA(service access)。所以正是因为相邻两层之间有SA，这两层之间才会有联系。相邻两层之间必须有服务接入点。

**TCP/IP网络协议四层模型**

**TCP/IP**（`Transmission Control Protocol/Internet Protocol`，传输控制协议/网际协议）指能够在多个不同网络间实现信息传输的协议簇。该协议具有很强的灵活性，支持任意规模的网络，几乎可连接所有服务器和工作站。定义了主机如何连入因特网及数据如何在它们之间传输的标准。

TCP/IP协议不仅仅指的是TCP 和IP两个协议，而是指一个由TCP、IP、UDP、FTP、SMTP等协议构成的协议簇， 只是因为在TCP/IP协议中TCP协议和IP协议最具代表性，所以被称为TCP/IP协议。

TCP/IP协议在一定程度上参考了OSI的体系结构。不同于ISO模型的七个分层，TCP/IP协议参考模型把所有的TCP/IP系列协议归类到四个抽象层中：应用--传输--网络--网络接口层。数据链路层和物理层合并为网络接口层。网络层也称为IP层。

TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。

![](D:\Java\笔记\图片\5-13【网络模型-应用层】\3.png)

# 第一章 应用层

“应用层”的作用，就是向**用户提供一组常用的应用程序，规定应用程序的数据格式**，比如电子邮件、文件传输访问、远程登录等。

TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了"应用层"。在这一层，数据的单位称为帧（frame）。

我们常见应用层的网络服务协议有：HTTP、HTTPS、DNS、FTP、DHCP、TELNET、SMTP、POP3、IMAP、SNMP等。

|        应用        | 应用层协议 | 端口号  | 传输层协议 |            备注             |
| :----------------: | :--------: | :-----: | :--------: | :-------------------------: |
|   超文本传送协议   |    HTTP    |   80    |    TCP     |                             |
| 超文本传送安全协议 |   HTTPS    |   443   |    TCP     |                             |
|      域名解析      |    DNS     |   53    |  TCP/UDP   | 长度超过 512 字节时使用 TCP |
|    文件传送协议    |    FTP     |  20/21  |    TCP     |  控制连接 21，数据连接 20   |
|  动态主机配置协议  |    DHCP    |  67/68  |    UDP     |                             |
|    远程终端协议    |   TELNET   |   23    |    TCP     |                             |
|  简单邮件传送协议  |    SMTP    |   25    |    TCP     |                             |
|    邮件读取协议    |    POP3    |   110   |    TCP     |                             |
|  网际报文存取协议  |    IMAP    |   143   |    TCP     |                             |
|  简单网络管理协议  |    SNMP    | 161/162 |    UDP     |                             |

## 1.1 HTTP协议

HTTP协议是`Hyper Text Transfer Protocol`（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议，定义了客户端和服务器端通信的时候，发送数据的格式。HTTP协议就是TCP/IP协议中专门用于浏览器与Web服务器之间通信的应用层协议。

通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行，比如"HTTP/1.1 200 OK"，和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。HTTP使用TCP而不是UDP的原因在于（打开）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据和错误纠正。

浏览器与Web服务器之间的协议是应用层协议，当前，我们主要遵循的协议为HTTP/1.1。HTTP协议是Web开发的基础，这是一个无状态的协议，客户机与服务器之间通过请求和相应完成一次会话（Session）。

![](D:\Java\笔记\图片\5-13【网络模型-应用层】\1-1.png)

特点如下：

- 基于`TCP/IP`的高级协议。
- 默认端口号：`80`。
- 基于请求/响应模型的：一次请求对应一次响应。
- 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
- 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
- HTTP 允许传输任意类型的数据。传输的类型由 `Content-Type` 加以标记。
- 支持客户端/服务器模式。

HTTP 协议由HTTP 请求和HTTP 响应组成，当在浏览器中输入网址访问某个网站时，浏览器会将请求封装成一个HTTP 请求发送给服务器站点，服务器接收到请求后会组织响应数据封装成一个HTTP 响应返回给浏览器。即没有请求就没有响应。

### 1.1.1 URI和URL

- URI：统一资源标识符。相当于共和国，所以URI更大
- URL：统一资源定位符。相当于中华人民共和国

我们在浏览器的地址栏里输入的网站地址叫做URL (Uniform Resource Locator，统一资源定位符)。URL中描述了协议，用于检索资源和资源名称。如果是web上的资源，所用的协议就是http或者https。如果资源是文件类型的，那么使用的协议就是ftp。URL由七部分组成：

- 1：所使用的协议（http,ftp）
- 2：服务器的位置（IP号）
- 3：服务器上的端口号（0~65535）
- 4：资源所在的路径
- 5：参数（访问该资源所带的参数）
- 6：片段（发给http服务器的数据）

![](D:\Java\笔记\图片\5-13【网络模型-应用层】\1.2.png)

只要能唯一标识资源的就是URI，在URI的基础上给出其资源的访问方式的就是URL。

### 1.1.1 请求消息

请求消息：客户端发给服务器端的数据

```java
// 请求行
POST /login.html HTTP/1.1

// Chrome浏览器请求头
Host: localhost
Connection: keep-alive
Cache-Control: max-age=0

// 请求空行

// 请求体，只有POST有，是参数
username = zhangsan
```

数据格式如下：请求行、请求头、请求空行、请求体。

1. 请求行：`请求方式 请求URL 请求协议/版本`，实例：`GET /login.html HTTP/1.1`。包括请求方法，访问的资源 URL，使用的 HTTP 版本。`GET`和`POST`是最常见的 HTTP 方法，除此以外还包括`DELETE、HEAD、OPTIONS、PUT、TRACE`。

2. 请求头：`请求头名称: 请求头值`。格式为“属性名:属性值”，服务端根据请求头获取客户端的信息，主要有`cookie、host、connection、accept-language、accept-encoding、user-agent`。

   `User-Agent`：浏览器告诉服务器，访问服务器使用的浏览器款式。这样可以让服务器获取头信息，解决浏览器的兼容性问题。

   `Referer`：`http://localhost/login.html`告诉服务器，当前请求从何而来。这样有两个好处：1. 防止盗链发生。2. 统计工作。

3. 请求空行

   空行，真的只是一个空行，它主要是起了分割的作用。分割请求头和请求体。

4. 请求体(请求正文)

   在GET方法中是没有请求体的，但是在POST中是有请求体的。这是因为POST的参数不显示，都在请求体中封装POST请求消息的请求参数。

`HTTP`协议一共有着7种请求方式GET、POST、DELETE、HEAD、OPTIONS、PUT、TRACE。，但是常用的只有两种GET和POST。

- GET 参数通过 URL也就是请求行传递，POST参数数据 放在 Request body请求体 中。
- GET 请求在 URL 中传送的参数是有长度限制的，而 POST没有，所以POST可以用于文件的上传。
- GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。
- GET 在浏览器回退时是无害的，而 POST 会再次提交请求。
- GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。
- GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。
- GET 请求只能进行 URL 编码，而 POST 支持多种编码方式。
- GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。
- 对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。

但是实际上 GET 和 POST 本质上没有区别：

- GET 和 POST 是HTTP 协议中的两种发送请求的方法，HTTP是基于 TCP/IP 的关于数据如何在万维网中如何通信的协议。

- HTTP 的底层是 TCP/IP，所以 GET 和 POST 的底层也是 TCP/IP，也就是说，GET/POST 都是 TCP 链接。GET 和 POST 能做的事情是一样一样的。要给 GET 加上 request body，给 POST 带上 url 参数，技术上是完全行的通的。


在万维网世界中，TCP 就像汽车，交通规则就是HTTP，浏览器和服务器就是运输公司。HTTP 给汽车运输设定了好几个服务类别，有 GET, POST, PUT, DELETE 等等。

HTTP 规定，执行 GET 请求时设置 method 为 GET，并且把传送的数据放在url 中以方便记录。如果是 POST 请求，就要设置 method 为 POST，并把传送数据放在方法体中。当然，也可以在 GET 的时候往方法体中放一些数据，在POST的时候往URL中放一些数据。HTTP 只是个行为准则，而 TCP 才是 GET 和 POST 怎么实现的基本。

上面说的是HTTP 对 GET 和 POST 参数的传送渠道（url 还是 requrest body）提出的要求，接下来说一下参数大小的限制。

浏览器和服务器就是运输公司，它们用来接收和传送数据，但是这也需要一些成本，因此会限制URL中的参数长度，不限制方法体中参数长度。如果是GET方式传数据，在方法体中放一些数据，不同的服务器处理方式不一样，有的会接收数据，有的忽略。GET 和 POST 本质上就是 TCP 链接，并无差别。但是由于 HTTP 的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。

GET 和 POST 还有一个重大区别，简单的说：GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。

- 对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；
- 而对于 POST，浏览器先发送 header，服务器响应 100（continue），浏览器再发送 data，服务器响应 200（返回数据）。

![](D:\Java\笔记\图片\5-13【网络模型-应用层】\应用层.jpg)

因为 POST 需要两步，时间上消耗的要多一点，看起来 GET 比 POST 更有效。但是GET并不能替换POST：

- GET 与 POST 都有自己的语义，不能随便混用。
- 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的 TCP 在验证数据包完整性上，有非常大的优点。
- 并不是所有浏览器都会在 POST 中发送两次包，比如 Firefox 就只发送一次。

### 1.1.2 响应消息

响应消息：服务器端发送给客户端的数据

```html
<!--响应行 协议/版本 响应状态码 状态码描述-->
HTTP/1.1 200
Content-Type: text/html;charset=UTF-8
Content-Length: 100
Date: Mon, 07 Mar 2022 08:01:01 GMT
Keep-Alive: timeout=20
Connection: keep-alive
```

数据格式如下：响应行、响应头、响应空行、响应体。

1. 响应行：`协议/版本 响应状态码 状态码描述 HTTP/1.1 200`。响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。

2. 响应头：格式：`响应头名称：值`。常见的响应头有：`connection、content-type、content-encoding、content-length、set-cookie、Last-Modified、Cache-Control、Expires`。

   `Content-Type`：服务器告诉客户端本次响应体数据格式以及编码格式

   `Content-disposition`：服务器告诉客户端以什么格式打开响应体数据。`in-line`：默认值，在当前页面内部打开。不经常使用。`attachment`：以附件的形式打开响应体，通常用于文件下载。

3. 相应空行：仅仅是一个空行

4. 响应体：响应体：传输的数据。

常用的相应状态码如下：

| 状态码 | 类别                             | 原因                       |
| ------ | -------------------------------- | -------------------------- |
| 1xx    | Informational(信息性状态码)      | 接收的请求正在处理         |
| 2xx    | Success（成功状态码）            | 请求正常处理完毕           |
| 3xx    | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4xx    | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5xx    | Server Error（服务器错误状态码） | 服务器处理请求错误         |

| 状态码 | 含义               | 解释                                                         |
| ------ | :----------------- | ------------------------------------------------------------ |
| 200    | 成功               | 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 |
| 300    | 多种选择           | 针对请求，服务器可执行多种操作。 <br />服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择 |
| 302    | 重定向             | 服务器目前从不同位置的网页响应请求，<br />但请求者应继续使用原有位置来进行以后的请求 |
| 304    | 未修改（请求缓存） | 自从上次请求后，请求的网页未修改过。 <br />服务器返回此响应时，不会返回网页内容 |
| 305    | 使用代理           | 请求者只能使用代理访问请求的网页。 <br />如果服务器返回此响应，还表示请求者应使用代理 |
| 400    | 错误请求           | 服务器不理解请求的语法                                       |
| 401    | 未授权             | 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应  |
| 403    | 禁止               | 服务器拒绝请求                                               |
| 404    | 未找到             | 服务器找不到请求的网页                                       |
| 405    | 方法禁用           | 禁用请求中指定的方法                                         |
| 500    | 服务器内部错误     | 服务器遇到错误，无法完成请求                                 |
| 502    | 错误网关           | 服务器作为网关或代理，从上游服务器收到无效响应               |
| 503    | 服务不可用施       | 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态 |
| 504    | 网关超时           | 服务器作为网关或代理，但是没有及时从上游服务器收到请求       |

### 1.1.3 HTTP1.0和HTTP1.1

区别如下：

- 长连接：HTTP1.0 默认使用短连接，每次请求都需要建立新的 TCP 连接，连接不能复用。HTTP1.1 支持长连接，复用 TCP 连接，允许客户端通过同一连接发送多个请求。不过，这个优化策略也存在问题，当一个队头的请求不能收到响应的资源时，它将会阻塞后面的请求。这就是“队头阻塞”问题。
- 断点续传：HTTP1.0 不支持断点续传。HTTP1.1 新增了 range 字段，用来指定数据字节位置，支持断点续传。
- 错误状态响应码：在 HTTP1.1 中新增了 24 个错误状态响应码，如`409（Conflict）`表示请求的资源与资源的当前状态发生冲突、`410（Gone）`表示服务器上的某个资源被永久性的地删除。
- Host 头处理：在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名。到了 HTTP1.1 时代，虚拟主机技术发展迅速，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个 IP 地址，故 HTTP1.1 增加了 HOST 信息。

### 1.1.4 HTTP1.1和HTTP2.0

- 新的二进制格式：HTTP1.1 基于文本格式传输数据；HTTP2.0 采用二进制格式传输数据，解析更高效。
- 多路复用：在一个连接里，允许同时发送多个请求或响应，并且这些请求或响应能够并行地传输而不被阻塞，避免 HTTP1.1 出现的“队头堵塞”问题。
- 头部压缩，HTTP1.1 的 header 带有大量信息，而且每次都要重复发送；HTTP2.0 把 header 从数据中分离，并封装成头帧和数据帧，使用特定算法压缩头帧，有效减少头信息大小。并且 HTTP2.0 在客户端和服务器端记录了之前发送的键值对，对于相同的数据，不会重复发送。比如请求 a 发送了所有的头信息字段，请求 b 则只需要发送差异数据，这样可以减少冗余数据，降低开销。
- 服务端推送：HTTP2.0 允许服务器向客户端推送资源，无需客户端发送请求到服务器获取。

## 1.2 HTTPS协议

HTTPS 原理：首先是 TCP 三次握手，然后客户端发起一个 HTTPS 连接建立请求，客户端先发一个`Client Hello`的包，然后服务端响应`Server Hello`，接着再给客户端发送它的证书，然后双方经过密钥交换，最后使用交换的密钥加解密数据。

- 协商加密算法 。在`Client Hello`里面客户端会告知服务端自己当前的一些信息，包括客户端要使用的 TLS 版本，支持的加密算法，要访问的域名，给服务端生成的一个随机数（Nonce）等。需要提前告知服务器想要访问的域名以便服务器发送相应的域名的证书过来。
- 服务端响应`Server Hello`，告诉客户端服务端选中的加密算法。

- 接着服务端给客户端发来了 2 个证书。第二个证书是第一个证书的签发机构（CA）的证书。

- 客户端使用证书的认证机构 CA 公开发布的 RSA 公钥对该证书进行验证。

- 验证通过之后，浏览器和服务器通过密钥交换算法产生共享的对称密钥。

- 开始传输数据，使用同一个对称密钥来加解密。

HTTP与HTTS区别如下：

1. HTTP 是超文本传输协议，信息是明文传输；HTTPS 则是具有安全性的 ssl 加密传输协议。
2. HTTP 和 HTTPS 用的端口不一样，HTTP 端口是 80，HTTPS 是 443。
3. HTTPS 协议需要到 CA 机构申请证书，一般需要一定的费用。
4. HTTP 运行在 TCP 协议之上；HTTPS 运行在 SSL 协议之上，SSL 运行在 TCP 协议之上。

## 1.3 DNS域名系统

DNS (域名系统)：端口号53，用于解析DNS。

DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。

域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。

![](D:\Java\笔记\图片\5-13【网络模型-应用层】\4-1.jpg)

DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：

- 如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。
- 区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。

## 1.4 FTP文件传送协议

FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：

- 控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。
- 数据连接：用来传送一个文件数据。

根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：

- 主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0\~1023 是熟知端口号。

  ![](D:\Java\笔记\图片\5-13【网络模型-应用层】\4-2.jpg)

- 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。

  ![](D:\Java\笔记\图片\5-13【网络模型-应用层】\4-3.jpg)

主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。

filezilla使用的就是FTP协议来传输文件。

## 1.5 DHCP动态主机配置协议

DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。

DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。

DHCP 工作过程如下：

1. 客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。

2. DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。

3. 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。

4. DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。

   ![](D:\Java\笔记\图片\5-13【网络模型-应用层】\5-1.jpg)

## 1.6 TELNET远程登录协议

TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。

TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。

## 1.7 电子邮件协议

一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。

邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。

![](D:\Java\笔记\图片\5-13【网络模型-应用层】\5-2.png)

### 1.7.1 SMTP

SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。

![](D:\Java\笔记\图片\5-13【网络模型-应用层】\5-3.png)

### 1.7.2 POP3

POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。

### 1.7.3 IMAP

IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。

## 1.8 Web 页面请求过程

### 1.8.1 DHCP 配置主机信息

- 假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。

- 主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。

- 该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。

- 该数据报则被放置在 MAC 帧中，将广播到与交换机连接的所有设备。

- 连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段被放入 IP 数据报中，最后放入 MAC 帧中。

- 该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。

- 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。

### 1.8.2 ARP 解析 MAC 地址

- 主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。

- 主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。

- 该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。

- 该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。

- DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。

- 主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。

- 网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。

### 1.8.3 DNS 解析域名

- 知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。

- 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。

- 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。

- 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。

- 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。

### 1.8.4 HTTP 请求页面

- 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。

- 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。

- HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。

- 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。

- HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。

- 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。