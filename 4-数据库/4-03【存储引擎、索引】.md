# 第一章 MySQL存储引擎

## 1.1 MySQL体系结构

![结构图](..\图片\4-01【MySQL】\10.png)


- 连接层

   最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于 TCP/IP的通信。

   主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。

- 服务层 

   第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。

   在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大， 这样在解决大量读操作的环境中能够很好的提升系统的性能。

- 引擎层 

   存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库中的索引是在存储引擎层实现的。

- 存储层

   数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询 日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。

和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。 这种架构可以根据业务的需求和实际需要选择合适的存储引擎。

## 1.2 存储引擎介绍

存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式 。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。我们可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎。默认的存储引擎是InnoDB。

简单来说，存储引擎就是指**表的类型以及表在计算机上的存储方式**。

```sql
CREATE TABLE 表名(
    字段1 字段1类型 [ COMMENT 字段1注释 ] ,
    ......
    字段n 字段n类型 [COMMENT 字段n注释 ]
) ENGINE = INNODB [ COMMENT 表注释 ] ;			-- 创建表的时候指定存储引擎
```

```sql
show engines;								-- 查询当前数据库支持的存储引擎
```

## 1.3 存储引擎分类

官网5.7版本支持的10种存储引擎：

- **InnoDB**：5.5.8版本后Mysql的默认数据库引擎，支持ACID事务，支持行级锁定。
- **MyISAM**： 拥有较高的插入，查询速度，但不支持事务。
- **Memory**：所有数据置于内存的存储引擎，拥有极高的插入，更新和查询效率。但是会占用和数据量成正比的内存空间。并且其内容会在Mysql重新启动时丢失。
- ....

## 1.4 InnoDB

`InnoDB`是一种兼顾高可靠性和高性能的通用存储引擎，在MySQL5.5之后，InnoDB是默认的MySQL存储引擎,默认使用B+TREE数据结构存储索引。

`InnoDB`的优势在于提供了良好的事务处理、崩溃修复能力和并发控制。缺点是读写效率较差，占用的数据空间相对较大。

特点：

- DML 操作遵循 ACID 模型，支持**事务**
- **行级锁**，提高并发访问性能
- 支持**外键**约束，保证数据的完整性和正确性

文件：

- xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。

参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间

知识点：

查看 Mysql 变量：
`show variables like 'innodb_file_per_table';`

从idb文件提取表结构数据：
（在cmd运行）
`ibd2sdi xxx.ibd`

InnoDB 逻辑存储结构：
![InnoDB逻辑存储结构](..\图片\4-01【MySQL】\11.png)

## 1.5 MyISAM

MyISAM 是 MySQL 早期的默认存储引擎。

特点：

- 不支持事务，不支持外键
- 支持表锁，不支持行锁
- 访问速度快

文件：

- xxx.sdi: 存储表结构信息
- xxx.MYD: 存储数据
- xxx.MYI: 存储索引

## 1.6 Memory

Memory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。

特点：

- 存放在内存中，速度快
- hash索引（默认）

文件：

- xxx.sdi: 存储表结构信息

## 1.7 存储引擎特点

| 特点         | InnoDB              | MyISAM | Memory |
| ------------ | ------------------- | ------ | ------ |
| 存储限制     | 64TB                | 有     | 有     |
| 事务安全     | 支持                | -      | -      |
| 锁机制       | 行锁                | 表锁   | 表锁   |
| B+tree索引   | 支持                | 支持   | 支持   |
| Hash索引     | -                   | -      | 支持   |
| 全文索引     | 支持（5.6版本之后） | 支持   | -      |
| 空间使用     | 高                  | 低     | N/A    |
| 内存使用     | 高                  | 低     | 中等   |
| 批量插入速度 | 低                  | 高     | 高     |
| 支持外键     | 支持                | -      | -      |

## 1.8 存储引擎的选择

在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。

- InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择
- MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。
- Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性

电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。

# 第二章 索引

索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构 上实现高级查找算法，这种数据结构就是索引。

- 优点：提高数据检索效率，降低数据库的IO成本。通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。

- 缺点：索引列也是要占用空间的。索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE


## 2.1 索引结构

MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：

| 索引结构            | 描述                                                         |
| ------------------- | ------------------------------------------------------------ |
| B+Tree              | 最常见的索引类型，大部分引擎都支持B+树索引                   |
| Hash                | 底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询 |
| R-Tree(空间索引)    | 空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 |
| Full-Text(全文索引) | 是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES |

上述是MySQL中所支持的所有的索引结构，接下来，我们再来看看不同的存储引擎对于索引结构的支持情况。

| 索引       | InnoDB        | MyISAM | Memory |
| ---------- | ------------- | ------ | ------ |
| B+Tree索引 | 支持          | 支持   | 支持   |
| Hash索引   | 不支持        | 不支持 | 支持   |
| R-Tree索引 | 不支持        | 支持   | 不支持 |
| Full-text  | 5.6版本后支持 | 支持   | 不支持 |

> 注意： 我们平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引。

### 2.1.1 二叉树

了解下二叉搜索树有助于我们理解B-树、B+树，二叉搜索树的特点是：

- 所有非叶子结点至多拥有两个儿子（Left和Right）；
- 所有结点存储一个关键字；
- 非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；

假如说MySQL的索引结构采用二叉树的数据结构，比较理想的结构是左边的二叉树，但是如果主键是顺序插入的，则会形成一个单向链表，结构就是右边的二叉树了：

![](..\图片\4-01【MySQL】\12-1.png)

二叉树用它来做索引有几个问题：

1. 如果索引数据很多，树的层次会很高（只有左右两个子节点），数据量大时查询还是会慢

2. 二叉树每个节点只存储一个记录，一次查询在树上找的时候花费磁盘IO次数较多

3. 顺序插入时，会形成一个链表，查询性能大大降低。

那么红黑树可不可以呢？红黑树是一颗自平衡二叉树，那这样即使是顺序插入数 据，最终形成的数据结构也是一颗平衡的二叉树,结构如下：

![](..\图片\4-01【MySQL】\12-2.png)

但是，即使如此，由于红黑树也是一颗二叉树，所以也会存在一个缺点： 大数据量情况下，层级较深，检索速度慢。

在MySQL的索引结构中，并没有选择二叉树或者红黑树，而选择的是B+Tree，那么什么是 B+Tree呢？在详解B+Tree之前，先来介绍一个B-Tree。

### 2.1.2 B-Tree

B-tree树即B树，B即Balanced，平衡的意思。因为B树的原英文名称为B-tree，而国内很多人喜欢把B-tree译作B-树，其实，这是个非常不好的直译，很容易让人产生误解。事实上，B-tree就是指的B树。

B-Tree，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。 以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5 个指针：

![](..\图片\4-01【MySQL】\12-3.png)

> 树的度数指的是一个节点的子节点个数。
>
> 演示地址：https://www.cs.usfca.edu/~galles/visualization/BTree.html

特点： 

- 5阶的B树，每一个节点最多存储4个key，对应5个指针。
-  一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。 
- 在B树中，非叶子节点和叶子节点都会存放数据。

### 2.1.3 B+Tree

B-Tree，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。

以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5个指针：

![](..\图片\4-01【MySQL】\12-4.png)

我们可以看到：索引部分，仅仅起到索引数据的作用，不存储数据。数据存储部分，在其叶子节点中要存储具体的数据。

最终我们看到，B+Tree 与 B-Tree相比，主要有以下三点区别： 

- 所有的数据都会出现在叶子节点。 
- 叶子节点形成一个单向链表。 
- 非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。

上述我们所看到的结构是标准的B+Tree的数据结构，接下来，我们再来看看MySQL中优化之后的 B+Tree。

MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。

![](..\图片\4-01【MySQL】\12-5.png)

### 2.1.4 Hash

MySQL中除了支持B+Tree索引，还支持一种索引类型---Hash索引。

哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。

![](..\图片\4-01【MySQL】\12-6.png)

特点：

- Hash索引只能用于对等比较（=、in），不支持范围查询（betwwn、>、<、...）
- 无法利用索引完成排序操作
- 查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引

在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有自适应hash功能，hash索引是 InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的

### 2.1.5 面试题

**为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？**

- **B+ 树的磁盘读写代价更低**

  B+ 树的数据都集中在叶子节点，分支节点只负责指针（索引）；B 树的分支节点既有指针也有数据 。这将导致B+ 树的层高会小于B 树的层高，也就是说B+ 树平均的Io次数会小于B 树。

- **B+ 树的查询效率更加稳定**

  B+ 树的数据都存放在叶子节点，故任何关键字的查找必须走一条从根节点到叶子节点的路径。所有关键字的查询路径相同，每个数据查询效率相当。

- **B+树更便于遍历**

  由于B+树的数据都存储在叶子结点中，分支结点均为索引，遍历只需要扫描一遍叶子节点即可；B树因为其分支结点同样存储着数据，要找到具体的数据，需要进行一次中序遍历按序来搜索。

- **B+树更擅长范围查询**

  B+树叶子节点存放数据，数据是按顺序放置的双向链表。B树范围查询只能中序遍历。Hash索引不支持范围匹配和排序操作。

- **B+ 树占用内存空间小**

  B+ 树索引节点没有数据，比较小。在内存有限的情况下，相比于B树索引可以加载更多B+ 树索引。 



**Hash 索引的限制和弊端**

Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B+Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B+Tree 索引。

可能很多人又有疑问了，既然 Hash 索引的效率要比 B+Tree 高很多，为什么大家不都用 Hash 索引而还要使用 B+Tree 索引呢？任何事物都是有两面性的，Hash 索引也一样，虽然 Hash 索引效率高，但是 Hash 索引本身由于其特殊性也带来了很多限制和弊端，主要有以下这些。

- **Hash 索引仅仅能满足”=”,”IN”和”<=>”查询，不能使用范围查询。**由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。

- **Hash 索引无法被用来避免数据的排序操作。**由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；

- **Hash 索引不能利用部分索引键查询。**对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。

- **Hash 索引在任何时候都不能避免表扫描。**前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。

- **Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B+Tree索引高。**对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下

简单地说，哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。



**B+树索引和哈希索引的区别**

- 如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据;
- 如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；
- 同理，哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；
- 哈希索引也不支持多列联合索引的最左匹配规则；
- B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。



 **InnoDB不使用哈希索引**

说说 MySQL 的索引

* 我：索引是存储引擎层的问题，要看存储引擎，常用的有 MyISAM 和 InnoDB。

两者索引结构都是 B+ 树，但InnoDB 是聚集索引，叶子节点既存数据也存储 key，查找数据需要先查找二级索引，得到主键然后在到聚集索引中查找，需要二次查找。MyISAM 是非聚集索引，叶子节点只存储 key，只需一次查表，因此 MyISAM 适合于读密集的场景，InnoDB 则具有很多额外的特性，如行级锁，事务等，InnoDB 适合写密集的场景

面试官：为啥用 B+ 树

* 我：索引结构还有其他的很多，如 hash，红黑树，B 树

* 不用 hash 是因为冲突和不适合排序和分组查询

* 不用红黑树，是因为它是二叉树，高度高，因为不可能把整个表装入内存，只能从根节点一直到叶子节点一个一个转入，需要的 IO 次数太多

* 不用 B 树是因为，B 树的内部节点也存储数据，且 B 树的叶子节点相互福利，相比 B+ 树的排序和分组查询差一些，由于内部节点也存储数据，B 树更适合单值查询更多的数据库，比如非关系型数据库，我了解到 MongoDB 就是用的 B 树，B+ 树则更适合关系型数据库。

## 2.2 索引分类

在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。

| 分类     | 含义                                                 | 特点                     | 关键字   |
| -------- | ---------------------------------------------------- | ------------------------ | -------- |
| 主键索引 | 针对于表中主键创建的索引                             | 默认自动创建，只能有一个 | PRIMARY  |
| 唯一索引 | 避免同一个表中某数据列中的值重复                     | 可以有多个               | UNIQUE   |
| 常规索引 | 快速定位特定数据                                     | 可以有多个               |          |
| 全文索引 | 全文索引查找的是文本中的关键词，而不是比较索引中的值 | 可以有多个               | FULLTEXT |

在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：

| 分类                      | 含义                                                       | 特点                 |
| ------------------------- | ---------------------------------------------------------- | -------------------- |
| 聚集索引(Clustered Index) | 将数据存储与索引放一块，索引结构的叶子节点保存了行数据     | 必须有，而且只有一个 |
| 二级索引(Secondary Index) | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 | 可以存在多个         |

聚集索引选取规则: 

* 如果存在主键，主键索引就是聚集索引。
* 如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。 
* 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。

聚集索引和二级索引的具体结构如下：

![](..\图片\4-01【MySQL】\12-7.png)

聚集索引的叶子节点下面存储的是这一行的数据。而二级索引下面存储的是对应的ID。

我们来看一下这条语句在MySQL中的查询流程：`select * from user where name = 'Arm';`首先在二级索引里面查找到Arm，然后就可以得到ID。最后根据ID就可以查出来这一行数据了。这叫做回表查询，步骤如下：

![演示图](https://dhc.pythonanywhere.com/media/editor/演示图_20220319215403721066.png "演示图")



**以下 SQL 语句，哪个执行效率高？为什么？**

```sql
select * from user where id = 10;
select * from user where name = 'Arm';
-- 备注：id为主键，name字段创建的有索引
```

答：第一条语句，因为第二条需要回表查询，相当于两个步骤。



**InnoDB 主键索引的 B+Tree 高度为多少？**

![](..\图片\4-01【MySQL】\12-5.png)

答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.
可得公式：`n * 8 + (n + 1) * 6 = 16 * 1024`，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。

如果树的高度为2，那么他能存储的数据量大概为：`1171 * 16 = 18736`；
如果树的高度为3，那么他能存储的数据量大概为：`1171 * 1171 * 16 = 21939856`。

另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。

## 2.3 索引语法

```sql
-- 创建索引 如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引
CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);

-- 创建索引的名称index_name的规范：idx_表名_字段名
create index idx_user_name on tb_user(name);
```

```sql
SHOW INDEX FROM table_name;		-- 查看索引
```

```sql
DROP INDEX index_name ON table_name;		-- 删除索引
```

## 2.4 性能分析

### 2.4.1 查看执行频次

MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：

```sql
-- session 是查看当前会话 ;
-- global 是查询全局数据 ;
SHOW GLOBAL STATUS LIKE 'Com_______';		-- 一共有7个下划线，com_______也可以
```

通过上述指令，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据 库优化提供参考依据。 如果是以增删改为主，我们可以考虑不对其进行索引的优化。 如果是以查询为主，那么就要考虑对数据库的索引进行优化了。

### 2.4.2 慢查询日志

慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。

MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件`/etc/my.cnf`中配置如下信息：

```sh
# 开启慢查询日志开关
slow_query_log=1
# 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
long_query_time=2
```

更改后记得重启MySQL服务，查看慢日志文件中记录的信息：`/var/lib/mysql/localhost-slow.log`

查看慢查询日志开关状态：`show variables like 'slow_query_log';`

### 2.4.3 profile文件

show profiles 能在做SQL优化时帮我们了解时间都耗费在哪里。通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：

```sql
SELECT @@have_profiling;
```

```sh
+------------------+
| @@have_profiling |
+------------------+
| YES              |
+------------------+
```

可以看到，当前MySQL是支持 profile操作的，但是开关是关闭的。可以通过set语句在 session/global级别开启profiling：

```sql
SET profiling = 1;
```

```sql
show profiles;							-- 查看所有语句的耗时
show profile for query query_id;			-- 查看指定query_id的SQL语句各个阶段的耗时 
show profile cpu for query query_id;		-- 查看指定query_id的SQL语句CPU的使用情况
```

### 2.4.5 explain

EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行 过程中表如何连接和连接的顺序。

```sql
-- 直接在select语句之前加上关键字 explain / desc
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;
```

![](..\图片\4-01【MySQL】\12-8.png)

Explain 执行计划中各个字段的含义：

- `id`：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行）
- `select_type`：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等
- `type`：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all，尽量将性能提升到const就可以了。
- `possible_key`：可能应用在这张表上的索引，一个或多个
- `Key`：实际使用的索引，如果为 NULL，则没有使用索引
- `Key_len`：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好
- `rows`：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的
- `filtered`：表示返回结果的行数占需读取行数的百分比，filtered**的值越大越好**

## 2.5 索引使用规则

### 2.5.1 最左前缀法则

如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效（后面的字段索引失效）。

注意 ： 最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是 第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。

* 创建一个表tb_user，包含的字段如下：

  ```sql
  +------------+------------------+------+-----+---------+----------------+
  | Field      | Type             | Null | Key | Default | Extra          |
  +------------+------------------+------+-----+---------+----------------+
  | id         | int              | NO   | PRI | NULL    | auto_increment |
  | name       | varchar(50)      | NO   | MUL | NULL    |                |
  | phone      | varchar(11)      | NO   | UNI | NULL    |                |
  | email      | varchar(100)     | YES  |     | NULL    |                |
  | profession | varchar(11)      | YES  | MUL | NULL    |                |
  | age        | tinyint unsigned | YES  |     | NULL    |                |
  | gender     | char(1)          | YES  |     | NULL    |                |
  | status     | char(1)          | YES  |     | NULL    |                |
  | createtime | datetime         | YES  |     | NULL    |                |
  +------------+------------------+------+-----+---------+----------------+
  ```

* 给字段profession，age，status添加索引：

  ```sql
  create index idx_user_pro_age_sta on tb_user(profession, age, status);		-- 添加索引
  ```

  ```sql
  show index from tb_user;			-- 查看索引
  ```

* 根据索引来查询，测试

  ```sql
  explain select * from tb_user where profession = '软件工程' and age = 31 and status = '0';
  
  +----------------------+----------------------+---------+
  | possible_keys        | key                  | key_len |	-- 预计使用索引：idx_user_pro_age_sta
  +----------------------+----------------------+---------+	-- 使用索引：idx_user_pro_age_sta
  | idx_user_pro_age_sta | idx_user_pro_age_sta | 54      |	-- 索引长度：54
  +----------------------+----------------------+---------+
  ```

  ```sql
  explain select * from tb_user where profession = '软件工程' and age = 31; -- 跳过某一列 索引部分失效
  
  +----------------------+----------------------+---------+	    
  | possible_keys        | key                  | key_len |	-- 预计使用索引：idx_user_pro_age_sta 
  +----------------------+----------------------+---------+	-- 使用索引：idx_user_pro_age_sta
  | idx_user_pro_age_sta | idx_user_pro_age_sta | 49      |	-- 索引长度：49
  +----------------------+----------------------+---------+
  ```

  ```sql
  explain select * from tb_user where profession = '软件工程';   -- 跳过某一列，索引部分失效
  
  +----------------------+----------------------+---------+
  | possible_keys        | key                  | key_len |	-- 预计使用索引：idx_user_pro_age_sta
  +----------------------+----------------------+---------+	-- 使用索引：idx_user_pro_age_sta
  | idx_user_pro_age_sta | idx_user_pro_age_sta | 47      |	-- 索引长度：47
  +----------------------+----------------------+---------+
  ```

  ```sql
  explain select * from tb_user where age = 31 and status = '0';	-- 没有最左索引，因此索引失效
  
  +---------------+------+---------+
  | possible_keys | key  | key_len |			-- 预计使用索引：NULL
  +---------------+------+---------+			-- 使用索引：NULL
  | NULL          | NULL | NULL    |			-- 索引长度：NULL
  +---------------+------+---------+
  ```

  ```sql
  -- 查询顺序于索引顺序不容，当然没有任何问题，依然使用索引查询。
  explain select * from tb_user where age = 31 and status = '0' and profession = "软件工程";
  
  +----------------------+----------------------+---------+
  | possible_keys        | key                  | key_len |	-- 预计使用索引：idx_user_pro_age_sta
  +----------------------+----------------------+---------+	-- 使用索引：idx_user_pro_age_sta
  | idx_user_pro_age_sta | idx_user_pro_age_sta | 54      |	-- 索引长度：54
  +----------------------+----------------------+---------+
  ```

联合索引中，出现范围查询（<, >），范围查询右侧的列索引失效。可以用>=或者<=来规避索引失效问题。

### 2.5.2 索引失效情况

在索引列上进行运算操作，索引将失效。

```sql
-- 对phone字段添加一个唯一索引，然后查询后两位为15的phone。这样会导致索引失效，因为用到了函数
explain select * from tb_user where substring(phone, 10, 2) = '15';		
```



字符串类型字段使用时，不加引号，索引将失效。

```sql
-- 索引失效 phone字段是varchar(11)，可是并没有加上引号。因此索引失效
explain select * from tb_user where phone = 17799990015;
```



模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。

```sql
-- 模糊查询，头部模糊查询，索引失效
explain select * from tb_user where profession like '%工程';
```



用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。

```sql
-- phone有索引，但是age没有索引 所以不走索引。全表扫描
explain select * from tb_user where phone = '17799990017' or age = 23;
```



数据分步影响：如果 MySQL 评估使用索引比全表更慢，则不使用索引。

### 2.5.3 SQL 提示

有时候我们查询一个字段，但是与该字段相关联的索引有多个，这个时候我们就需要来指定索引了。

SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。

```sql
-- 为profession创建一个联合索引及单列索引
explain select * from tb_user where profession = "软件工程";

-- 可能用到的索引有两个：idx_user_pro_age_sta, idx_user_pro
-- 实际用到的索引为 idx_user_pro_age_sta 联合索引
+------+-----------------------------------+----------------------+
| type | possible_keys                     | key                  |	
+------+-----------------------------------+----------------------+	
| ref  | idx_user_pro_age_sta,idx_user_pro | idx_user_pro_age_sta |
+------+-----------------------------------+----------------------+
```

这时候我们可以利用SQL提示来指定使用的索引了：

```sql
-- 建议使用该索引
explain select * from tb_user use index(idx_user_pro) where profession="软件工程";
```

```sql
-- 不使用该索引
explain select * from tb_user ignore index(idx_user_pro) where profession="软件工程";
```

```sql
-- 必须使用该索引
explain select * from tb_user force index(idx_user_pro) where profession="软件工程";
```

### 2.5.4 覆盖索引

覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。尽量使用覆盖索引，减少`select *`。 

```sql
-- 之前已经为profession age status创建了联合索引了
explain select id, profession, age, status from tb_user where profession = "软件工程" and age = 31 and status = '0';

-- using where; using index; 查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询
+--------------------------+
| Extra                    |
+--------------------------+
| Using where; Using index |
+--------------------------+
```

```sql
-- 查询的字段比上面多了一个status，联合索引里面并没有status
explain select id, profession, age, status, gender from tb_user where profession = "软件工程" and age = 31 and status = '0'; 

-- using index condition 查找使用了索引，但是需要回表查询数据
+-----------------------+
| Extra                 |
+-----------------------+
| Using index condition |
+-----------------------+
```

在tb_user表中有一个联合索引 `idx_user_pro_age_sta`，该索引关联了三个字段 `profession`、`age`、`status`，而这个索引也是一个二级索引，所以叶子节点下面挂的是这一行的主键id。 所以当我们查询返回的数据在 `id`、`profession`、`age`、`status` 之中，则直接走二级索引直接返回数据了。

 如果超出这个范围，就需要拿到主键id，再去扫描聚集索引，再获取额外的数据了，这个过程就是回表。 而我们如果一直使用`select *` 查询返回所有字段值，很容易就会造成回表查询（除非是根据主键查询，此时只会扫描聚集索引）。

> 面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：
> `select id, username, password from tb_user where username='itcast';`
>
> 解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引

### 2.5.5 前缀索引

当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。

```sql
create index idx_xxxx on table_name(columnn(n));			-- 前缀索引语法
```

前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

```mysql
select count(distinct email) / count(*) from tb_user;
select count(distinct substring(email, 1, 5)) / count(*) from tb_user;
```

show index 里面的sub_part可以看到截取的长度

```sql
 create index idx_user_email_5 on tb_user(email(5));		-- 创建email字段的前缀索引 长度为5
 
 show index from tb_user \G;							-- 查看所有索引

*************************** 7. row ***************************	-- 第7个索引
        Table: tb_user
   Non_unique: 1
     Key_name: idx_user_email_5
 Seq_in_index: 1
  Column_name: email
    Collation: A
  Cardinality: 23
     Sub_part: 5		-- 索引截取长度
       Packed: NULL
         Null: YES
   Index_type: BTREE
      Comment: 
Index_comment: 
      Visible: YES
   Expression: NULL
```

![](..\图片\4-01【MySQL】\12-9.png)

### 2.5.6 单列索引&联合索引

单列索引：即一个索引只包含单个列

联合索引：即一个索引包含了多个列

在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。

```sql
-- 在tb_user表里面存在着phone和name的单列索引
explain select * from tb_user where phone = "17799990010" and name = "韩信";

-- 预计使用到的索引：idx_user_pho，idx_user_name
-- 使用到的索引：idx_user_pho
+----------------------------+--------------+
| possible_keys              | key          |
+----------------------------+--------------+
| idx_user_pho,idx_user_name | idx_user_pho |
+----------------------------+--------------+
```

多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询

在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。

## 2.6 设计原则

1. 针对于数据量较大，且查询比较频繁的表建立索引
2. 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引
3. 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高
4. 如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引
5. 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率
6. 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率
7. 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。
