# 第一章 JSP入门

<!--已经过时 但是大学学习的-->

JSP：`Java Server Pages`：是一个Java服务器端页面。

可以理解为：一个特殊的页面，在这里页面里面我们可以定义HTML标签，也可以定义Java代码。jsp是一个后缀，我们创建一个Web项目，里面就带着一个jsp页面。

JSP有一个特别大的好处，就是可以简化书写。我们可以在里面定义HTML标签，也可以定义Java代码。所以很方便。

![](D:\Java\笔记\图片\2-15【JSP】\2JSP.png)

本质上，JSP就是一个Servlet。

当我们在`index.jsp`书写代码，服务器启动，浏览器访问。那么会将`index.jsp`转为`index.java`，再转为`index.class`。

我们可以查看一下：当服务器运行，会在`C:\Users\林轩\AppData\Local\JetBrains\IntelliJIdea2021.2\tomcat\3e20fe4c-cdaf-436f-8e70-1d6bfe2452e7`产生work工作空间。在里面可以找到`index.java`和`index.class`。我们打开可以发现继承了`org.apache.jasper.runtime.HttpJspBase`。

打开Tomcat源码可以发现`HttpJspBase`继承了`HttpServlet`。所以说`jsp`本质上就是一个`Servlet`。

```jsp
<!--第一个程序-->
<%@ page contentType="text/html;charset=UTF-8" language="java" pageEncoding="utf-8" %>
<html>
    <head>
        <title>第一个 JSP 程序</title>
    </head>
    <body>
        <%
        	out.println("Hello World！");
        %>
    </body>
</html>
```

## 1.1 Eclipse JSP

![](D:\Java\笔记\图片\2-15【JSP】\1.png)

上图中各个目录解析：

- deployment descriptor：部署的描述。
- Web App Libraries：自己加的包可以放在里面。这里没有显示出来，应该在Java Resources下面的Libraries目录下。
- build：放入编译之后的文件。
- WebContent:放进写入的页面。

## 1.2 JSP基础语法

所谓JSP脚本就是JSP定义Java代码的方式

1. `<% 代码 %>`：JSP脚本程序。定义的`Java`代码，在`Service`方法中。`Service`方法中可以定义什么，那么在这个脚本中就可以定义什么。脚本程序可以包含任意量的Java语句、变量、方法或表达式。

   ```jsp
   <%
   	out.println("Your IP address is " + request.getRemoteAddr());
   %>
   ```
2. `<%! 代码 %>`：JSP声明。定义的`Java`代码，在`JSP`转换后的`Java`类的成员位置。一个声明语句可以声明一个或多个变量、方法，供后面的Java代码使用。

   ```jsp
   <%! int i = 0; %> 
   <%! int a, b, c; %> 
   ```
3. `<%= 代码 %>`：JSP表达式。定义的`Java`代码，会输出到页面上面。输出语句中可以定义什么，那么脚本中就可以定义什么。一个JSP表达式中包含的脚本语言表达式，先被转化成String，然后插入到表达式出现的地方。

   ```jsp
   <p>
      今天的日期是: <%= (new java.util.Date()).toLocaleString()%>
   </p>
   ```

## 1.3 JSP注释

| **语法**         | 描述                                                 |
| :--------------- | :--------------------------------------------------- |
| `<%-- 注释 --%>` | JSP注释，注释内容不会被发送至浏览器甚至不会被编译    |
| `<!-- 注释 -->`  | HTML注释，通过浏览器查看网页源代码时可以看见注释内容 |
| `<\%`            | 代表静态 <%常量                                      |
| `%\>`            | 代表静态 %> 常量                                     |
| `\'`             | 在属性中使用的单引号                                 |
| `\"`             | 在属性中使用的双引号                                 |

## 1.3 JSP 生命周期

JSP生命周期就是从创建到销毁的整个过程，类似于servlet生命周期，区别在于JSP生命周期还包括将JSP文件编译成servlet。

以下是JSP生命周期中所走过的几个阶段：

- **编译阶段：**

  servlet容器编译servlet源文件，生成servlet类

- **初始化阶段：**

  加载与JSP对应的servlet类，创建其实例，并调用它的初始化方法

- **执行阶段：**

  调用与JSP对应的servlet实例的服务方法

- **销毁阶段：**

  调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例

------

**JSP编译**

当浏览器请求JSP页面时，JSP引擎会首先去检查是否需要编译这个文件。如果这个文件没有被编译过，或者在上次编译后被更改过，则编译这个JSP文件。

编译的过程包括三个步骤：

- 解析JSP文件。
- 将JSP文件转为servlet。
- 编译servlet。

------

**JSP初始化**

容器载入JSP文件后，它会在为请求提供任何服务前调用jspInit()方法。如果您需要执行自定义的JSP初始化任务，复写jspInit()方法就行了，就像下面这样：

```java
public void jspInit(){
  // 初始化代码
}
```

一般来讲程序只初始化一次，servlet也是如此。通常情况下可以在jspInit()方法中初始化数据库连接、打开文件和创建查询表。

------

**JSP执行**

这一阶段描述了JSP生命周期中一切与请求相关的交互行为，直到被销毁。

当JSP网页完成初始化后，JSP引擎将会调用_jspService()方法。

`_jspService()`方法需要一个HttpServletRequest对象和一个HttpServletResponse对象作为它的参数，就像下面这样：

```java
void _jspService(HttpServletRequest request, HttpServletResponse response)
{
   // 服务端处理代码
}
```

`_jspService()`方法在每个request中被调用一次并且负责产生与之相对应的response，并且它还负责产生所有7个HTTP方法的回应，比如GET、POST、DELETE等等。

------

**JSP清理**

JSP生命周期的销毁阶段描述了当一个JSP网页从容器中被移除时所发生的一切。

`jspDestroy()`方法在JSP中等价于servlet中的销毁方法。当需要执行任何清理工作时复写`jspDestroy()`方法，比如释放数据库连接或者关闭文件夹等等。

jspDestroy()方法的格式如下：

```java
public void jspDestroy()
{
   // 清理代码
}
```

------

JSP生命周期示例：

JSP生命周期代码实例如下所示：

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<html>
<head>
<title>life.jsp</title>
</head>
<body>

<%! 
  private int initVar = 0;
  private int serviceVar = 0;
  private int destroyVar = 0;
%>
  
<%!
  public void jspInit(){
    initVar++;
    System.out.println("jspInit(): JSP被初始化了"+initVar+"次");
  }
  public void jspDestroy(){
    destroyVar++;
    System.out.println("jspDestroy(): JSP被销毁了"+destroyVar+"次");
  }
%>

<%
  serviceVar++;
  System.out.println("_jspService(): JSP共响应了"+serviceVar+"次请求");

  String content1="初始化次数 : "+initVar;
  String content2="响应客户请求次数 : "+serviceVar;
  String content3="销毁次数 : "+destroyVar;
%>
<h1>菜鸟教程 JSP 测试实例</h1>
<p><%=content1 %></p>
<p><%=content2 %></p>
<p><%=content3 %></p>

</body>
</html>
```



## １.4 JSP的内置对象

在JSP中我们不需要获取和创建对象，可以直接使用对象。JSP一共有着9个内置对象。今天只学习3个：

* `resquest`

* `response`

* `out`：字符流输出对象。可以将数据输出到页面上面。和`response.getWriter()`类似。

  二者不同之处：`response.getWriter()`方法不论在哪里，数据输出永远在`out.write()`之前。

  这是因为：在`Tomcat`服务器真正给客户端做出响应之前，会先找到`response`缓冲区数据。



# 第一章 JSP进阶

<!--P763-->

## 1.1 指令

JSP指令：用于配置JSP页面，导入资源文件。

格式：`<%@ 指令名称 属性名1=属性值1 属性名2=属性值2...%>`

​			`<%@ page contentType="text/html;charset=UTF-8" language="java" %>`

​			上面的Page就是一个指令名称。除了page还有几种指令名称。

指令名称分类

* page：配置JSP页面
* include：页面包含的。导入页面的资源文件。
* taglib：导入资源

### page指令名称

<!--P764 3.19-->

page指令名称作用： 配置JSP页面的

它的属性名称分类如下：

* **contentType**：等同于response.setContentType()。设置响应体的mime类型以及字符集；设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集）

  例如：`contentType="text/html;charset=UTF-8"`

* **pageEncoding**：设置当前页面的字符集

  例如：`pageEncoding="GBK"`

* **language**：设置语言

  例如：`language="java"`

* **import**：导包的，java代码如果需要导包，那么就会在这个里面进行导包

  例如：`import="java.util.List"`

* **buffer**：缓冲区的大小，默认是8kb

  例如：`buffer="16kb"`

* **errorPage**：当前页面发生异常后，会自动跳转到指定的错误页面

  例如：`errorPage="500.jsp"`在当前页面造一个数学异常，然后就会报错，浏览器显示错误。但是显示的错误不好看，泄露源码了。那么我们可以让它自动跳转到指定的错误页面。

* **isErrorPage**：标识当前也是是否是错误页面。

  * true：是，可以使用内置对象exception
  * false：否。默认值。不可以使用内置对象exception

### include指令名称

<!--P765-->

include	： 页面包含的。导入其他页面的资源文件。因为有很多代码都会重复，所以我们可以定义一个jsp页面，然后统一导入即可。

```jsp
<%@include file="top.jsp"%>
```

### taglib指令名称

taglib	： 导入资源，导入标签库。

我们在IDEA里面创建WEB-INF文件夹，在WEB-INF下面创建lib文件夹。导入一些JSTL标签jar包。`javax.servlet.jsp.jstl.jar` `jstl-impl.jar`

然后键入下面的代码，就导入jstl的标签库了。

```jsp
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
```

* prefix：前缀，自定义的，我们想定义成什么就定义什么。当然，大家都有一些约定俗称的规则。JSTL就是c。

## 1.2 注释

<!--P766-->

1. html注释：
   `<!-- -->`:只能注释html代码片段

2. jsp注释：推荐使用
   `<%-- --%>`：可以注释所有的代码片段

3. Java注释：在JSP的`<%%>`区域内部可以使用注释

   `//` `/**/`

## 1.3 内置对象

<!--P767-->

内置对象：**在jsp页面中不需要创建，直接使用的对象**。

|   变量名    |      真实类型       |                     作用                     |
| :---------: | :-----------------: | :------------------------------------------: |
| pageContext |     PageContext     | 当前页面共享数据，还可以获取其他八个内置对象 |
|   request   | HttpServletRequest  |         一次请求访问的多个资源(转发)         |
|   session   |     HttpSession     |             一次会话的多个请求间             |
| application |   ServletContext    |              所有用户间共享数据              |
|  response   | HttpServletResponse |                   响应对象                   |
|    page     |       Object        |        当前页面(Servlet)的对象  this         |
|     out     |      JspWriter      |          输出对象，数据输出到页面上          |
|   config    |    ServletConfig    |              Servlet的配置对象               |
|  exception  |      Throwable      |                   异常对象                   |

### pageContext

pageContext：当前页面共享数据，还可以获取其他八个内置对象，里面配置了一些方法来获取其他八个对象。

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
  <head>
    <title>$Title$</title>
  </head>
  <body>
    <%
      pageContext.setAttribute("msg", "林炫你好");
    %>

    <%=pageContext.getAttribute("msg")%>
  </body>
</html>

<!-- 会在页面输出林炫你好 -->
```

# 





# 第四章 JSTL标签

## 4.1 基本概述

<!--P776-->

JSTL标签概念：JavaServer Pages Tag Library  JSP标准标签库

* **是由Apache组织提供的开源的免费的jsp标签**

1. 作用：用于简化和替换jsp页面上的java代码		
2. 使用步骤：
  3. 导入jstl相关jar包
  4. 引入标签库：taglib指令：  `<%@ taglib %>`
  5. 使用标签

## 4.2 常用的JSTL标签

### if标签

<!--P777-->

**if标签相当于java代码的if语句**

if标签里面有着一个test属性，该属性必须添加，否则报错，该属性接受boolean表达式

* 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容

  ```jsp
  <%@ page contentType="text/html;charset=UTF-8" language="java" %>
  <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
  <html>
  <head>
      <title>Title</title>
  </head>
  <body>
      <c:if test="true">
          <h1>你好</h1>
      </c:if>
  </body>
  </html>
  
  <!--
  	显示：
  		你好
  -->
  ```

* 一般情况下，test属性值会结合el表达式一起使用

  ```jsp
  <%@ page import="java.util.List" %>
  <%@ page import="java.util.ArrayList" %>
  <%@ page contentType="text/html;charset=UTF-8" language="java" %>
  <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
  <html>
  <head>
      <title>Title</title>
  </head>
  <body>
      <%
          List<Integer> list = new ArrayList<>();
          list.add(1);
          request.setAttribute("list", list);
      %>
  
      <!--判断是否为空-->
      <c:if test="${not empty list}">
          <h2>不为空</h2>
      </c:if>
  
  </body>
  </html>
  
  <!--
  	显示：
  		不为空
  -->
  ```

> 注意：c:if标签没有else情况，如果我们想要else情况，那么可以再定义一个c:if标签

### choose标签

<!--P778-->

**choose标签相当于java代码的switch语句**

* 使用choose标签声明 == 相当于switch声明
* 使用when标签做判断 == 相当于case
* 使用otherwise标签做其他情况的声明 == 相当于default

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <%
        // 存储信息
        request.setAttribute("number", 1);
    %>

    <c:choose>
        <c:when test="${number == 1}">星期一</c:when>
        <c:when test="${number == 2}">星期二</c:when>
        <c:when test="${number == 3}">星期三</c:when>
        <c:when test="${number == 4}">星期四</c:when>
        <c:when test="${number == 5}">星期五</c:when>
        <c:when test="${number == 6}">星期六</c:when>
        <c:when test="${number == 7}">星期天</c:when>

        <c:otherwise>数字输入有误</c:otherwise>
    </c:choose>
</body>
</html>

<!--
	显示：
		星期一
-->
```

### foreach标签

<!--P779-->

**foreach标签相当于java代码的for语句**

对于for循环，在Java中我们知道有两种，一种普通for循环，用于完成重复的操作；一种是增强for循环，会直接遍历容器。

同样的，在JSTL里面对于for循环也有两种，他们都叫做foreach。只是属性不同而已。

* 普通的for循环属性如下：

  1. begin：开始值
  2. end：结束值
  3. var：临时变量
  4. setp：步长

  ```jsp
  <%@ page contentType="text/html;charset=UTF-8" language="java" %>
  <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
  <html>
  <head>
      <title>Title</title>
  </head>
  <body>
  
      <c:forEach begin="1" end="10" var="i" step="1">
          ${i} <br>
      </c:forEach>
  </body>
  </html>
  
  <!--
  	显示：
  		1
          2
          3
          4
          5
          6
          7
          8
          9
          10
  -->
  ```

* 增强for循环属性如下：

  1. items：容器对象
  2. var：容器中元素的临时变量
  3. varStatus：循环状态对象
     * index：容器中元素的索引，从0开始
     * count：循环次数，从1开始

  ```jsp
  <%@ page import="java.util.List" %>
  <%@ page import="java.util.ArrayList" %>
  <%@ page contentType="text/html;charset=UTF-8" language="java" %>
  <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
  <html>
  <head>
      <title>Title</title>
  </head>
  <body>
  
      <%
          List<String> list = new ArrayList<>();
          list.add("aaa");
          list.add("bbb");
          list.add("ccc");
          request.setAttribute("list", list);
      %>
  
      <c:forEach items="${list}" var="str" varStatus="s">
          ${str} ${s.index} ${s.count} <br>
      </c:forEach>
  </body>
  </html>
  
  <!--
  	显示：
          aaa 0 1
          bbb 1 2
          ccc 2 3
  -->
  ```

## 4.3 练习

<!--P780-->

* 需求：在request域中有一个存有User对象的List集合。需要使用jstl+el将list集合数据展示到jsp页面的表格table中

```jsp
<%@ page import="java.util.List" %>
<%@ page import="cn.com.demo01.User" %>
<%@ page import="java.util.ArrayList" %>
<%@ page import="java.util.Date" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <%
        List<User> list = new ArrayList<>();
        list.add(new User("张三", 24, new Date()));
        list.add(new User("李四", 35, new Date()));
        list.add(new User("王五", 46, new Date()));
        request.setAttribute("list", list);
    %>

    <table border="1" align="center" width="500">
        <tr>
            <th>编号</th>
            <th>姓名</th>
            <th>年龄</th>
            <th>日期</th>
        </tr>

        <c:forEach items="${list}" var="user" varStatus="u">
            
            <!--弄一些颜色来搞的丰富一些-->
            <c:if test="${u.count % 2 == 0}">
                <tr bgcolor="aqua">
                    <td>${u.count}</td>
                    <td>${user.name}</td>
                    <td>${user.age}</td>
                    <td>${user.dateStr}</td>
                </tr>
            </c:if>

            <c:if test="${u.count % 2 != 0}">
                <tr bgcolor="red">
                    <td>${u.count}</td>
                    <td>${user.name}</td>
                    <td>${user.age}</td>
                    <td>${user.dateStr}</td>
                </tr>
            </c:if>
        </c:forEach>
    </table>
</body>
</html>

<!--
	显示：
        编号	姓名	年龄	日期
        1	张三	24	2022-03-21 11:31:09
        2	李四	35	2022-03-21 11:31:09
        3	王五	46	2022-03-21 11:31:09
-->
```

```java
package cn.com.demo01;

import java.text.SimpleDateFormat;
import java.util.Date;

public class User {
    private String name;
    private int age;
    private Date date;

    public User(String name, int age, Date date) {
        this.name = name;
        this.age = age;
        this.date = date;
    }

    public User() {
    }

    /**
     * 逻辑视图，非常常用的一种方式
     * @return
     */
    public String getDateStr() {
        if (date != null) {
            SimpleDateFormat sdf = new SimpleDateFormat("yyy-MM-dd HH:mm:ss");
            return sdf.format(date);
        } else {
            return "";
        }
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Date getDate() {
        return date;
    }

    public void setDate(Date date) {
        this.date = date;
    }
}

```

# 

# 第三章 EL表达式

## 3.1 基本概述

<!--P770-->

1. 概念：Expression Language 表达式语言

2. 作用：替换和简化jsp页面中java代码的编写

3. 语法：`${表达式}`，**不加分号**

   > 注意：
   >
   > jsp默认支持el表达式的。如果要忽略el表达式那么有两种方法：
   >
   > 1. 设置jsp中page指令中：`isELIgnored="true"` 忽略当前jsp页面中所有的el表达式
   > 2. `\${表达式}` ：忽略当前这个el表达式，反斜线相当于转义字符。

## 3.2 运算符

<!--P771-->

1. 算数运算符： `+ - * /(div) %(mod)`
2. 比较运算符： `> < >= <= == !=`
3. 逻辑运算符： `&&(and) ||(or) !(not)`
4. 空运算符： `empty`
   * 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0
   * `${empty list}`:判断字符串、集合、数组对象是否为null或者长度为0
   * `${not empty str}`:表示判断字符串、集合、数组对象是否不为null 并且 长度>0

## 3.3 获取值

<!--P772-->

注意：**el表达式只能从域对象中获取值**

获取值的语法一共有两种，如下：

1. `${域名称.键名}`：从指定域中获取指定键的值

   * 域名称：
     1. pageScope          --> pageContext
     2. requestScope     --> request
     3. sessionScope      --> session
     4. applicationScope --> application（ServletContext）
   * 举例：在request域中存储了name=张三
   * 获取：`${requestScope.name}`

   创建一个el01.jsp，在里面键入如下代码：

   ```jsp
   <%@ page contentType="text/html;charset=UTF-8" language="java" %>
   <html>
   <head>
       <title>Title</title>
   </head>
   <body>
       <%
       	// 在域中存储数据
           request.setAttribute("linxuan", "nihao");
           session.setAttribute("session", "attribute");
       %>
   
   <!--页面打印值，注意第三个不会打印NULL，只会打印空字符串-->
   ${requestScope.linxuan}<br>
   ${sessionScope.session}<br>
   ${sessionScope.linxuan}
   </body>
   </html>
   
   <!--
   	打印结果：
   		nihao
   		attribute
   -->
   ```

   > 注意：
   >
   > ​	如果获取的键没有，那么不会打印NULL，只会打印空字符串。

2. `${键名}`：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。

   * 从从最小的域中开始查找，如果找到了，那么会停止，之后的域便不会查找。
   * 与域对象放置的位置无关。

   ```jsp
   <%@ page contentType="text/html;charset=UTF-8" language="java" %>
   <html>
   <head>
       <title>Title</title>
   </head>
   <body>
       <%
           // 在域中存储数据
           session.setAttribute("name", "张三2");
           request.setAttribute("name", "张三1");
           session.setAttribute("lisi", "李四");
       %>
   <!--打印数据-->
   ${name}
   </body>
   </html>
   
   <!--
   	打印结果：
   		张三1
   -->
   ```

## 3.4 获取对象的值

<!--P773-->

获取对象的值的方法：`${域名称.键名.属性名}`

* 如果只是`${域名称.键名}`，会打印哈希值

* 属性名是getter和setter方法去掉get或者set，然后将剩余的部分首字母变成小写。
* 调用setName方法，去掉set，将N变成小写。`setName --> Name --> name`

* **本质上会去调用对象的getter和setter方法**

创建一个User类，存储姓名，年龄，日期。

```java
import java.util.Date;

public class User {
    private String name;
    private int age;
    private Date date;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Date getDate() {
        return date;
    }

    public void setDate(Date date) {
        this.date = date;
    }
}
```

创建jsp文件，获取User对象，存储数据。再获取值

```jsp
<%@ page import="cn.com.demo01.User" %>
<%@ page import="java.util.Date" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <%
        // 获取User对象，存储数据
        User user = new User();
        user.setName("linxuan");
        user.setAge(19);
        user.setDate(new Date());

        request.setAttribute("user", user);
    %>

    <!--获取对象中的值-->
    ${requestScope.user.name}<br>
    ${user.age}<br>
    ${user.date}<br>
    ${user.date.year}<br>
</body>
</html>

<!--
    输出：
        linxuan
        19
        Sat Mar 19 16:08:40 CST 2022
        122
-->
```

我们发现，输出的日期格式并不是我们想要的，所以我们可以利用一波获取对象的值的方法，在User类里面定义好输出日期的格式。

```java
User类：
/**
 * 逻辑视图，非常常用的一种方式
 * @return
 */
public String getDateStr() {
    if (date != null) {
    	SimpleDateFormat sdf = new SimpleDateFormat("yyy-MM-dd HH:mm:ss");
    	return sdf.format(date);
    } else {
    	return "";
    }
}

jsp文件里面键入下面代码：
<!--输出指定格式的日期-->
${user.dateStr}

<!--这样就会在页面输入中国的时间格式了-->
```

## 3.5 获取List、Map集合的值

<!--P774-->

### 获取List集合

获取List集合的方法：`${域名称.键名[索引]}`

```jsp
<%@ page import="cn.com.demo01.User" %>
<%@ page import="java.util.Date" %>
<%@ page import="java.util.List" %>
<%@ page import="java.util.ArrayList" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <%
        // 获取User对象，存储数据
        User user = new User();
        user.setName("linxuan");
        user.setAge(19);
        user.setDate(new Date());

        request.setAttribute("user", user);

        List list = new ArrayList();
        list.add("aaa");
        list.add("bbb");
        list.add(user);

        request.setAttribute("list", list);
    %>

    <!--输出list集合值-->
    ${requestScope.list}<br>
    ${requestScope.list[0]}<br>
    ${requestScope.list[1]}<br>
    ${requestScope.list[2].name}<br>
    <!--对越界索引做了一个优化，所以不会报错，只会打印空字符串-->
    ${requestScope.list[3]}

</body>
</html>

<!--
	输出：
		[aaa, bbb, cn.com.demo01.User@4d322f31]
        aaa
        bbb
        linxuan
-->
```

> 注意：
>
> ​	在EL表达式里面对越界索引异常做了优化，并不会报错，只会打印空字符串

### 获取Map集合

获取Map集合有两种方法，如下：

* `${域名称.键名.key名称}`
* `${域名称.键名["key名称"]}`

```jsp
<%@ page import="cn.com.demo01.User" %>
<%@ page import="java.util.Date" %>
<%@ page import="java.util.Map" %>
<%@ page import="java.util.HashMap" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <%
        // 获取User对象，存储数据
        User user = new User();
        user.setName("linxuan");
        user.setAge(19);
        user.setDate(new Date());

        Map map = new HashMap();
        map.put("name", "李四");
        map.put("gender", "男");
        map.put("user", user);

        request.setAttribute("map", map);
    %>

    <!--获取Map值-->
    ${map.name}<br>
    ${map["gender"]}<br>
    ${map.user.name}<br>
</body>
</html>

<!--
	输出：
        李四
        男
        linxuan
-->
```

## 3.6 隐式对象：

<!--P775 3.21-->

el表达式中一共有着11个隐式对象，我们只需要学习pageContext即可。

* pageContext：获取jsp其他八个内置对象
  * ${pageContext.request.contextPath}：动态获取虚拟目录



# 第二章 MVC开发模式

## 2.1 JSP演变历史

<!--P768-->

1. 早期只有servlet，只能使用response输出标签数据，非常麻烦。
2. 后来有了jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，又写html标签，造成难于维护，难于分工协作。
3. 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性。

## 2.2 MVC详解

<!--P769-->

![](D:\Java\笔记\图片\2-16【软件设计架构】\1MVC开发模式.bmp)

**M**：Model，模型。JavaBean

* 完成具体的业务操作，如：查询数据库，封装对象

**V**：View，视图。JSP

* 展示数据

**C**：Controller，控制器。Servlet

* 获取用户的输入
* 调用模型
* 将数据交给视图进行展示

## 2.3 MVC优缺点

* 优点：
  1. 耦合性低，方便维护，可以利于分工协作
  1. 重用性高

* 缺点：
  1. 使得项目架构变得复杂，对开发人员要求高

# 第五章 三层架构：软件设计架构

<!--P781-->

1. 界面层(表示层)：用户看的得界面。用户可以通过界面上的组件和服务器进行交互
2. 业务逻辑层：处理业务逻辑的。
3. 数据访问层：操作数据存储文件。

![](D:\Java\笔记\图片\2-16【软件设计架构】\2三层架构.bmp)









<!--P737-->