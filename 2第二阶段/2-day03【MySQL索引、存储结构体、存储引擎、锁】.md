# 第一章 MySQL体系构架

以下是官网MySQL体系构架图，我们稍微对其进行了层级划分。

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\20210126094715923.png)


由上至下，我们可以MySQL的体系构架划分为：**1.网络接入层 2.服务层 3.存储引擎层 4.文件系统层**

## 1.1 网络接入层

提供了应用程序接入MySQL服务的接口。客户端与服务端建立连接，客户端发送SQL到服务端。

## 1.2 服务层

### 管理工具和服务

系统管理和控制工具，例如备份恢复、Mysql复制、集群等

### 连接池

主要负责连接管理、授权认证、安全等等。

每个客户端连接都对应着服务器上的一个线程。服务器上维护了一个线程池，避免为每个连接都创建销毁一个线程。当客户端连接到MySQL服务器时，服务器对其进行认证。可以通过用户名与密码认证，也可以通过SSL证书进行认证。登录认证后，服务器还会验证客户端是否有执行某个查询的操作权限。

由于每次建立连接需要消耗很多时间，连接池的作用就是将这些连接缓存下来，下次可以直接用已经建立好的连接，提升服务器性能。

### SQL接口

接受用户的SQL命令，并且返回用户操作的结果。

### 查询解析器

SQL命令传递到解析器的时候会被解析器验证和解析。

MySQL是一个DBMS（数据库管理系统），没法直接理解SQL语句。Parser负责对SQL语句进行解析好让DBMS知道该怎么做。

### 查询优化器

SQL语句在查询之前会使用查询优化器对查询进行优化。它使用的是“选取-投影-联接”策略进行查询以此选择一个最优的查询路径。

```SQL
select uid,name from user where gender = 1;
```

select 查询先根据 where 语句进行选取，而不是先将表全部查询出来以后再进行条件过滤

select查询先根据 uid 和 name 进行属性投影，而不是将属性全部取出以后再进行过滤

将这两个查询条件联接起来生成最终查询结果

### 缓存

缓存（8.0版本之前支持查询缓存，8.0之后不支持了）
查询缓存，如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。

通过LRU算法将数据的冷端溢出，未来得及时刷新到磁盘的数据页，叫脏页。

这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等

## 1.3 存储引擎层

负责数据的存储和读取，与数据库文件打交道。 服务器中的查询执行引擎通过API与存储引擎进行通信，通过接口屏蔽了不同存储引擎之间的差异。


MySQL采用插件式的存储引擎。MySQL为我们提供了许多存储引擎，每种存储引擎有不同的特点。我们可以根据不同的业务特点，选择最适合的存储引擎。

MySQL区别于其他数据库的最重要的一个特点就是插件式的表存储引擎，注意：存储引擎是基于表的。

## 1.4 系统文件层

该层主要是将数据库的数据存储在文件系统之上，并完成与存储引擎的交互。

存储引擎是基于表的，以下分别使用`MyISAM`和`InnoDB`存储引擎建立两张表，看看其在文件系统中对应的文件存储格式。

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\20210126113548687.png)


存储引擎为`MyISAM`：

- `*.frm`：与表相关的元数据信息都存放在`frm`文件，包括表结构的定义信息等
- `*.MYD`：`MyISAM DATA`，用于存储`MyISAM`表的数据
- `*.MYI`：`MyISAM INDEX`，用于存储`MyISAM`表的索引相关信息

存储引擎为`InnoDB`：

- `*.frm`：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等
- `*.ibd`：`InnoDB DATA`，表数据和索引的文件。该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据

除了`.ibd`文件`InnoDB`还有一种文件的存储格式为`.ibdata`文件，那么他们之间有什么区别呢？

> `InnoDB`的数据存储方式能够通过配置来决定是使用共享表空间存放存储数据，还是用独享表空间存放存储数据。
>
> 独享表空间存储方式使用`.ibd`文件，并且每个表为一个`ibd`文件。共享表空间存储方式采用`.ibdata`文件，所有的表共同使用一个`ibdata`文件，即所有的数据文件都存在一个文件中。
>
> 决定使用哪种表的存储方式可以通过mysql的配置文件中`innodb_file_per_table`选项来指定。
>
> `InnoDB`默认使用的是独享表的存储方式，这种方式的好处是当数据库产生大量文件碎片的时，整理磁盘碎片对线上运行环境的影响较小。

## 1.5 SQL语句执行流程

用户使用mysql查询的一个整体流程如下（原图链接）：

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\20210126212911166.png)

简化版：

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\20210130005455679.png)

# 第二章 存储引擎

## 2.1 了解存储引擎

> 引擎（Engine）是电子平台上开发程序或系统的核心组件。
>
> 利用引擎，开发者可迅速建立、铺设程序所需的功能，或利用其辅助程序的运转。一般而言，引擎是一个程序或一套系统的支持部分。常见的程序引擎有游戏引擎，搜索引擎，杀毒引擎等。

Ok，我们知道了，引擎就是一个程序的核心组件。

MySQL中的数据用各种不同的技术存储在文件（或者内存）中。每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，能够获得额外的速度或者功能，从而改善应用的整体功能。 这些不同的技术以及配套的相关功能在MySQL中被称作存储引擎(也称作表类型)。

简单来说，存储引擎就是指**表的类型以及表在计算机上的存储方式**。

存储引擎的概念是MySQL的特点，Oracle中没有专门的存储引擎的概念，Oracle有OLTP和OLAP模式的区分。不同的存储引擎决定了MySQL数据库中的表可以用不同的方式来存储。我们可以根据数据的特点来选择不同的存储引擎。

<font color = "red">**MySQL区别于其他数据库的最重要的一个特点就是插件式的表存储引擎，也就是说存储引擎是基于表的。**</font>

## 2.2 存储引擎分类

查看当前安装的MySQL版本支持的存储引擎

```SQL
-- 查看MySQL版本
select version();

-- 查看版本支持的存储引擎
show engines;
```

官网5.7版本支持的10种存储引擎：

- <font color = "red">**MyISAM**</font>： 拥有较高的插入，查询速度，但不支持事务
- <font color = "red">**InnoDB**</font> ：5.5.8版本后Mysql的默认数据库引擎，支持ACID事务，支持行级锁定
- <font color = "red">**Memory**</font> ：所有数据置于内存的存储引擎，拥有极高的插入，更新和查询效率。但是会占用和数据量成正比的内存空间。并且其内容会在Mysql重新启动时丢失
- BDB： 源自Berkeley DB，事务型数据库的另一种选择，支持COMMIT和ROLLBACK等其他事务特性
- Merge ：将一定数量的MyISAM表联合而成一个整体，在超大规模数据存储时很有用
- Archive ：非常适合存储大量的独立的，作为历史记录的数据。因为它们不经常被读取。Archive拥有高效的插入速度，但其对查询的支持相对较差
- Federated： 将不同的Mysql服务器联合起来，逻辑上组成一个完整的数据库。非常适合分布式应用
- Cluster/NDB ：高冗余的存储引擎，用多台数据机器联合提供服务以提高整体性能和安全性。适合数据量大，安全和性能要求高的应用
- CSV： 逻辑上由逗号分割数据的存储引擎。它会在数据库子目录里为每个数据表创建一个.CSV文件。这是一种普通文本文件，每个数据行占用一个文本行。CSV存储引擎不支持索引。
- BlackHole ：黑洞引擎，写入的任何数据都会消失，一般用于记录binlog做复制的中继

## 2.3 常用存储引擎特性

### 存储特性要求

存储引擎常见的目标特性要求

>- 并发性：某些应用程序比其他应用程序具有更高的颗粒级锁定要求（如行级锁定）。
>
>- 事务支持：并非所有的应用程序都需要事务，但对的确需要事务的应用程序来说，有着定义良好的需求，如ACID兼容等。
>
>- 引用完整性：通过DDL定义的外键，服务器需要强制保持关联数据库的引用完整性。
>
>- 物理存储：它包括各种各样的事项，从表和索引的总的页大小，到存储数据所需的格式，到物理磁盘。
>
>- 索引支持：不同的应用程序倾向于采用不同的索引策略，每种存储引擎通常有自己的编制索引方法，但某些索引方法（如B-tree索引）对几乎所有的存储引擎来说是共同的。
>
>- 内存高速缓冲：与其他应用程序相比，不同的应用程序对某些内存高速缓冲策略的响应更好，因此，尽管某些内存高速缓冲对所有存储引擎来说是共同的（如用于用户连接的高速缓冲，MySQL的高速查询高速缓冲等），其他高速缓冲策略仅当使用特殊的存储引擎时才唯一定义。
>
>- 性能帮助：包括针对并行操作的多I/O线程，线程并发性，数据库检查点，成批插入处理等。
>
>- 其他目标特性：可能包括对地理空间操作的支持，对特定数据处理操作的安全限制等。

以上特性很多是互斥的，一个存储引擎只能具备其中某些要求。

下文主要介绍InnoDB MyISAM Memory三种存储引擎，以下是三者简要特性对比

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\20210126233629589.png)

### InnoDB引擎

`InnoDB`给MySQL的表提供了**事务处理**、**回滚**、**崩溃修复能力**和**多版本并发控制**的事务安全。在MySQL从3.23.34a开始包含`InnnoDB`。

它是MySQL上第一个提供外键约束的表引擎。外键所在的表叫做子表，外键所依赖（`REFERENCES`）的表叫做父表。父表中被字表外键关联的字段必须为主键。当删除、更新父表中的某条信息时，子表也必须有相应的改变，这是数据库的**参照完整性规则**。

而且`InnoDB`对事务处理的能力，也是其他存储引擎不能比拟的。靠后版本的MySQL的默认存储引擎就是`InnoDB`。默认使用B+TREE数据结构存储索引。

`InnoDB`存储引擎总支持**AUTO_INCREMENT**。自动增长列的值不能为空，并且值必须唯一。MySQL中规定自增列必须为主键。在插入值的时候，如果自动增长列不输入值，则插入的值为自动增长后的值；如果输入的值为0或空（NULL），则插入的值也是自动增长后的值；如果插入某个确定的值，且该值在前面没有出现过，就可以直接插入。

`InnoDB`中，创建的表的表结构存储在`.frm`文件中（我觉得是`frame`的缩写吧）。数据和索引存储在`innodb_data_home_dir`和`innodb_data_file_path`定义的表空间中。

`InnoDB`的优势在于提供了良好的事务处理、崩溃修复能力和并发控制。缺点是读写效率较差，占用的数据空间相对较大。

**特点**

- 支持事务，支持4个事务隔离（ACID）级别
- 行级锁定（更新时锁定当前行）
- 读写阻塞与事务隔离级别相关
- 既能缓存索引又能缓存数据
- 支持外键
- InnoDB更消耗资源，读取速度没有MyISAM快
- 在InnoDB中存在着缓冲管理，通过缓冲池，将索引和数据全部缓存起来，加快查询的速度；
- 对于InnoDB类型的表，其数据的物理组织形式是聚簇表。所有的数据按照主键来组织。数据和索引放在一块，都位于B+数的叶子节点上；

**业务场景**

- 需要支持事务的场景（银行转账之类）
- 适合高并发，行级锁定对高并发有很好的适应能力，但需要确保查询是通过索引完成的
- 数据修改较频繁的业务

**InnoDB引擎调优**

- 主键尽可能小，否则会给`Secondary index`带来负担
- 避免全表扫描，这会造成锁表
- 尽可能缓存所有的索引和数据，减少IO操作
- 避免主键更新，这会造成大量的数据移动

### MyISAM引擎

`MyISAM`是MySQL中常见的存储引擎，曾经是MySQL的默认存储引擎。`MyISAM`是基于`ISAM`引擎发展起来的，增加了许多有用的扩展。

`MyISAM`既不支持事务、也不支持外键、其优势是访问速度快，但是表级别的锁定限制了它在读写负载方面的性能，因此它经常应用于只读或者以读为主的数据场景。默认使用`B+TREE`数据结构存储索引。

`MyISAM`的表存储成3个文件。文件的名字与表名相同。拓展名为*`frm`*、*`MYD`*、*`MYI`*。其实，`frm`文件是存储表的结构；`MYD`文件存储数据，是`MYData`的缩写；`MYI`文件存储索引，是`MYIndex`的缩写。

基于`MyISAM`存储引擎的表支持3种不同的存储格式。包括静态型、动态型和压缩型。其中，静态型是`MyISAM`的默认存储格式，它的字段是固定长度的；动态型包含变长字段，记录的长度不是固定的；压缩型需要用到`myisampack`工具，占用的磁盘空间较小。

`MyISAM`的优势在于占用空间小，处理速度快。缺点是不支持事务的完整性和并发性。

**特点**

- 不支持事务
- 表级锁定（更新时锁定整个表）
- 读写互相阻塞（写入时阻塞读入、读时阻塞写入；但是读不会互相阻塞）
- 只会缓存索引（通过`key_buffer_size`缓存索引，但是不会缓存数据）
- 不支持外键
- 读取速度快

**业务场景**

- 不需要支持事务的场景（像银行转账之类的不可行）
- 一般读数据的较多的业务
- 数据修改相对较少的业务
- 数据一致性要求不是很高的业务

**MyISAM引擎调优**

- 设置合适索引
- 启用延迟写入，尽量一次大批量写入，而非频繁写入
- 尽量顺序`insert`数据，让数据写入到尾部，减少阻塞
- 降低并发数，高并发使用排队机制
- `MyISAM`的`count`只有全表扫描比较高效，带有其它条件都需要进行实际数据访问

### Memory引擎

`MEMORY`是MySQL中一类特殊的存储引擎。它使用存储在内存中的内容来创建表，而且**数据全部放在内存中**。这些特性与前面的两个很不同。

每个基于`MEMORY`存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为*`frm`*类型。该文件中只存储表的结构。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。值得注意的是，服务器需要有足够的内存来维持`MEMORY`存储引擎的表的使用。如果不需要了，可以释放内存，甚至删除不需要的表。要记住，在用完表格之后就删除表格，不然一直占据内存空间。

`MEMORY`默认使用哈希索引。速度比使用B型树索引快。当然如果你想用B型树索引，可以在创建索引时指定。

注意，`MEMORY`用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于MEMORY的表的生命周期很短，一般是一次性的。

**特点**

- 支持的数据类型有限制，比如：不支持`TEXT`和`BLOB`类型（长度不固定），对于字符串类型的数据，只支持固定长度的行，`VARCHAR`会被自动存储为`CHAR`类型；
- 支持的锁粒度为表级锁。所以，在访问量比较大时，表级锁会成为`MEMORY`存储引擎的瓶颈；
- 由于数据是存放在内存中，一旦服务器出现故障，数据都会丢失；
- 查询的时候，如果有用到临时表，而且临时表中有`BLOB`，`TEXT`类型的字段，那么这个临时表就会转化为MyISAM类型的表，性能会急剧降低；
- 默认使用`hash`索引。
- 如果一个内部表很大，会转化为磁盘表。

**业务场景**

- 那些内容变化不频繁的代码表，或者作为统计操作的中间结果表，便于高效地堆中间结果进行分析并得到最终的统计结果。
- 目标数据比较小，而且非常频繁的进行访问，在内存中存放数据，如果太大的数据会造成内存溢出。可以通过参数`max_heap_table_size`控制`Memory`表的大小，限制`Memory`表的最大的大小。
- 数据是临时的，而且必须立即可用得到，那么就可以放在内存中。
- 存储在`Memory`表中的数据如果突然间丢失的话也没有太大的关系。

## 2.4 怎样选择存储引擎

在实际工作中，选择一个合适的存储引擎是一个比较复杂的问题。每种存储引擎都有自己的优缺点，不能笼统地说谁比谁好。

[![img](https://images2015.cnblogs.com/blog/851461/201703/851461-20170306202857781-1607368004.png)](https://images2015.cnblogs.com/blog/851461/201703/851461-20170306202857781-1607368004.png)

* InnoDB：支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。 
* MyISAM：插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。
* MEMORY：所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。

> 注意，同一个数据库也可以使用多种存储引擎的表。如果一个表要求比较高的事务处理，可以选择InnoDB。这个数据库中可以将查询要求比较高的表选择MyISAM存储。如果该数据库需要一个用于查询的临时表，可以选择MEMORY存储引擎。

## 2.4 存储引擎构架

为了进一步深入理解MySQL存储引擎，我们有必要了解一下存储引擎的数据存储结构，在此之前，我们得先了解下数据在文件系统中的存储。

### 磁盘基本知识

数据库的数据存储在文件系统中。文件系统是操作系统用来 明确 存储设备（常见的是磁盘，也有基于NAND Flash的固态硬盘）或分区上的文件 的方法和数据结构。**磁盘上数据必须用一个三维地址唯一标示：柱面号、盘面号、块号(磁道上的盘块)。**

硬盘只是磁盘的一种，或说是经典代表，以下通过硬盘模型图讲解磁盘中的各个概念。

硬盘整体模型图

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\20210127094513512.jpg)

硬盘模型图

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\20210127095609945.png)


磁盘重点概念

- 盘片（platter）：硬盘中承载数据存储的介质

  硬盘一般由多个盘片组成，每个盘片包含两个面，每个盘面都对应地有一个读/写磁头。受到硬盘整体体积和生产成本的限制，盘片数量都受到限制，一般都在5片以内。盘片的编号自下向上从0开始，如最下边的盘片有0面和1面，再上一个盘片就编号为2面和3面。

- 磁头（head）：通过磁性原理读取磁性介质上数据的部件

- 磁道（track）：当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道

- 扇区（sector）：磁盘上的每个磁道被等分为若干个弧段，这些弧段便是硬盘的扇区，同一块硬盘上的扇区大小是一致的"每个磁道的扇区数一样的

  <font color = "red">"说的是老的硬盘，外圈的密度小，内圈的密度大（简单理解就是，磁盘存储媒介为
  磁性记忆材料，在内圈涂的密度高），故每圈可存储的数据量是一样的。新的硬盘数据的密度都一致，这样磁道的周长越长，扇区就越多，存储的数据量就越大。</font>

- 柱面（cylinder）：在有多个盘片构成的盘组中，由不同盘片的面，但处于同一半径圆的多个磁道组成的一个圆柱面

**物理扇区（physical sector）与逻辑扇区（logical sector）**

近年来，为了最求更高的硬盘容量，便出现了扇区存储容量为2048、4096等字节的硬盘，我们称这样的扇区为"物理扇区"。这样的大扇区会导致许多兼容性问题，有的系统或软件无法适应。为了解决这个问题，硬盘内部将物理扇区在逻辑上划分为多个扇区片段并将其作为普通的扇区（一般为512字节大小）报告给操作系统及应用软件。这样的扇区片段我们称之为“逻辑扇区”。实际读写时由硬盘内的程序（固件）负责在逻辑扇区与物理扇区之间进行转换，上层程序“感觉”不到物理扇区的存在。

<font color = "red">逻辑扇区是硬盘可以接受读写指令的最小操作单元，是操作系统及应用程序可以访问的扇区，多数情况下其大小为512字节。我们通常所说的扇区一般就是指的逻辑扇区。物理扇区是硬盘底层硬件意义上的扇区，是实际执行读写操作的最小单元。</font>是只能由硬盘直接访问的扇区，操作系统及应用程序一般无法直接访问物理扇区。当要读写某个逻辑扇区时，硬盘底层在实际操作时都会读写逻辑扇区所在的整个物理扇区。

**磁盘容量计算**

- 旧式——非ZBR区位记录（不同磁道扇区数相同）

  存储容量 ＝ 磁头数 × 磁道(柱面)数 × 每道扇区数 × 每扇区字节数

  比如上图最右边硬盘容量：6 * 7 * 12 * 512 = 258048 byte

- 新式——ZBR区位记录（不同磁道扇区数不同）

**块（Block）/簇（Cluster）**

块/簇两者指的是同一个逻辑上的概念，只是在Linux与Windows中的称呼不同。

- 块/簇 是操作系统中最小的逻辑存储单位。操作系统与磁盘打交道的最小单位是块/簇。
- 在Windows下如NTFS等文件系统中叫做簇；在Unix和Linux下如Ext4等文件系统中叫做块（block）。
- 每个簇或者块可以包括2、4、8、16、32、64…2的n次方个扇区。

**块/簇 用来干什么的**

磁盘的最小单位是扇区，操作系统使用的是 块/簇 作为IO的基本单位。

- 读取方便：扇区容量小，数据多会加大寻址难度。操作系统将相邻的扇区组合一起形成块，再对块整体操作

- 分离对底层的依赖：操作系统忽略对底层物理存储结构的设计。通过虚拟出来磁盘块的概念，在系统中认为块是最小的单位

扇区是对硬盘而言，块是对文件系统而言，出于不同的需要。

**查看块/簇的大小**

不同文件系统中block的大小不一样。

```asciiarmor
Windows:（使用管理员命令提示行）
fsutil fsinfo ntfsinfo E:

Linux：
stat /home | grep "IO Block"
```

如下所示，Windows下E盘的Cluster的大小为4Kb大小，如下所示：

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\20210127114610560.png)

**页（Page）**
操作系统经常与内存和硬盘这两种存储设备进行通信，类似于“块”的概念，都需要一种虚拟的基本单位。与内存操作，是虚拟一个页的概念来作为最小单位。与硬盘打交道，就是以块为最小单位。

**扇区、块/簇、页的关系**

- 扇区： 硬盘的最小读写单元
- 块/簇： 是操作系统针对硬盘读写的最小单元
- 页： 是内存与操作系统之间操作的最小单元。
- 扇区 <= 块/簇 <= 页

### MySQL的InnoDB数据存储结构

MySQL的InnoDB数据存储结构可以划分为逻辑存储结构和物理存储结构。

**前置：数据库磁盘读取与系统磁盘读取**

- 系统从磁盘中读取数据到内存时是以磁盘块（block）为基本单位，位于同一个磁盘块中的数据会被一次性读取出来。
- <font color = "red">InnoDB存储引擎中有页（Page）的概念，页是数据库管理磁盘的最小单位，InnoDB存储引擎中默认每个页的大小为16kb，每次读取磁盘时都将页载入内存中。</font>
- 系统一个磁盘块的大小空间往往没有16kb这么大，因此InnoDB每次io操作时都会将若干个地址连续的磁盘块的数据读入内存，从而实现整页读入内存。

**物理存储结构**

<font color = "red">从物理意义上来看，InnoDB表由共享表空间、日志文件组（更准确地说，应该是Redo文件组）、表结构定义文件组成。</font>若将innodb_file_per_table设置为on，则每个表将独立地产生一个表空间文件，以ibd结尾，数据、索引、表的内部数据字典信息都将保存在这个单独的表空间文件中。表结构定义文件以frm结尾，这个是与存储引擎无关的，任何存储引擎的表结构定义文件都一样，为.frm文件。

**逻辑存储结构**
InnoDB存储引擎的逻辑存储结构和Oracle大致相同，所有数据都被逻辑地存放在一个空间中，我们称之为表空间。<font color = "red">表空间又由段、区、页组成。</font>`1 extent = 64 pages`，InnoDB存储引擎的逻辑存储结构大致如图所示。

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\20210128150726805.png)

**表空间（tablespace）**

表空间可以看做是InnoDB存储引擎逻辑结构的最高层，<font color = "red">所有的数据都是存放在表空间中</font>。默认情况下InnoDB存储引擎有一个共享表空间ibdata1，即所有数据都放在这个表空间内。如果我们启用了参数`innodb_file_per_table`，则每张表内的数据可以单独放到一个表空间内。

对于启用了`innodb_file_per_table`的参数选项，需要注意的是，每张表的表空间内存放的只是数据、索引和插入缓冲，其他类的数据，如撤销（Undo）信息、系统事务信息、二次写缓冲（double write buffer）等还是存放在原来的共享表空间内。这也就说明了另一个问题：即使在启用了参数innodb_file_per_table之后，共享表空间还是会不断地增加其大小。

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\2021012815281239.png)

**段（segment）**

表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等。

InnoDB存储引擎表是由索引组织的（index organized），因此数据即索引，索引即数据。InnoDB采取B+树作为存储数据的结构，数据段即为B+树的叶节点（上图的leaf node segment），索引段即为B+树的非叶子节点（上图的non-leaf node segment）。

InnoDB存储引擎对于段的管理是由引擎本身完成。

**区（extent）**

<font color = "red">一个区是由64个连续的页组成的，每个页大小为16KB，即每个区的大小为1MB。</font>对于大的数据段，InnoDB存储引擎最多每次可以申请4个区，以此来保证数据的顺序性能。

在我们启用了参数innodb_file_per_talbe后，创建的表默认大小是96KB，新建的InnoDB表就是一个区。区是64个连续的页，那创建的表的大小至少是1MB才对啊？其实这是因为在每个段开始时，先有32个页大小的碎片页（fragment page）来存放数据，当这些页使用完之后才是64个连续页的申请。

```asciiarmor
create table innodb_table(
	id int primary key
)engine=innodb default charset=utf8;
```

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\20210128155859405.png)

**页（page）**

每个页大小为16KB，页是InnoDB磁盘管理的最小单位，整页整页的读取。

InnoDB中主要的页类型：

- 数据页（BTreeNode）
- Undo页（undo Log page）
- 系统页（System page）
- 事务数据页（Transaction SystemPage）

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\20210129225535112.png)

1. 0-38：页头占据38位字节，页面id（32位的整数），页面类型，以及两个分别指向前一个page和后一个page的指针（page是一个双向列表）等信息
2. 38-16376：不同的类型页所含的数据不同，这部分空间包含系统记录（SystemRecord）和用户记录（UserRecord)，我们表中的一条条记录就放在UserRecord部分
3. 16376-16384：页面结束标识

由页组成的链表，页之间是双向列表，页里面的数据是单向链表，这种结构组成了主键索引B+树，组成了叶子节点数据。

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\20210129230713841.png)

### 定位一条表记录的过程

```sql
select * from user where id = 29
```

这里id是主键,我们通过这棵B+树来查找，首先找到根页，你怎么知道user表的根页在哪呢？

其实每张表的根页位置在表空间文件中是固定的。系统经过解析sql语句，首先从找到user表的跟页面（一个表通常需要多个页面组成，跟页面就是起始页），层级遍历非叶子节点页（索引）读取到key值为29的指针（遍历非叶子节点的过程随着节点的遍历会将一个或多个页加载到内存），最后到指针指向的叶子节点所在的页中，然后遍历找出该条记录。

如果使用了二级索引则先读取二级索引page遍历这个二级索引，找到装有主键信息叶子节点page页，遍历找到该主键。然后再根据主键索引寻找到该条记录

# 第三章 索引结构

## 3.1 常见的索引结构

Mysql数据库中的常见索引结构有多种，常用Hash，B-树，B+树等数据结构来进行数据存储。树的深度加深一层，意味着多一次查询，对于数据库磁盘而言，就是多一次IO操作，导致查询效率低下。

在计算机数据结构体系中，为了加速查找的速度，常见的数据结构有两种：

-     `Hash`哈希结构，例如Java中的`HashMap`，这种数据组织结构可以让查询/插入/修改/删除的平均时间复杂度都为O(1);

-     `Tree` 树结构 ， 这种数据组织结构可以让查询/插入/修改/删除的平均时间复杂度都为O(log(n));

问题来了：即然不管读还是写，`Hash`这种类型比`Tree`树这种类型都要更快一些，那为什么MySQL的开发者既使用`Hash`类型做为索引，又使用了`BTREE`呢？

话说回来，还是跟SQL应用场景有关系，前文中我们找`"ZhangSan"`用户的`SQL`：

```sql
select name,age,address from employee where name='ZhangSan'
```

确实用HASH索引更快，因为每次都只查询一条信息（重名的雇员姓名也才几条而已），但实际上业务对于SQL的应用场景是：

-      `orderby` 需要排个序
-      `groupby` 还要分个组
-      还要比较大小 大于或小于等等

> group by
> having
> order by
> limit

这种情况下如果继续用`HASH`类型做索引结构，其时间复杂度会从O(1)直接退化为O(n)，相当于全表扫描了，而`Tree`的特性保证了不管是哪种操作，依然能够保持O(log(n))的高效率，有种我自岿然不动的赶脚！所以抛开应用场景谈设计其实是耍流氓（比如很多java程序员被安利阿里的`fastjson`比`jackson`快，故而抛弃`jackson`一样），实际上MySQL中也支持`HASH`类型的索引，但不是主流。

我们下面谈一下各种树

### 二叉搜索树

了解下二叉搜索树有助于我们理解B-树、B+树，二叉搜索树的特点是：

- 所有非叶子结点至多拥有两个儿子（Left和Right）；
- 所有结点存储一个关键字；
- 非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；

以下都是二叉搜索树：

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\20210128203928397.png)

如果要找到65，左边的二叉树需要扫描3层（3次IO），而右边的却需要6层。

<img src="D:\Java\笔记\图片\3-day02【MySQL约束】\8传统二叉树.png"  />

二叉树是大家熟知的一种树，用它来做索引行不行，可以是可以，但有几个问题：

1. **如果索引数据很多，树的层次会很高（只有左右两个子节点），数据量大时查询还是会慢**

2. **二叉树每个节点只存储一个记录，一次查询在树上找的时候花费磁盘IO次数较多**

所以它并不适合直接拿来做索引存储，算法设计人员在二叉树的基础之上进行了变种，引入了`BTREE`的概念

### B-Tree（B树）

> B-tree树即B树，B即Balanced，平衡的意思。因为B树的原英文名称为B-tree，而国内很多人喜欢把B-tree译作B-树，其实，这是个非常不好的直译，很容易让人产生误解。事实上，B-tree就是指的B树。

B树是一种多路搜索树，一棵m阶的B树满足下列条件：

- 树中每个结点至多有m个孩子
- 根结点的儿子数为[2, M]；
- 除根结点以外的非叶子结点的儿子数为[M/2, M]；
- 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）
- 非叶子结点的关键字个数 = 指向子节点的指针个数-1；
- 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
- 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；
- 所有叶子结点位于同一层；

以下是3阶B树

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\20210131224804956.png)

磁盘读取数据是以盘块(block)为基本单位的。

以下结合磁盘块作图

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\20210128210127904.png)

B树的特征：

- 关键字集合分布在整颗树中；
- 任何一个关键字出现且只出现在一个结点中；
- 搜索有可能在非叶子结点结束；
- 其搜索性能等价于在关键字全集内做一次二分查找；
- 自动层次控制；

B树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；



<img src="D:\Java\笔记\图片\3-day02【MySQL约束】\9二叉树.png" style="zoom:200%;" />

如上图可知`BTREE`有以下特点：

-      <font color = "red">不再是二叉搜索，而是N叉搜索，树的高度会降低，查询快</font>

-      <font color = "red">叶子节点，非叶子节点，都可以存储数据，且可以存储多个数据</font>

-      <font color = "red">通过中序遍历，可以访问树上所有节点。中序遍历：左根右。</font>

`BTREE`被作为实现索引的数据结构被创造出来，是因为它能够完美的利用“局部性原理”，其设计逻辑是这样的：

-      <font color = "red">内存读写快，磁盘读写慢，而且慢很多</font>
-      <font color = "red">磁盘预读：磁盘读写并不是按需读取，而是按页预读，一次会读一页的数据，每次加载一些看起来是冗余的数据，如果未来要读取的数据就在这一页中，可以避免未来的磁盘读写，提高效率（通常，一页数据是4K）</font>
-      <font color = "red">局部性原理：软件设计要尽量遵循“数据读取集中”与“使用到一个数据，大概率会使用其附近的数据”，这样磁盘预读能充分提高磁盘IO效能</font>

### B+ Tree

早先的MySQL就是使用的`BTREE`做为索引的数据结构，随着时间推移，B树发生了较多的变种，其中最常见的就是`B+TREE`变种，现在MySQL用的就是这种：

B+树是B-树的变体，也是一种多路搜索树：（❀ 表示两者间的不同点）

- 树中每个结点至多有m个孩子

- 根结点的儿子数为[2, M]；

- 除根结点以外的非叶子结点的儿子数为[M/2, M]；

- 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）

- 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；

- ❀ 非叶子结点的子树指针与关键字个数相同；

- ❀ 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树；（B树是开区间）；

- ❀ 为所有叶子结点增加一个链指针；

- ❀ 所有关键字都在叶子结点出现；

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\20210128213406422.png)

B+树的特征：

- 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；
- 不可能在非叶子结点命中；
- 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；
- 每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。
- 更适合文件索引系统；

B+树的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；

示意如下：

![](D:\Java\笔记\图片\3-day02【MySQL约束】\10BTREE.png)

`B+TREE`改进点及优势所在：

-      <font color = "red">仍然是N叉树，层级小，非叶子节点不再存储数据，数据只存储在同一层的叶子节点上，B+树从根到每一个节点的路径长度一样，而B树不是这样</font>

-      <font color = "red">叶子之间，增加了链表(图中红色箭头指向)，获取所有节点，不再需要中序遍历，使用链表的next节点就可以快速访问到</font>

-      <font color = "red">范围查找方面，当定位min与max之后，中间叶子节点，就是结果集，不用中序回溯（范围查询在SQL中用得很多，这是B+树比B树最大的优势）</font>

-      <font color = "red">叶子节点存储实际记录行，记录行相对比较紧密的存储，适合大数据量磁盘存储；非叶子节点存储记录的PK，用于查询加速，适合内存存储</font>

-      <font color = "red">非叶子节点，不存储实际记录，而只存储记录的KEY的话，那么在相同内存的情况下，B+树能够存储更多索引</font>

可以来初步计算一下：

> 假设key、子树节点指针均占用4B，则B树一个节点占用4 + 4 = 8B，一页页面大小4KB，则N = 4 * 1024 / 8B = 512，一个512叉的B树，1000w的数据，深度最大 log(512/2)(10^7) 约等于4。
>
> 对比二叉树如AVL的深度为log(2)(10^7) 约为24，相差了5倍以上！

> 假如一个节点大小是4KB，一个KEY有8字节，一页可以存4000/8=500个KEY，根据N叉树特点,就算一层500叉节点，则：
>
> - 第一层树：1个节点：1 * 500KEY , 大小4K
> - 第二层树：500节点 ：500 * 500=25万个KEY，500 * 4K=2M
> - 第三层树：500 * 500节点： 500 * 500 * 500=1.2亿KEY，500 * 500 * 4K=1G
>
> 如果没算错，1G空间，只用三层树结构，可以存1.2亿行数据的KEY，B+树牛掰不？

所以`B+TREE`索引只用占用很少的内存空间，却大大提升了查询效率（不论是单个查询、范围查询还是有序性查询），并且还减少了磁盘读写。

### B+ 树更适合作索引

1. <font color = "red">B+ 树的磁盘读写代价更低</font>
   B+ 树的数据都集中在叶子节点，分支节点 只负责指针（索引）；B 树的分支节点既有指针也有数据 。这将导致B+ 树的层高会小于B 树的层高，也就是说B+ 树平均的Io次数会小于B 树。
2. <font color = "red">B+ 树的查询效率更加稳定</font>
   B+ 树的数据都存放在叶子节点，故任何关键字的查找必须走一条从根节点到叶子节点的路径。所有关键字的查询路径相同，每个数据查询效率相当。
3. <font color = "red">B+树更便于遍历</font>
   由于B+树的数据都存储在叶子结点中，分支结点均为索引，遍历只需要扫描一遍叶子节点即可；B树因为其分支结点同样存储着数据，要找到具体的数据，需要进行一次中序遍历按序来搜索。
4. <font color = "red">B+树更擅长范围查询</font>
   B+树叶子节点存放数据，数据是按顺序放置的双向链表。B树范围查询只能中序遍历。
5. <font color = "red">B+ 树占用内存空间小</font>
   B+ 树索引节点没有数据，比较小。在内存有限的情况下，相比于B树索引可以加载更多B+ 树索引。

### Hash

哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。Memory存储引擎使用Hash。

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\20210129224145549.png)

<font color = "red">Hash索引仅仅能满足"=",“IN"和”<=>"查询，不能使用范围查询。也不支持任何范围查询，例如`WHERE price > 100`。</font>

<font color = "red">由于Hash索引比较的是进行Hash运算之后的Hash值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的Hash算法处理之后的Hash值的大小关系，并不能保证和Hash运算前完全一样。</font>

从上面的图来看，B+树索引和哈希索引的明显区别是：

- 如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；这有个前提，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；

- 如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；

- 哈希索引也没办法利用索引完成排序，以及`like ‘xxx%’` 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；

- 哈希索引也不支持多列联合索引的最左匹配规则；

- B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。

## 3.2 B+ 树可以存储多少行数据

InnoDB存储引擎也有自己的最小储存单元——页（Page），一个页的大小默认是16K。

```asciiarmor
mysql> show variables like 'innodb_page_size';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| innodb_page_size | 16384 |
+------------------+-------+
```

磁盘扇区、文件系统、InnoDB存储引擎都有各自的最小存储单元

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\20210129144520139.png)

数据表中的数据都是存储在页中的，所以一个页中能存储多少行数据呢？假设一行数据的大小是1k，那么一个页可以存放16行这样的数据。

如果数据库只按这样的方式存储，那么如何查找数据就成为一个问题？
因为我们不知道要查找的数据存在哪个页中，也不可能把所有的页遍历一遍，那样太慢了。

于是人们想到了用B+ 树的方式组织这些数据，下图以InnoDB为例。

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\20210131235341534.png)

pointer往往是6个字节，指明对应key值的页面位置信息。key一般为索引主键，如果为单字段 bigint 类型，则为8字节。如此可计算一个页大概可以存放16 * 1024/（6+8）=1170行数据。假设一行数据1k，那么2层B+ 树（第一层索引，第二层叶子节点 存数据）就可以存储1170 * 16 = 18 720行；三层则可以存储1170 * 1170 * 16=21902400行。

## 3.3 InnoDB使用B+树

InnoDB使用B+Tree数据结构存储索引，根据索引物理结构可将索引划分为聚簇索引和非聚簇索引（也可称辅助索引或二级索引）。一个表中只能存在一个聚簇索引（主键索引），但可以存在多个非聚簇索引。

B+树 叶子节点包含数据表中行记录就是聚簇索引（索引和数据是一块的）。

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\20210131235047821.png)

B+树 叶子节点没包含数据表中行记录就是非聚簇索引（索引和数据是分开的）。

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\2021013123462610.png)



## 3.4 InnoDB不使用哈希索引

说说 MySQL 的索引

* 我：索引是存储引擎层的问题，要看存储引擎，常用的有 MyISAM 和 InnoDB。

两者索引结构都是 B+ 树，但InnoDB 是聚集索引，叶子节点既存数据也存储 key，查找数据需要先查找二级索引，得到主键然后在到聚集索引中查找，需要二次查找。MyISAM 是非聚集索引，叶子节点只存储 key，只需一次查表，因此 MyISAM 适合于读密集的场景，InnoDB 则具有很多额外的特性，如行级锁，事务等，InnoDB 适合写密集的场景

面试官：为啥用 B+ 树

* 我：索引结构还有其他的很多，如 hash，红黑树，B 树

* 不用 hash 是因为冲突和不适合排序和分组查询

* 不用红黑树，是因为它是二叉树，高度高，因为不可能把整个表装入内存，只能从根节点一直到叶子节点一个一个转入，需要的 IO 次数太多

* 不用 B 树是因为，B 树的内部节点也存储数据，且 B 树的叶子节点相互福利，相比 B+ 树的排序和分组查询差一些，由于内部节点也存储数据，B 树更适合单值查询更多的数据库，比如非关系型数据库，我了解到 MongoDB 就是用的 B 树，B+ 树则更适合关系型数据库。

## 3.5 MyISAM使用B+树

MyISAM也使用B+Tree数据结构存储索引，但都是非聚簇索引。

以下是MyISAM主键索引存储图

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\2021020100081078.png)

可见，索引和数据是分开的 索引的data部分只是索引的地址值。其实上文也提到过，.MYI就是MyISAM表的索引文件，MYD是MyISAM表的数据文件。

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\20210201001937236.png)

## 3.6 B+树索引和哈希索引的区别

- 如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据;
- 如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；
- 同理，哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；
- 哈希索引也不支持多列联合索引的最左匹配规则；
- B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。

## 3.7 Hash 索引的限制和弊端

Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B+Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B+Tree 索引。

可能很多人又有疑问了，既然 Hash 索引的效率要比 B+Tree 高很多，为什么大家不都用 Hash 索引而还要使用 B+Tree 索引呢？任何事物都是有两面性的，Hash 索引也一样，虽然 Hash 索引效率高，但是 Hash 索引本身由于其特殊性也带来了很多限制和弊端，主要有以下这些。

- **Hash 索引仅仅能满足”=”,”IN”和”<=>”查询，不能使用范围查询。**由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。

- **Hash 索引无法被用来避免数据的排序操作。**由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；

- **Hash 索引不能利用部分索引键查询。**对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。

- **Hash 索引在任何时候都不能避免表扫描。**前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。

- **Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B+Tree索引高。**对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下

简单地说，哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。

# 第四章 索引

## 1.1 导入

> 字段也就是列

假设我们有一张数据表 `employee(员工表)`，该表有三个字段（列）,分别是`name`、`age` 和`address`。假设表`employee`有上万行数据，现在需要从这个表中查找出所有名字是`‘ZhangSan’`的雇员信息，你会快速的写出SQL语句：

```sql
select name,age,address from employee where name='ZhangSan'
```

如果数据库还没有索引这个东西，一旦我们运行这个SQL查询，查找名字为`ZhangSan`的雇员的过程中，究竟会发生什么？

- 数据库不得不在`employee`表中的每一行查找并确定雇员的名字`（name）`是否为`‘ZhangSan’`。

- 由于我们想要得到每一个名字为`ZhangSan`的雇员信息，在查询到第一个符合条件的行后，不能停止查询，因为可能还有其他符合条件的行，所以必须一行一行的查找直到最后一行——这就意味数据库不得不检查上万行数据才能找到所有名字为`ZhangSan`的雇员。这就是所谓的全表扫描，显然这种模式效率太慢。


## 1.2 索引介绍

你会想为如此简单的事情做全表扫描效率欠佳——数据库是不是应该更聪明一点呢？“索引”派上用场的时候到了，使用索引的全部意义就是：**通过缩小一张表中需要查询的记录/行的数目来加快搜索的速度。**

在关系型数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单（定义真特么拗口）。**大白话意思是索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。**

一个索引是存储的表中一个特定列的值数据结构。**索引是在表的列上创建。要记住的关键点是索引包含一个表中列的值，并且这些值存储在一个数据结构中。请牢记这一点：<font color = "red">索引是一种数据结构。</font>**

一个好的数据库表设计,从一开始就应该考虑添加索引,而不是到最后发现慢SQL了,影响业务了才来补救。

在没有GUI工具的情况下，可以使用以下命令查看索引：

<img src="D:\Java\笔记\图片\3-day02【MySQL约束】\7索引.png" style="zoom:150%;" />

上述`ad_article`表中有两个索引，`Key_name`中有显示:

-  `PRIMARY`主键索引，`Seq_in_index`索引序号为1，从1开始，`Collation`为“A”表示升序（或NULL无分类），对应字段是id

-  `idx_cid`是自建索引，由`cid`、`available`、`id`三个字段组成，分别对应序号1,2,3

表中大部分信息都挺好理解的，倒是`Index_type=BTREE`这块内容很多人不懂其意思，其实通过GUI工具创建索引时也会有`BTREE` 的显示，先着重了解一下。

### Cardinality 索引基数

<img src="D:\Java\笔记\图片\3-day02【MySQL约束】\7索引.png" style="zoom:150%;" />

说完`BTREE`，在`'show index from ad_article'`结果集中有一列为`Cardinality`的值，它的作用也非常的大，称之为：**索引基数**

索引基数简单的说就是:**你索引列的唯一值的个数，如果是复合索引就是唯一组合的个数**。

这个数值将会作为MySQL优化器对语句执行计划进行判定时依据。如果唯一性太小，那么优化器会认为这个索引对语句没有太大帮助，而不使用索引。`cardinality`值越大，就意味着，使用索引能排除越多的数据，执行也更为高效。

举个简单例子来说明：比如有一张表有A、B、C列，数据情况如下：

```asciiarmor
A    B    C
1    1    1
1    1    2
1    2    1
1    2    2
2    1    1
2    1    2
2    2    1
2    2    2
```

-      如果对A列进行索引，那么它的`cardinality`基数值为2，因为只有1，2两种值

-      如果对A、B两列做复合索引，那么它的`cardinality`基数值为4，因为值的组合为(11),(1 2),(2 1),(2 2)

-      如果对A、B、C做复合索引，则它的`cardinality`基数值为8

> 当有多个索引可用时，mysql会自动依据`cardinality`大的值来进行SQL索引选择优化。
>
> 如果现在再问你“为什么数据库都有PK”，你怎么答?
> 		因为PK的数据均不一样啊，做索引了后查询起来效果才快啊，因为`cardinality`值很高，是不是？
>
> 另一种问法常见于判断题，问你“数据库索引通常要放在选择性差的列上”，
> 		你以前可能还不明白为什么，其背后逻辑就是索引的`cardinality`值啊，选择性差意味着重复数据少，索引才高效嘛。

回到我们自己的例子，数据库中有数据值61行，但是`cardinality=59`并不准确，是因为它不会自动更新，需要通过`analyzetable`来进行更新，示例如下：

```sql
mysql>analyze local table ad_article;
```

优化以后结果为：

<img src="D:\Java\笔记\图片\3-day02【MySQL约束】\11优化.png" style="zoom:200%;" />

索引基数更加准确一些了。

## 1.3 索引类型

MySQL中有以下索引类型：

* <font color = "red">UNIQUE唯一索引</font>
* <font color = "red">INDEX普通索引</font>
* <font color = "red">PRIMARY KEY主键索引</font>
* <font color = "red">fulltext index 全文索引</font>

### UNIQUE唯一索引

`UNIQUE`唯一索引：该索引其含义是被标定义唯一索引的列，不允许出现重复的数据， 但可以有NULL值。举例来讲,假如有A、B两个字段，建立唯一索引：

```java
A  B
1  1
1  2
1  1  // 这一行数据无法插入，因为与第一条数据重复，数据库底层报错DuplicateKeyException 1 1
```

唯一索引有利有弊，好处是：如果你的程序不好处理界面端的重复提交，或者因为数据的重复导致程序出错误，可以通过创建唯一索引来解决问题，当然不要为了设置唯一索引而设置索引，索引还是要有用处的。

其次在设置了唯一索引时，万一真要发生变更，支持重复数据怎么办?MySQL提供了两种补救办法：

-      自动替换为新的值：可以用`ONDUPLICATE KEY UPDATE xxx= VALUES(xxx)`

-      忽略插入： `insert ignore into`

### INDEX普通索引

`INDEX`普通索引：允许出现相同的索引内容，平时创建的索引通常就是普通索引，利用提升查询数据性能

普通索引是最基本的索引类型，而且它没有唯一性之类的限制。普通索引可以通过以下几种方式创建：  

创建索引，例如  

```sql
CREATE INDEX <索引的名字> ON tablename (列的列表);  
```

修改表，例如  

```SQL
ALTER TABLE tablename ADD INDEX [索引的名字] (列的列表);  
```

创建表的时候指定索引，例如  

```SQL
CREATE TABLE tablename ( [...], INDEX [索引的名字] (列的列表) );  
```

### PRIMARY KEY主键索引

`PRIMARY KEY`主键索引：不允许出现相同的值,且不能为NULL值,一个表只能有一个`primary_key`索引，常见于ID字段。

主键是一种唯一性索引，但它必须指定为`“PRIMARY KEY”`。  

主键一般在创建表的时候指定，例如  

```SQL
CREATE TABLE tablename ( [...], PRIMARY KEY (列的列表) );  
```

但是，我们也可以通过修改表的方式加入主键，例如`“ALTER TABLE tablename ADD PRIMARY KEY (列的列表); ”`。每个表只能有一个主键。 

### fulltext index 全文索引

上述三种索引都是针对列的值发挥作用,但全文索引,可以针对值中的某个单词,比如一篇文章中的某个词,然而并没有什么卵用,因为只有`myisam`引擎以及英文支持,并且效率让人不敢恭维,要全文搜索还是建议使用`Luence`、`Solr`、`ES`等方案，更专业且强大一些。

## 1.4 索引的创建与使用

* `ALTER TABLE` 适用于表创建完毕之后再添加

  ```sql
  ALTERTABLE 表名 ADD 索引类型 （unique,primary key,fulltext,index）[索引名]（字段名）
  ```

* `CREATE INDEX`可对表增加普通索引或`UNIQUE`索引

  ```sql
  CREATE INDEXindex_name ON table_name (column_list)
  ```

  ```sql
  CREATE UNIQUE INDEX index_name ON table_name(column_list)
  ```

* 另外,还可以在建表时添加:

  ```sql
  CREATE TABLE mytable (
    ... //中间字段忽略
    PRIMARY KEY (`id`),
    UNIQUE KEY `unique1`(`username`), -- 索引名称,可要可不要,不要就是和列名一样
    KEY `index1` (`nickname`),
    FULLTEXT KEY `intro` (`intro`)
  ) ENGINE=MyISAMAUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COMMENT='测试表';
  ```

一张表字段有多有少，该在哪些列上创建索引呢？其实新建索引也是有一定的原则的,建什么索引,建在哪些字段上,有以下一些原则与技巧可参考：

-      在维度高或选择性差的列创建索引 说人话就是数据列中不重复值出现的个数,这个数量越高,维度就越高（如数据表中存在8行数据a,b ,c,d,a,b,c,d这个表的维度为4）。要为维度高的列创建索引,如性别和年龄,那年龄的维度就高于性别，性别这样的列不适合创建索引,因为维度过低，只有两三种值。

-      对 where,on,group by,order by  中出现的列使用索引，索引一般多设置在条件列上，显示列通常少设置索引

-      对较小的数据列使用索引 ,这样会使索引文件更小,同时内存中也可以装载更多的索引键，例如有一个字段存文本内容，新闻、资讯类那种的，内容超大，你为它设置索引就是脑袋被门夹了。

-      为较长的字符串使用前缀索引，比如有个姓名字段firstname，varchar(50)个长，可以用

```sql
alter table employee add key(firstname(5))
```

来设置前缀索引，为什么这里只取前5个字符进行索引呢？是因为可以通过

```sql
select 1.0 * count(distinct left(firstname,5)) / count(*) from employee
```

算法得到前几个字母对标数据的覆盖率，覆盖率超过31%黄金值就可以使用前缀索引。

-      使用组合索引,可以减少文件索引大小,在使用时速度要优于多个单列索引

-      索引也不是越多越好，不要过多创建索引,除了增加额外的磁盘空间外,对于DML操作的速度影响很大,因为其每增删改一次就得从新建立索引

说了创建索引，接下来就是使用索引，如果认真研读过前面的“执行计划”，SQL用到哪些索引，用了索引没有一目了然，但是有一些情况就是不会走索引，先来一些简单的示例说明：

```sql
SELECT sname FROM stu WHERE age+10=30;  --不会使用索引,因为有索引列参与了计算
SELECT sname FROM stu WHERE LEFT(`date`,4) <1990; -- 不会使用索引,因为使用了函数运算,原理与上面相同
SELECT * FROM table WHERE uname LIKE'前缀%' -- 走索引
SELECT * FROM table WHERE uname LIKE "%关键字%"-- 不走索引
SELECT * FROM table WHERE a=1 -- a列为char字符类型，用整数找不走索引，a='1'才走索引
SELECT * FROM table WHEREdname='xxx' or loc='xx' or deptno=45

-- 如果条件中有or,即使其中有条件带索引也不会使用。换言之,就是要求使用的所有字段,都必须建立索引,建议大家尽量避免使用or关键字
-- 正则表达式,regexp不走索引
-- 表中数据不多，只有几十几百条，MySQL评估使用全表扫描要比使用索引快,也不使用索引，不要大惊小怪
```

以上都是单表查询操作，多表关联查询才是业务开发的“常见姿势”，假如有一个查询：

```sql
select a,b,c from A join B join C on a=b and b=c;
```

三表join关联，假设三个表每个均有2000条记录，在没有添加索引时，则结果会进行2000*2000*2000=8000000000一共80亿次检索(因为一不小心就是一个笛卡尔乘积的恐怖扫描),只有在加了索引后，第一张表会全表扫描2000次，其余的关联表基本是range区间扫描，这样扫描次数就会降低很多很多，并且关联表时，建议多用leftjoin以少联多减少扫描次数。

有些时候发现明明创建了索引，但是因为一些原因并没有使用索引，mysql支持强制走索引,比如：

```sql
select* from table where a=1 force index(PRI，my_index) --强制主键索引和自己创建的索引
```

与之相反，还可以禁止某个索引：

```sql
select* from table where a=1 ignore index(PRI,my_index) --禁止使用索引
```

### 复合索引执行顺序

复合索引的执行顺序是有讲究的，还是以之前的案例举例：

<img src="D:\Java\笔记\图片\3-day02【MySQL约束】\12符合索引.png" style="zoom:200%;" />

表有一个主键索引及一个复合索引，复合索引名称：idx_cid，字段顺序分别是：cid,available及id

只用cid执行分析：

<img src="D:\Java\笔记\图片\3-day02【MySQL约束】\13.png" style="zoom:200%;" />

结果显示用到了idx_cid，接下来再看第二个字段的分析：

<img src="D:\Java\笔记\图片\3-day02【MySQL约束】\14.png" style="zoom:200%;" />

没有走idx_cid索引，全表扫描，接下来再看第三个的分析：

<img src="D:\Java\笔记\图片\3-day02【MySQL约束】\15.png" style="zoom:200%;" />

因为id本身就是主键，所以也不会走idx_cid索引，而是走主键索引，假设id不是主键索引，则也不会走idx_cid索引。

接下来再测试两两组合,先看cid +available组合：

<img src="D:\Java\笔记\图片\3-day02【MySQL约束】\16.png" style="zoom:200%;" />

结果显示用到了idx_cid，再看cid+id组合：

<img src="D:\Java\笔记\图片\3-day02【MySQL约束】\17.png" style="zoom:200%;" />

结果显示也用到了idx_cid，再看available+id组合：

<img src="D:\Java\笔记\图片\3-day02【MySQL约束】\18.png" style="zoom:200%;" />

结果是走的主键索引，并没有走idx_cid复合索引，于是结果很清晰了，MySQL中的复合索引有顺序，且很重要，查询条件的顺序不能随意乱写。假设A、B、C三个字段索引按A+B+C顺序创建的索引：

```sql
A --走索引
B --不走索引
C --不走索引
A + B 或 B + A -- 走索引
B + C 或 C + B -- 不走索引
A + B + C 或 B + C + A 或 C + B + A --走索引
```

小结：在复合索引中，索引第一位的column很重要，只要查询语句包含了复合索引的第一个条件,基本上就会使用到该复合索引（可能会使用其他索引）。在建复合索引的时候应该按照column的重要性从左往右建。

### 索引的坑

既然索引这么好，我们是不是应该尽可能多用索引呢？并不是。

首先，不要盲目的创建索引，应只为那些查询操作频繁的列创建索引,创建索引会使查询操作变得更加快速,但是会降低增加、删除、更新操作的速度,因为执行这些操作的同时会对索引文件进行重新排序或更新;

其次，在互联网应用中,查询的语句远远大于DML的语句,为一个大表（比如千万级数据）新建索引时是一个需要特别慎重的事情，经常出现“翻车”导致“车毁人亡”的事故，为什么？因为线上系统在被人使用，如果这时候开发或者运维人员执行一个创建索引的语句，容易导致表被锁死，所有操作排队无法被响应，时间一长容易导致业务崩溃，形成链式连锁反应，让业务蒙受巨大损失。百万或千万级数据库，大表加索引有一个比较好的方法：online-schema-change，有兴趣可自行网上搜索，此文不再赘述。

## 5.3 主键索引和普通索引区别  

1. 普通索引是最基本的索引类型，没有任何限制，值可以为空，仅加速查询。普通索引是可以重复的，一个表中可以有多个普通索引。 
2. 主键索引是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值；索引列的所有值都只能出现一次，即必须唯一。简单来说：主键索引是加速查询 + 列值唯一（不可以有null）+ 表中只有一个。 

## 5.4 联合索引

联合索引是指对表上的多个列进行索引，联合索引也是一棵B+树，不同的是联合索引的键值数量不是1，而是大于等于2.

最左匹配原则

![](D:\Java\笔记\图片\3-day02【MySQL约束】\19联合索引.png)

假定上图联合索引的为（a,b）。联合索引也是一棵B+树，不同的是B+树在对索引a排序的基础上，对索引b排序。所以数据按照（1,1),(1,2)......顺序排放。

对于`selete * from table where a=XX and b=XX`，显然是可以使用(a,b)联合索引的，

对于`selete * from table where a=XX`，也是可以使用(a,b)联合索引的。因为在这两种情况下，叶子节点中的数据都是有序的。

但是，对于b列的查询，`selete * from table where b=XX`。则不可以使用这棵B+树索引。可以发现叶子节点的b值为1,2,1,4,1,2。显然不是有序的，因此不能使用(a,b)联合索引。

By the way:`selete * from table where b=XX and a=XX`,也是可以使用到联合索引的，你可能会有疑问，这条语句并不符合最左匹配原则。这是由于查询优化器的存在，mysql查询优化器会判断纠正这条sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。所以，当然是我们能尽量的利用到索引时的查询顺序效率最高咯，所以mysql查询优化器会最终以这种顺序进行查询执行。

优化：在联合索引中将选择性最高的列放在索引最前面。

例如：在一个公司里以age 和gender为索引，显然age要放在前面，因为性别就两种选择男或女，选择性不如age。

## 5.5 什么是mysql联合索引？联合索引的本质：最左匹配

联合索引又叫复合索引。对于复合索引：Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。

### mysql联合索引原理及失效条件

当创建(col1,col2,col3)联合索引时，相当于创建了**(col)单列索引**，**(clo1,clo2)联合索引**以及**(col1,col2,col3)联合索引**。想要索引生效，只能使用**col1**和**col1,col2**和**col1,col2,col3**三种组合。当然，**col1,col3组合也可以，但实际上只用到了col1的索引，col3并没有用到**。

例如：

索引是key index (a,b,c)。可以支持a | a,b| a,b,c 3种组合进行查找，但不支持 b,c进行查找 。当最左侧字段是常量引用时，索引就十分有效。

### 图解

![](D:\Java\笔记\图片\3-day02【MySQL约束】\20联合索引.png)

### 通俗理解

两个或更多个列上的索引被称作复合索引。

利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引 不同于使用两个单独的索引。复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。如果您知 道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不姓，电话簿将没有用处。

所以说创建复合索引时，应该仔细考虑列的顺序。对索引中的所有列执行搜索或仅对前几列执行搜索时，复合索引非常有用；仅对后面的任意列执行搜索时，复合索引则没有用处。

例如：

1、只命中 col1，col2

```
SELECT * FROM `table_name` WHERE `col1`='XX';
```

2、命中col1，col2。col1，col2的顺序可以颠倒

```
SELECT * FROM `table_name` WHERE `clo1`='XX' AND `clo2`='XXX'; 
SELECT * FROM `table_name` WHERE `clo2`='XXX' AND `clo1`='XX';  
```

3、命中col1,col2,col3，同理，三个列的顺可以颠倒

```
SELECT * FROM `table_name` WHERE `col1`='X' AND `col2`='XX' AND `col3`='XXX';
SELECT * FROM `table_name` WHERE `col1`='X' AND `col3`='XX' AND `col2`='XXX';
SELECT * FROM `table_name` WHERE `col2`='X' AND `col3`='XX' AND `col1`='XXX';
```

## 二、mysql 创建或添加联合索引

ALTER TABLE可用来创建普通INDEX索引、唯一UNIQUE索引或PRIMARY KEY索引。

> ALTER TABLE table_name ADD INDEX index_name (column_list)
>
> ALTER TABLE table_name ADD UNIQUE (column_list)
>
> ALTER TABLE table_name ADD PRIMARY KEY (column_list)

例如：

```
ALTER TABLE `table_name` ADD INDEX (`col1`,`col2`,`col3`);
```

## 三、mysql联合索引优点

若一条SQL，需要多个用到两个条件或以上，例如：

```
SELECT * FROM `user_info` WHERE username='XX' AND password='XXXXXX';
```

当索引在检索 password字段的时候，数据量大大缩小，索引的命中率减小，增大了索引的效率。

复合索引的索引体积比单独索引的体积要小，而且只是一个索引树，相比单独列的索引要更加的节省时间复杂度和空间复杂度。

## 三、mysql联合索引注意事项

命名规则：表名_字段名

1、需要加索引的字段，要在where条件中

2、数据量少的字段不需要加索引

3、如果where条件中是OR关系，加索引不起作用

4、符合最左原则







5. 

# 第五章 MySQL锁

**锁是计算机协调多个进程或线程并发访问某一资源的机制**。在数据库中，除传统的 计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一 个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。本章我们着重讨论MySQL锁机制 的特点，常见的锁问题，以及解决MySQL锁问题的一些方法或建议。
Mysql用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。这些锁统称为悲观锁(Pessimistic Lock)。

## 5.1 MySQL锁概述

相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。比如，MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）；BDB存储引擎采用的是页面锁（page-level locking），但也支持表级锁；InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。

* 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
* 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
* 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适！仅从锁的角度 来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有 并发查询的应用，如一些在线事务处理（OLTP）系统。

## 5.2 MyISAM表锁

MySQL的表级锁有两种模式：**表共享读锁（Table Read Lock）**和**表独占写锁（Table Write Lock）**。

对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；对 MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作；MyISAM表的读操作与写操作之间，以及写操作之间是串行的！根据如表20-2所示的 例子可以知道，当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。

**MyISAM存储引擎的写锁阻塞读例子：**
当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\17MyISAM存储引擎的写锁阻塞读例子.png)

**MyISAM存储引擎的读锁阻塞写例子:**
一个session使用LOCK TABLE命令给表film_text加了读锁，这个session可以查询锁定表中的记录，但更新或访问其他表都会提示错误；同时，另外一个session可以查询表中的记录，但更新就会出现锁等待。

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\18MyISAM存储引擎的读锁阻塞写例子.png)

### 如何加表锁

MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作 （UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。在示例中，显式加锁基本上都是为了演示而已，并非必须如此。

给MyISAM表显示加锁，一般是为了在一定程度模拟事务操作，实现对某一时间点多个表的一致性读取。例如， 有一个订单表orders，其中记录有各订单的总金额total，同时还有一个订单明细表order_detail，其中记录有各订单每一产品的金额小计 subtotal，假设我们需要检查这两个表的金额合计是否相符，可能就需要执行如下两条SQL：

```sql
Select sum(total) from orders;
Select sum(subtotal) from order_detail;
```

这时，如果不先给两个表加锁，就可能产生错误的结果，因为第一条语句执行过程中，order_detail表可能已经发生了改变。因此，正确的方法应该是：

```sql
Lock tables orders read local, order_detail read local;
Select sum(total) from orders;
Select sum(subtotal) from order_detail;
Unlock tables;
```

要特别说明以下两点内容：
	1、上面的例子在LOCK TABLES时加了“local”选项，其作用就是在满足MyISAM表并发插入条件的情况下，允许其他用户在表尾并发插入记录，有关MyISAM表的并发插入问题，在后面还会进一步介绍。

​	2、在用LOCK TABLES给表显式加表锁时，必须同时取得所有涉及到表的锁，并且MySQL不支持锁升级。也就是说，在执行LOCK TABLES后，只能访问显式加锁的这些表，不能访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。其实，在自动加锁的 情况下也基本如此，MyISAM总是一次获得SQL语句所需要的全部锁。这也正是MyISAM表不会出现死锁（Deadlock Free）的原因。

当使用LOCK TABLES时，不仅需要一次锁定用到的所有表，而且，同一个表在SQL语句中出现多少次，就要通过与SQL语句中相同的别名锁定多少次，否则也会出错！举例说明如下。
（1）对actor表获得读锁：

```sql
mysql> lock table actor read;
Query OK, 0 rows affected (0.00 sec)
```

（2）但是通过别名访问会提示错误：

```sql
mysql> select a.first_name,a.last_name,b.first_name,b.last_name 
from actor a,actor b 
where a.first_name = b.first_name and a.first_name = 'Lisa' and a.last_name = 'Tom' 
and a.last_name <> b.last_name;
```

```sql
ERROR 1100 (HY000): Table ‘a’ was not locked with LOCK TABLES
```

（3）需要对别名分别锁定：

```sql
mysql> lock table actor as a read,actor as b read;
```

```sql
Query OK, 0 rows affected (0.00 sec)
```

（4）按照别名的查询可以正确执行：

```sql
mysql> select a.first_name,a.last_name,b.first_name,b.last_name 
from actor a,actor b where a.first_name = b.first_name 
and a.first_name = 'Lisa' and a.last_name = 'Tom' 
and a.last_name <> b.last_name;
```

```sql
+————+———–+————+———–+
| first_name | last_name | first_name | last_name |
+————+———–+————+———–+
| Lisa | Tom | LISA | MONROE |
+————+———–+————+———–+
1 row in set (0.00 sec)
```

### 查询表级锁争用情况

可以通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定争夺：

```
mysql> show status like 'table%';
```

```
Variable_name | Value
Table_locks_immediate | 2979
Table_locks_waited | 0
2 rows in set (0.00 sec))
```

如果Table_locks_waited的值比较高，则说明存在着较严重的表级锁争用情况。

### 并发插入（Concurrent Inserts）

上文提到过MyISAM表的读和写是串行的，但这是就总体而言的。在一定条件下，MyISAM表也支持查询和插入操作的并发进行。
MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0、1或2。

* 当concurrent_insert设置为0时，不允许并发插入。
* 当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置。
* 当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。

在下面的例子中，session_1获得了一个表的READ LOCAL锁，该线程可以对表进行查询操作，但不能对表进行更新操作；其他的线程（session_2），虽然不能对表进行删除和更新操作，但却可以对该表进行并发插入操作，这里假设该表中间不存在空洞。

**MyISAM存储引擎的读写（INSERT）并发例子：**

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\19MyISAM存储引擎的读写（INSERT）并发例子.png)

可以利用MyISAM存储引擎的并发插入特性，来解决应 用中对同一表查询和插入的锁争用。例如，将concurrent_insert系统变量设为2，总是允许并发插入；同时，通过定期在系统空闲时段执行 OPTIMIZE TABLE语句来整理空间碎片，收回因删除记录而产生的中间空洞。

### MyISAM的锁调度

前面讲过，MyISAM存储引擎的读锁和写锁是互斥的，读写操作是串行的。那么，一个进程请求某个 MyISAM表的读锁，同时另一个进程也请求同一表的写锁，MySQL如何处理呢？答案是写进程先获得锁。不仅如此，即使读请求先到锁等待队列，写请求后 到，写锁也会插到读锁请求之前！这是因为MySQL认为写请求一般比读请求要重要。这也正是MyISAM表不太适合于有大量更新操作和查询操作应用的原 因，因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。这种情况有时可能会变得非常糟糕！幸好我们可以通过一些设置来调节MyISAM 的调度行为。

* 通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利。
* 通过执行命令`SET LOW_PRIORITY_UPDATES=1`，使该连接发出的更新请求优先级降低。
* 通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。

虽然上面3种方法都是要么更新优先，要么查询优先的方法，但还是可以用其来解决查询相对重要的应用（如用户登录系统）中，读锁等待严重的问题。

另外，MySQL也提供了一种折中的办法来调节读写冲突，即给系统参数`max_write_lock_count`设置一个合适的值，当一个表的读锁达到这个值后，MySQL就暂时将写请求的优先级降低，给读进程一定获得锁的机会。

上面已经讨论了写优先调度机制带来的问题和解决办法。这 里还要强调一点：一些需要长时间运行的查询操作，也会使写进程“饿死”！因此，应用中应尽量避免出现长时间运行的查询操作，不要总想用一条SELECT语 句来解决问题，因为这种看似巧妙的SQL语句，往往比较复杂，执行时间较长，在可能的情况下可以通过使用中间表等措施对SQL语句做一定的“分解”，使每 一步查询都能在较短时间完成，从而减少锁冲突。如果复杂查询不可避免，应尽量安排在数据库空闲时段执行，比如一些定期统计可以安排在夜间执行。

## 5.3 InnoDB锁

InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁。行级锁与表级锁本来就有许多不同之处，另外，事务的引入也带来了一些新问题。

**1、事务（Transaction）及其ACID属性**
事务是由一组SQL语句组成的逻辑处理单元，事务具有4属性，通常称为事务的ACID属性。

* 原子性（Actomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。
* 一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。
* 隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。
* 持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

**2、并发事务带来的问题**
相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持可以支持更多的用户。但并发事务处理也会带来一些问题，主要包括以下几种情况。

* 更新丢失（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题——最后的更新覆盖了其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改保存其更改副本的编辑人员覆盖另一个编辑人员所做的修改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题。
* 脏读（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”。
* 不可重复读（Non-Repeatable Reads）：一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。
* 幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。

**3、事务隔离级别**
在并发事务处理带来的问题中，“更新丢失”通常应该是完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。

“脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。数据库实现事务隔离的方式，基本可以分为以下两种。

* 一种是在读取数据前，对其加锁，阻止其他事务对数据进行修改。
* 另一种是不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot），并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度，好像是数据库可以提供同一数据的多个版本，因此，这种技术叫做数据多版本并发控制（ＭultiVersion Concurrency Control，简称MVCC或MCC），也经常称为多版本数据库。

在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。
在一个支持MVCC并发控制的系统中，哪些读操作是快照读？哪些操作又是当前读呢？以MySQL InnoDB为例：

* 快照读：简单的select操作，属于快照读，不加锁。(当然，也有例外)

  ```sql
  select * from table where ?; 
  ```

* 当前读：特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。

  下面语句都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。

  ```sql
  select * from table where ? lock in share mode;
  select * from table where ? for update;
  insert into table values (…);
  update table set ? where ?;
  delete from table where ?;
  ```

数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上 “串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏 感，可能更关心数据并发访问的能力。

为了解决“隔离”与“并发”的矛盾，ISO/ANSI SQL92定义了4个事务隔离级别，每个级别的隔离程度不同，允许出现的副作用也不同，应用可以根据自己的业务逻辑要求，通过选择不同的隔离级别来平衡 “隔离”与“并发”的矛盾。

### 获取InonoD行锁争用情况

可以通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况：

```sql
mysql> show status like 'innodb_row_lock%';
```


如果发现锁争用比较严重，如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高，还可以通过设置InnoDB Monitors来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。

### InnoDB的行锁模式及加锁方法

InnoDB实现了以下两种类型的行锁。

* 共享锁（s）：又称读锁。允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。
* 排他锁（Ｘ）：又称写锁。允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。

对于共享锁大家可能很好理解，就是多个事务只能读数据不能改数据。

对于排他锁大家的理解可能就有些差别，我当初就犯了一个错误，以为排他锁锁住一行数据后，其他事务就不能读取和修改该行数据，其实不是这样的。排他锁指的是一个事务在一行数据加上排他锁后，其他事务不能再在其上加其他的锁。mysql InnoDB引擎默认的修改数据语句：**update,delete,insert都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型**，如果加排他锁可以使用select …for update语句，加共享锁可以使用select … lock in share mode语句。**所以加过排他锁的数据行在其他事务种是不能修改数据的，也不能通过for update和lock in share mode锁的方式查询数据，但可以直接通过select …from…查询数据，因为普通查询没有任何锁机制。**

另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。

* 意向共享锁（IS）：事务打算给数据行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
* 意向排他锁（IX）：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。

### InnoDB行锁模式兼容性列表:

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\20InnoDB行锁模式兼容性列表.png)


如果一个事务请求的锁模式与当前的锁兼容，InnoDB就请求的锁授予该事务；反之，如果两者两者不兼容，该事务就要等待锁释放。
意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁。
事务可以通过以下语句显式给记录集加共享锁或排他锁：

* 共享锁（S）：`SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE`。
* 排他锁（X）：`SELECT * FROM table_name WHERE ... FOR UPDATE`。

用`SELECT ... IN SHARE MODE`获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。**但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT… FOR UPDATE方式获得排他锁。**

### InnoDB行锁实现方式

InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，**否则，InnoDB将使用表锁！**
在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。下面通过一些实际例子来加以说明。

（1）在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。

```sql
mysql> create table tab_no_index(id int,name varchar(10)) engine=innodb;
```

```sql
Query OK, 0 rows affected (0.15 sec)
```



```sql
mysql> insert into tab_no_index values(1,'1'),(2,'2'),(3,'3'),(4,'4');
Query OK, 4 rows affected (0.00 sec)
```

```sql
Records: 4 Duplicates: 0 Warnings: 0
```

在上面的例子中，看起来session_1只给一行加了排他锁，但session_2在请求其他行的排他锁时，却出现了锁等待！原因就是在没有索引的情况下，InnoDB只能使用表锁。当我们给其增加一个索引后，InnoDB就只锁定了符合条件的行，如下例所示：
创建tab_with_index表，id字段有普通索引：

```
mysql> create table tab_with_index(id int,name varchar(10)) engine=innodb;
mysql> alter table tab_with_index add index id(id);
```

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\22.png)

（2）由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。应用设计的时候要注意这一点。
在下面的例子中，表tab_with_index的id字段有索引，name字段没有索引：

```
mysql> alter table tab_with_index drop index name;
```

```
Query OK, 4 rows affected (0.22 sec) Records: 4 Duplicates: 0
Warnings: 0
```



```
mysql> insert into tab_with_index  values(1,'4');
```

```
Query OK, 1 row affected (0.00 sec)
```



```
mysql> select * from tab_with_index where id = 1;
```

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\23.png)

InnoDB存储引擎使用相同索引键的阻塞例子

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\24InnoDB存储引擎使用相同索引键的阻塞例子.png)


（3）当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。
在下面的例子中，表tab_with_index的id字段有主键索引，name字段有普通索引：

```
mysql> alter table tab_with_index add index name(name);
```

```
Query OK, 5 rows affected (0.23 sec) Records: 5 Duplicates: 0
Warnings: 0
```

**InnoDB存储引擎的表使用不同索引的阻塞例子**

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\25InnoDB存储引擎的表使用不同索引的阻塞例子.png)

（4）即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决 定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突 时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。

比如，在tab_with_index表里的name字段有索引，但是name字段是varchar类型的，检索值的数据类型与索引字段不同，虽然MySQL能够进行数据类型转换，但却不会使用索引，从而导致InnoDB使用表锁。通过用explain检查两条SQL的执行计划，我们可以清楚地看到了这一点。

```
mysql> explain select * from tab_with_index where name = 1 \G
mysql> explain select * from tab_with_index where name = '1' \G
```

### 间隙锁（Next-Key锁）

当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的 索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁 （Next-Key锁）。
举例来说，假如emp表中只有101条记录，其empid的值分别是 1,2,…,100,101，下面的SQL：

```
Select * from  emp where empid > 100 for update;
```

是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。

InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使 用间隙锁，如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另外一方面，是为了满足其恢复和复制的需 要。有关其恢复和复制对锁机制的影响，以及不同隔离级别下InnoDB使用间隙锁的情况，在后续的章节中会做进一步介绍。

很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。**因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。**

还要特别说明的是，InnoDB除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用间隙锁！下面这个例子假设emp表中只有101条记录，其empid的值分别是1,2,……,100,101。
InnoDB存储引擎的间隙锁阻塞例子

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\26InnoDB存储引擎的间隙锁阻塞例子.png)

## 5.4 小结

本文重点介绍了MySQL中MyISAM表级锁和InnoDB行级锁的实现特点，并讨论了两种存储引擎经常遇到的锁问题和解决办法。

**对于MyISAM的表锁，主要讨论了以下几点：**

1. 共享读锁（S）之间是兼容的，但共享读锁（S）与排他写锁（X）之间，以及排他写锁（X）之间是互斥的，也就是说读和写是串行的。
2. 在一定条件下，MyISAM允许查询和插入并发执行，我们可以利用这一点来解决应用中对同一表查询和插入的锁争用问题。
3. MyISAM默认的锁调度机制是写优先，这并不一定适合所有应用，用户可以通过设置LOW_PRIORITY_UPDATES参数，或在INSERT、UPDATE、DELETE语句中指定LOW_PRIORITY选项来调节读写锁的争用。
4. 由于表锁的锁定粒度大，读写之间又是串行的，因此，如果更新操作较多，MyISAM表可能会出现严重的锁等待，可以考虑采用InnoDB表来减少锁冲突。

**对于InnoDB表，本文主要讨论了以下几项内容：**

1. InnoDB的行锁是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁。
2. 介绍了InnoDB间隙锁（Next-key)机制，以及InnoDB使用间隙锁的原因。
3. 在不同的隔离级别下，InnoDB的锁机制和一致性读策略不同。

**在了解InnoDB锁特性后，用户可以通过设计和SQL调整等措施减少锁冲突和死锁，包括：**

* 尽量使用较低的隔离级别； 精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会；
* 选择合理的事务大小，小事务发生锁冲突的几率也更小；
* 给记录集显式加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁；
* 不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会；
* 尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响； 不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁；
* 对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。



# 第六章 存储结构体

## 4.1 什么是存储过程？

> 在mysql中，存储过程是一组为了完成特定功能的SQL语句集合。一个存储过程是一个可编程的函数，它在数据库中创建并保存，一般由SQL语句和一些特殊的控制结构组成。使用存储过程不仅可以提高数据库的访问效率，同时也可以提高数据库使用的安全性。

存储过程是一组为了完成特定功能的 SQL 语句集合。使用存储过程的目的是将常用或复杂的工作预先用 SQL 语句写好并用一个指定名称存储起来，这个过程经编译和优化后存储在数据库服务器中，因此称为存储过程。当以后需要数据库提供与已定义好的存储过程的功能相同的服务时，只需调用“CALL存储过程名字”即可自动完成。

常用操作数据库的 SQL 语句在执行的时候需要先编译，然后执行。存储过程则采用另一种方式来执行 SQL 语句。

一个存储过程是一个可编程的函数，它在数据库中创建并保存，一般由 SQL 语句和一些特殊的控制结构组成。当希望在不同的应用程序或平台上执行相同的特定功能时，存储过程尤为合适。

MySQL 5.0 版本以前并不支持存储过程，这使 MySQL 在应用上大打折扣。MySQL 从 5.0 版本开始支持存储过程，既提高了数据库的处理速度，同时也提高了数据库编程的灵活性

存储过程是数据库中的一个重要功能，存储过程可以用来转换数据、数据迁移、制作报表，它类似于编程语言，一次执行成功，就可以随时被调用，完成指定的功能操作。

使用存储过程不仅可以提高数据库的访问效率，同时也可以提高数据库使用的安全性。

**相对于直接使用SQL 语句，在应用程序中直接调用存储过程有以下好处：**

(1)减少网络通信量。

调用一个行数不多的存储过程与直接调用SQL 语句的网络通信量可能不会有很大的差别，可是如果存储过程包含上百行SQL 语句，那么其性能绝对比一条一条的调用SQL 语句要高得多。

(2)执行速度更快。

有两个原因：首先，在存储过程创建的时候，数据库已经对其进行了一次解析和优化。其次，存储过程一旦执行，在内存中就会保留一份这个存储过程，这样下次再执行同样的存储过程时，可以从内存中直接调用。

(3)更强的适应性。

由于存储过程对数据库的访问是通过存储过程来进行的，因此数据库开发人员可以在不改动存储过程接口的情况下对数据库进行任何改动，而这些改动不会对应用程序造成影响。

(4) 分布式工作。

应用程序和数据库的编码工作可以分别独立进行，而不会相互压制。

## 4.2 存储过程优点

1. **增强SQL语言的功能和灵活性**：存储过程可以用控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。

2. **标准组件式编程**：存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，对应用程序源代码毫无影响。

3. **较快的执行速度**：如果某一操作包含大量的Transaction-SQL代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transaction-SQL语句在每次运行时都要进行编译和优化，速度相对要慢一些。

4. **减少网络流量**：针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的Transaction-SQL语句被组织进存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大减少网络流量并降低了网络负载。

5. **作为一种安全机制来充分利用**：通过对执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。

