

# 第四章 索引

## 1.1 导入

> 字段也就是列

假设我们有一张数据表 `employee(员工表)`，该表有三个字段（列）,分别是`name`、`age` 和`address`。假设表`employee`有上万行数据，现在需要从这个表中查找出所有名字是`‘ZhangSan’`的雇员信息，你会快速的写出SQL语句：

```sql
select name,age,address from employee where name='ZhangSan'
```

如果数据库还没有索引这个东西，一旦我们运行这个SQL查询，查找名字为`ZhangSan`的雇员的过程中，究竟会发生什么？

- 数据库不得不在`employee`表中的每一行查找并确定雇员的名字`（name）`是否为`‘ZhangSan’`。

- 由于我们想要得到每一个名字为`ZhangSan`的雇员信息，在查询到第一个符合条件的行后，不能停止查询，因为可能还有其他符合条件的行，所以必须一行一行的查找直到最后一行——这就意味数据库不得不检查上万行数据才能找到所有名字为`ZhangSan`的雇员。这就是所谓的全表扫描，显然这种模式效率太慢。


## 1.2 索引介绍

你会想为如此简单的事情做全表扫描效率欠佳——数据库是不是应该更聪明一点呢？“索引”派上用场的时候到了，使用索引的全部意义就是：**通过缩小一张表中需要查询的记录/行的数目来加快搜索的速度。**

在关系型数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单（定义真特么拗口）。**大白话意思是索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。**

一个索引是存储的表中一个特定列的值数据结构。**索引是在表的列上创建。要记住的关键点是索引包含一个表中列的值，并且这些值存储在一个数据结构中。请牢记这一点：<font color = "red">索引是一种数据结构。</font>**

一个好的数据库表设计,从一开始就应该考虑添加索引,而不是到最后发现慢SQL了,影响业务了才来补救。

在没有GUI工具的情况下，可以使用以下命令查看索引：

<img src="D:\Java\笔记\图片\3-day02【MySQL约束】\7索引.png" style="zoom:150%;" />

上述`ad_article`表中有两个索引，`Key_name`中有显示:

-  `PRIMARY`主键索引，`Seq_in_index`索引序号为1，从1开始，`Collation`为“A”表示升序（或NULL无分类），对应字段是id

-  `idx_cid`是自建索引，由`cid`、`available`、`id`三个字段组成，分别对应序号1,2,3

表中大部分信息都挺好理解的，倒是`Index_type=BTREE`这块内容很多人不懂其意思，其实通过GUI工具创建索引时也会有`BTREE` 的显示，先着重了解一下。

### Cardinality 索引基数

<img src="D:\Java\笔记\图片\3-day02【MySQL约束】\7索引.png" style="zoom:150%;" />

说完`BTREE`，在`'show index from ad_article'`结果集中有一列为`Cardinality`的值，它的作用也非常的大，称之为：**索引基数**

索引基数简单的说就是:**你索引列的唯一值的个数，如果是复合索引就是唯一组合的个数**。

这个数值将会作为MySQL优化器对语句执行计划进行判定时依据。如果唯一性太小，那么优化器会认为这个索引对语句没有太大帮助，而不使用索引。`cardinality`值越大，就意味着，使用索引能排除越多的数据，执行也更为高效。

举个简单例子来说明：比如有一张表有A、B、C列，数据情况如下：

```asciiarmor
A    B    C
1    1    1
1    1    2
1    2    1
1    2    2
2    1    1
2    1    2
2    2    1
2    2    2
```

-      如果对A列进行索引，那么它的`cardinality`基数值为2，因为只有1，2两种值

-      如果对A、B两列做复合索引，那么它的`cardinality`基数值为4，因为值的组合为(11),(1 2),(2 1),(2 2)

-      如果对A、B、C做复合索引，则它的`cardinality`基数值为8

> 当有多个索引可用时，mysql会自动依据`cardinality`大的值来进行SQL索引选择优化。
>
> 如果现在再问你“为什么数据库都有PK”，你怎么答?
> 		因为PK的数据均不一样啊，做索引了后查询起来效果才快啊，因为`cardinality`值很高，是不是？
>
> 另一种问法常见于判断题，问你“数据库索引通常要放在选择性差的列上”，
> 		你以前可能还不明白为什么，其背后逻辑就是索引的`cardinality`值啊，选择性差意味着重复数据少，索引才高效嘛。

回到我们自己的例子，数据库中有数据值61行，但是`cardinality=59`并不准确，是因为它不会自动更新，需要通过`analyzetable`来进行更新，示例如下：

```sql
mysql>analyze local table ad_article;
```

优化以后结果为：

<img src="D:\Java\笔记\图片\3-day02【MySQL约束】\11优化.png" style="zoom:200%;" />

索引基数更加准确一些了。

## 1.3 索引类型

MySQL中有以下索引类型：

* <font color = "red">UNIQUE唯一索引</font>
* <font color = "red">INDEX普通索引</font>
* <font color = "red">PRIMARY KEY主键索引</font>
* <font color = "red">fulltext index 全文索引</font>

### UNIQUE唯一索引

`UNIQUE`唯一索引：该索引其含义是被标定义唯一索引的列，不允许出现重复的数据， 但可以有NULL值。举例来讲,假如有A、B两个字段，建立唯一索引：

```java
A  B
1  1
1  2
1  1  // 这一行数据无法插入，因为与第一条数据重复，数据库底层报错DuplicateKeyException 1 1
```

唯一索引有利有弊，好处是：如果你的程序不好处理界面端的重复提交，或者因为数据的重复导致程序出错误，可以通过创建唯一索引来解决问题，当然不要为了设置唯一索引而设置索引，索引还是要有用处的。

其次在设置了唯一索引时，万一真要发生变更，支持重复数据怎么办?MySQL提供了两种补救办法：

-      自动替换为新的值：可以用`ONDUPLICATE KEY UPDATE xxx= VALUES(xxx)`

-      忽略插入： `insert ignore into`

### INDEX普通索引

`INDEX`普通索引：允许出现相同的索引内容，平时创建的索引通常就是普通索引，利用提升查询数据性能

普通索引是最基本的索引类型，而且它没有唯一性之类的限制。普通索引可以通过以下几种方式创建：  

创建索引，例如  

```sql
CREATE INDEX <索引的名字> ON tablename (列的列表);  
```

修改表，例如  

```SQL
ALTER TABLE tablename ADD INDEX [索引的名字] (列的列表);  
```

创建表的时候指定索引，例如  

```SQL
CREATE TABLE tablename ( [...], INDEX [索引的名字] (列的列表) );  
```

### PRIMARY KEY主键索引

`PRIMARY KEY`主键索引：不允许出现相同的值,且不能为NULL值,一个表只能有一个`primary_key`索引，常见于ID字段。

主键是一种唯一性索引，但它必须指定为`“PRIMARY KEY”`。  

主键一般在创建表的时候指定，例如  

```SQL
CREATE TABLE tablename ( [...], PRIMARY KEY (列的列表) );  
```

但是，我们也可以通过修改表的方式加入主键，例如`“ALTER TABLE tablename ADD PRIMARY KEY (列的列表); ”`。每个表只能有一个主键。 

### fulltext index 全文索引

上述三种索引都是针对列的值发挥作用,但全文索引,可以针对值中的某个单词,比如一篇文章中的某个词,然而并没有什么卵用,因为只有`myisam`引擎以及英文支持,并且效率让人不敢恭维,要全文搜索还是建议使用`Luence`、`Solr`、`ES`等方案，更专业且强大一些。

## 1.4 索引的创建与使用

* `ALTER TABLE` 适用于表创建完毕之后再添加

  ```sql
  ALTERTABLE 表名 ADD 索引类型 （unique,primary key,fulltext,index）[索引名]（字段名）
  ```

* `CREATE INDEX`可对表增加普通索引或`UNIQUE`索引

  ```sql
  CREATE INDEXindex_name ON table_name (column_list)
  ```

  ```sql
  CREATE UNIQUE INDEX index_name ON table_name(column_list)
  ```

* 另外,还可以在建表时添加:

  ```sql
  CREATE TABLE mytable (
    ... //中间字段忽略
    PRIMARY KEY (`id`),
    UNIQUE KEY `unique1`(`username`), -- 索引名称,可要可不要,不要就是和列名一样
    KEY `index1` (`nickname`),
    FULLTEXT KEY `intro` (`intro`)
  ) ENGINE=MyISAMAUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COMMENT='测试表';
  ```

一张表字段有多有少，该在哪些列上创建索引呢？其实新建索引也是有一定的原则的,建什么索引,建在哪些字段上,有以下一些原则与技巧可参考：

-      在维度高或选择性差的列创建索引 说人话就是数据列中不重复值出现的个数,这个数量越高,维度就越高（如数据表中存在8行数据a,b ,c,d,a,b,c,d这个表的维度为4）。要为维度高的列创建索引,如性别和年龄,那年龄的维度就高于性别，性别这样的列不适合创建索引,因为维度过低，只有两三种值。

-      对 where,on,group by,order by  中出现的列使用索引，索引一般多设置在条件列上，显示列通常少设置索引

-      对较小的数据列使用索引 ,这样会使索引文件更小,同时内存中也可以装载更多的索引键，例如有一个字段存文本内容，新闻、资讯类那种的，内容超大，你为它设置索引就是脑袋被门夹了。

-      为较长的字符串使用前缀索引，比如有个姓名字段firstname，varchar(50)个长，可以用

```sql
alter table employee add key(firstname(5))
```

来设置前缀索引，为什么这里只取前5个字符进行索引呢？是因为可以通过

```sql
select 1.0 * count(distinct left(firstname,5)) / count(*) from employee
```

算法得到前几个字母对标数据的覆盖率，覆盖率超过31%黄金值就可以使用前缀索引。

-      使用组合索引,可以减少文件索引大小,在使用时速度要优于多个单列索引

-      索引也不是越多越好，不要过多创建索引,除了增加额外的磁盘空间外,对于DML操作的速度影响很大,因为其每增删改一次就得从新建立索引

说了创建索引，接下来就是使用索引，如果认真研读过前面的“执行计划”，SQL用到哪些索引，用了索引没有一目了然，但是有一些情况就是不会走索引，先来一些简单的示例说明：

```sql
SELECT sname FROM stu WHERE age+10=30;  --不会使用索引,因为有索引列参与了计算
SELECT sname FROM stu WHERE LEFT(`date`,4) <1990; -- 不会使用索引,因为使用了函数运算,原理与上面相同
SELECT * FROM table WHERE uname LIKE'前缀%' -- 走索引
SELECT * FROM table WHERE uname LIKE "%关键字%"-- 不走索引
SELECT * FROM table WHERE a=1 -- a列为char字符类型，用整数找不走索引，a='1'才走索引
SELECT * FROM table WHEREdname='xxx' or loc='xx' or deptno=45

-- 如果条件中有or,即使其中有条件带索引也不会使用。换言之,就是要求使用的所有字段,都必须建立索引,建议大家尽量避免使用or关键字
-- 正则表达式,regexp不走索引
-- 表中数据不多，只有几十几百条，MySQL评估使用全表扫描要比使用索引快,也不使用索引，不要大惊小怪
```

以上都是单表查询操作，多表关联查询才是业务开发的“常见姿势”，假如有一个查询：

```sql
select a,b,c from A join B join C on a=b and b=c;
```

三表join关联，假设三个表每个均有2000条记录，在没有添加索引时，则结果会进行2000*2000*2000=8000000000一共80亿次检索(因为一不小心就是一个笛卡尔乘积的恐怖扫描),只有在加了索引后，第一张表会全表扫描2000次，其余的关联表基本是range区间扫描，这样扫描次数就会降低很多很多，并且关联表时，建议多用leftjoin以少联多减少扫描次数。

有些时候发现明明创建了索引，但是因为一些原因并没有使用索引，mysql支持强制走索引,比如：

```sql
select* from table where a=1 force index(PRI，my_index) --强制主键索引和自己创建的索引
```

与之相反，还可以禁止某个索引：

```sql
select* from table where a=1 ignore index(PRI,my_index) --禁止使用索引
```

### 复合索引执行顺序

复合索引的执行顺序是有讲究的，还是以之前的案例举例：

<img src="D:\Java\笔记\图片\3-day02【MySQL约束】\12符合索引.png" style="zoom:200%;" />

表有一个主键索引及一个复合索引，复合索引名称：idx_cid，字段顺序分别是：cid,available及id

只用cid执行分析：

<img src="D:\Java\笔记\图片\3-day02【MySQL约束】\13.png" style="zoom:200%;" />

结果显示用到了idx_cid，接下来再看第二个字段的分析：

<img src="D:\Java\笔记\图片\3-day02【MySQL约束】\14.png" style="zoom:200%;" />

没有走idx_cid索引，全表扫描，接下来再看第三个的分析：

<img src="D:\Java\笔记\图片\3-day02【MySQL约束】\15.png" style="zoom:200%;" />

因为id本身就是主键，所以也不会走idx_cid索引，而是走主键索引，假设id不是主键索引，则也不会走idx_cid索引。

接下来再测试两两组合,先看cid +available组合：

<img src="D:\Java\笔记\图片\3-day02【MySQL约束】\16.png" style="zoom:200%;" />

结果显示用到了idx_cid，再看cid+id组合：

<img src="D:\Java\笔记\图片\3-day02【MySQL约束】\17.png" style="zoom:200%;" />

结果显示也用到了idx_cid，再看available+id组合：

<img src="D:\Java\笔记\图片\3-day02【MySQL约束】\18.png" style="zoom:200%;" />

结果是走的主键索引，并没有走idx_cid复合索引，于是结果很清晰了，MySQL中的复合索引有顺序，且很重要，查询条件的顺序不能随意乱写。假设A、B、C三个字段索引按A+B+C顺序创建的索引：

```sql
A --走索引
B --不走索引
C --不走索引
A + B 或 B + A -- 走索引
B + C 或 C + B -- 不走索引
A + B + C 或 B + C + A 或 C + B + A --走索引
```

小结：在复合索引中，索引第一位的column很重要，只要查询语句包含了复合索引的第一个条件,基本上就会使用到该复合索引（可能会使用其他索引）。在建复合索引的时候应该按照column的重要性从左往右建。

### 索引的坑

既然索引这么好，我们是不是应该尽可能多用索引呢？并不是。

首先，不要盲目的创建索引，应只为那些查询操作频繁的列创建索引,创建索引会使查询操作变得更加快速,但是会降低增加、删除、更新操作的速度,因为执行这些操作的同时会对索引文件进行重新排序或更新;

其次，在互联网应用中,查询的语句远远大于DML的语句,为一个大表（比如千万级数据）新建索引时是一个需要特别慎重的事情，经常出现“翻车”导致“车毁人亡”的事故，为什么？因为线上系统在被人使用，如果这时候开发或者运维人员执行一个创建索引的语句，容易导致表被锁死，所有操作排队无法被响应，时间一长容易导致业务崩溃，形成链式连锁反应，让业务蒙受巨大损失。百万或千万级数据库，大表加索引有一个比较好的方法：online-schema-change，有兴趣可自行网上搜索，此文不再赘述。

## 5.3 主键索引和普通索引区别  

1. 普通索引是最基本的索引类型，没有任何限制，值可以为空，仅加速查询。普通索引是可以重复的，一个表中可以有多个普通索引。 
2. 主键索引是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值；索引列的所有值都只能出现一次，即必须唯一。简单来说：主键索引是加速查询 + 列值唯一（不可以有null）+ 表中只有一个。 

## 5.4 联合索引

联合索引是指对表上的多个列进行索引，联合索引也是一棵B+树，不同的是联合索引的键值数量不是1，而是大于等于2.

最左匹配原则

![](D:\Java\笔记\图片\3-day02【MySQL约束】\19联合索引.png)

假定上图联合索引的为（a,b）。联合索引也是一棵B+树，不同的是B+树在对索引a排序的基础上，对索引b排序。所以数据按照（1,1),(1,2)......顺序排放。

对于`selete * from table where a=XX and b=XX`，显然是可以使用(a,b)联合索引的，

对于`selete * from table where a=XX`，也是可以使用(a,b)联合索引的。因为在这两种情况下，叶子节点中的数据都是有序的。

但是，对于b列的查询，`selete * from table where b=XX`。则不可以使用这棵B+树索引。可以发现叶子节点的b值为1,2,1,4,1,2。显然不是有序的，因此不能使用(a,b)联合索引。

By the way:`selete * from table where b=XX and a=XX`,也是可以使用到联合索引的，你可能会有疑问，这条语句并不符合最左匹配原则。这是由于查询优化器的存在，mysql查询优化器会判断纠正这条sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。所以，当然是我们能尽量的利用到索引时的查询顺序效率最高咯，所以mysql查询优化器会最终以这种顺序进行查询执行。

优化：在联合索引中将选择性最高的列放在索引最前面。

例如：在一个公司里以age 和gender为索引，显然age要放在前面，因为性别就两种选择男或女，选择性不如age。

## 5.5 什么是mysql联合索引？联合索引的本质：最左匹配

联合索引又叫复合索引。对于复合索引：Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。

### mysql联合索引原理及失效条件

当创建(col1,col2,col3)联合索引时，相当于创建了**(col)单列索引**，**(clo1,clo2)联合索引**以及**(col1,col2,col3)联合索引**。想要索引生效，只能使用**col1**和**col1,col2**和**col1,col2,col3**三种组合。当然，**col1,col3组合也可以，但实际上只用到了col1的索引，col3并没有用到**。

例如：

索引是key index (a,b,c)。可以支持a | a,b| a,b,c 3种组合进行查找，但不支持 b,c进行查找 。当最左侧字段是常量引用时，索引就十分有效。

### 图解

![](D:\Java\笔记\图片\3-day02【MySQL约束】\20联合索引.png)

### 通俗理解

两个或更多个列上的索引被称作复合索引。

利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引 不同于使用两个单独的索引。复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。如果您知 道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不姓，电话簿将没有用处。

所以说创建复合索引时，应该仔细考虑列的顺序。对索引中的所有列执行搜索或仅对前几列执行搜索时，复合索引非常有用；仅对后面的任意列执行搜索时，复合索引则没有用处。

例如：

1、只命中 col1，col2

```
SELECT * FROM `table_name` WHERE `col1`='XX';
```

2、命中col1，col2。col1，col2的顺序可以颠倒

```
SELECT * FROM `table_name` WHERE `clo1`='XX' AND `clo2`='XXX'; 
SELECT * FROM `table_name` WHERE `clo2`='XXX' AND `clo1`='XX';  
```

3、命中col1,col2,col3，同理，三个列的顺可以颠倒

```
SELECT * FROM `table_name` WHERE `col1`='X' AND `col2`='XX' AND `col3`='XXX';
SELECT * FROM `table_name` WHERE `col1`='X' AND `col3`='XX' AND `col2`='XXX';
SELECT * FROM `table_name` WHERE `col2`='X' AND `col3`='XX' AND `col1`='XXX';
```

## 二、mysql 创建或添加联合索引

ALTER TABLE可用来创建普通INDEX索引、唯一UNIQUE索引或PRIMARY KEY索引。

> ALTER TABLE table_name ADD INDEX index_name (column_list)
>
> ALTER TABLE table_name ADD UNIQUE (column_list)
>
> ALTER TABLE table_name ADD PRIMARY KEY (column_list)

例如：

```
ALTER TABLE `table_name` ADD INDEX (`col1`,`col2`,`col3`);
```

## 三、mysql联合索引优点

若一条SQL，需要多个用到两个条件或以上，例如：

```
SELECT * FROM `user_info` WHERE username='XX' AND password='XXXXXX';
```

当索引在检索 password字段的时候，数据量大大缩小，索引的命中率减小，增大了索引的效率。

复合索引的索引体积比单独索引的体积要小，而且只是一个索引树，相比单独列的索引要更加的节省时间复杂度和空间复杂度。

## 三、mysql联合索引注意事项

命名规则：表名_字段名

1、需要加索引的字段，要在where条件中

2、数据量少的字段不需要加索引

3、如果where条件中是OR关系，加索引不起作用

4、符合最左原则







5. 

# 第五章 MySQL锁

**锁是计算机协调多个进程或线程并发访问某一资源的机制**。在数据库中，除传统的 计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一 个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。本章我们着重讨论MySQL锁机制 的特点，常见的锁问题，以及解决MySQL锁问题的一些方法或建议。
Mysql用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。这些锁统称为悲观锁(Pessimistic Lock)。

## 5.1 MySQL锁概述

相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。比如，MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）；BDB存储引擎采用的是页面锁（page-level locking），但也支持表级锁；InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。

* 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
* 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
* 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适！仅从锁的角度 来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有 并发查询的应用，如一些在线事务处理（OLTP）系统。

## 5.2 MyISAM表锁

MySQL的表级锁有两种模式：**表共享读锁（Table Read Lock）**和**表独占写锁（Table Write Lock）**。

对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；对 MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作；MyISAM表的读操作与写操作之间，以及写操作之间是串行的！根据如表20-2所示的 例子可以知道，当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。

**MyISAM存储引擎的写锁阻塞读例子：**
当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\17MyISAM存储引擎的写锁阻塞读例子.png)

**MyISAM存储引擎的读锁阻塞写例子:**
一个session使用LOCK TABLE命令给表film_text加了读锁，这个session可以查询锁定表中的记录，但更新或访问其他表都会提示错误；同时，另外一个session可以查询表中的记录，但更新就会出现锁等待。

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\18MyISAM存储引擎的读锁阻塞写例子.png)

### 如何加表锁

MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作 （UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。在示例中，显式加锁基本上都是为了演示而已，并非必须如此。

给MyISAM表显示加锁，一般是为了在一定程度模拟事务操作，实现对某一时间点多个表的一致性读取。例如， 有一个订单表orders，其中记录有各订单的总金额total，同时还有一个订单明细表order_detail，其中记录有各订单每一产品的金额小计 subtotal，假设我们需要检查这两个表的金额合计是否相符，可能就需要执行如下两条SQL：

```sql
Select sum(total) from orders;
Select sum(subtotal) from order_detail;
```

这时，如果不先给两个表加锁，就可能产生错误的结果，因为第一条语句执行过程中，order_detail表可能已经发生了改变。因此，正确的方法应该是：

```sql
Lock tables orders read local, order_detail read local;
Select sum(total) from orders;
Select sum(subtotal) from order_detail;
Unlock tables;
```

要特别说明以下两点内容：
	1、上面的例子在LOCK TABLES时加了“local”选项，其作用就是在满足MyISAM表并发插入条件的情况下，允许其他用户在表尾并发插入记录，有关MyISAM表的并发插入问题，在后面还会进一步介绍。

​	2、在用LOCK TABLES给表显式加表锁时，必须同时取得所有涉及到表的锁，并且MySQL不支持锁升级。也就是说，在执行LOCK TABLES后，只能访问显式加锁的这些表，不能访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。其实，在自动加锁的 情况下也基本如此，MyISAM总是一次获得SQL语句所需要的全部锁。这也正是MyISAM表不会出现死锁（Deadlock Free）的原因。

当使用LOCK TABLES时，不仅需要一次锁定用到的所有表，而且，同一个表在SQL语句中出现多少次，就要通过与SQL语句中相同的别名锁定多少次，否则也会出错！举例说明如下。
（1）对actor表获得读锁：

```sql
mysql> lock table actor read;
Query OK, 0 rows affected (0.00 sec)
```

（2）但是通过别名访问会提示错误：

```sql
mysql> select a.first_name,a.last_name,b.first_name,b.last_name 
from actor a,actor b 
where a.first_name = b.first_name and a.first_name = 'Lisa' and a.last_name = 'Tom' 
and a.last_name <> b.last_name;
```

```sql
ERROR 1100 (HY000): Table ‘a’ was not locked with LOCK TABLES
```

（3）需要对别名分别锁定：

```sql
mysql> lock table actor as a read,actor as b read;
```

```sql
Query OK, 0 rows affected (0.00 sec)
```

（4）按照别名的查询可以正确执行：

```sql
mysql> select a.first_name,a.last_name,b.first_name,b.last_name 
from actor a,actor b where a.first_name = b.first_name 
and a.first_name = 'Lisa' and a.last_name = 'Tom' 
and a.last_name <> b.last_name;
```

```sql
+————+———–+————+———–+
| first_name | last_name | first_name | last_name |
+————+———–+————+———–+
| Lisa | Tom | LISA | MONROE |
+————+———–+————+———–+
1 row in set (0.00 sec)
```

### 查询表级锁争用情况

可以通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定争夺：

```
mysql> show status like 'table%';
```

```
Variable_name | Value
Table_locks_immediate | 2979
Table_locks_waited | 0
2 rows in set (0.00 sec))
```

如果Table_locks_waited的值比较高，则说明存在着较严重的表级锁争用情况。

### 并发插入（Concurrent Inserts）

上文提到过MyISAM表的读和写是串行的，但这是就总体而言的。在一定条件下，MyISAM表也支持查询和插入操作的并发进行。
MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0、1或2。

* 当concurrent_insert设置为0时，不允许并发插入。
* 当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置。
* 当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。

在下面的例子中，session_1获得了一个表的READ LOCAL锁，该线程可以对表进行查询操作，但不能对表进行更新操作；其他的线程（session_2），虽然不能对表进行删除和更新操作，但却可以对该表进行并发插入操作，这里假设该表中间不存在空洞。

**MyISAM存储引擎的读写（INSERT）并发例子：**

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\19MyISAM存储引擎的读写（INSERT）并发例子.png)

可以利用MyISAM存储引擎的并发插入特性，来解决应 用中对同一表查询和插入的锁争用。例如，将concurrent_insert系统变量设为2，总是允许并发插入；同时，通过定期在系统空闲时段执行 OPTIMIZE TABLE语句来整理空间碎片，收回因删除记录而产生的中间空洞。

### MyISAM的锁调度

前面讲过，MyISAM存储引擎的读锁和写锁是互斥的，读写操作是串行的。那么，一个进程请求某个 MyISAM表的读锁，同时另一个进程也请求同一表的写锁，MySQL如何处理呢？答案是写进程先获得锁。不仅如此，即使读请求先到锁等待队列，写请求后 到，写锁也会插到读锁请求之前！这是因为MySQL认为写请求一般比读请求要重要。这也正是MyISAM表不太适合于有大量更新操作和查询操作应用的原 因，因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。这种情况有时可能会变得非常糟糕！幸好我们可以通过一些设置来调节MyISAM 的调度行为。

* 通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利。
* 通过执行命令`SET LOW_PRIORITY_UPDATES=1`，使该连接发出的更新请求优先级降低。
* 通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。

虽然上面3种方法都是要么更新优先，要么查询优先的方法，但还是可以用其来解决查询相对重要的应用（如用户登录系统）中，读锁等待严重的问题。

另外，MySQL也提供了一种折中的办法来调节读写冲突，即给系统参数`max_write_lock_count`设置一个合适的值，当一个表的读锁达到这个值后，MySQL就暂时将写请求的优先级降低，给读进程一定获得锁的机会。

上面已经讨论了写优先调度机制带来的问题和解决办法。这 里还要强调一点：一些需要长时间运行的查询操作，也会使写进程“饿死”！因此，应用中应尽量避免出现长时间运行的查询操作，不要总想用一条SELECT语 句来解决问题，因为这种看似巧妙的SQL语句，往往比较复杂，执行时间较长，在可能的情况下可以通过使用中间表等措施对SQL语句做一定的“分解”，使每 一步查询都能在较短时间完成，从而减少锁冲突。如果复杂查询不可避免，应尽量安排在数据库空闲时段执行，比如一些定期统计可以安排在夜间执行。

## 5.3 InnoDB锁

InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁。行级锁与表级锁本来就有许多不同之处，另外，事务的引入也带来了一些新问题。

**1、事务（Transaction）及其ACID属性**
事务是由一组SQL语句组成的逻辑处理单元，事务具有4属性，通常称为事务的ACID属性。

* 原子性（Actomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。
* 一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。
* 隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。
* 持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

**2、并发事务带来的问题**
相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持可以支持更多的用户。但并发事务处理也会带来一些问题，主要包括以下几种情况。

* 更新丢失（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题——最后的更新覆盖了其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改保存其更改副本的编辑人员覆盖另一个编辑人员所做的修改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题。
* 脏读（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”。
* 不可重复读（Non-Repeatable Reads）：一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。
* 幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。

**3、事务隔离级别**
在并发事务处理带来的问题中，“更新丢失”通常应该是完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。

“脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。数据库实现事务隔离的方式，基本可以分为以下两种。

* 一种是在读取数据前，对其加锁，阻止其他事务对数据进行修改。
* 另一种是不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot），并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度，好像是数据库可以提供同一数据的多个版本，因此，这种技术叫做数据多版本并发控制（ＭultiVersion Concurrency Control，简称MVCC或MCC），也经常称为多版本数据库。

在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。
在一个支持MVCC并发控制的系统中，哪些读操作是快照读？哪些操作又是当前读呢？以MySQL InnoDB为例：

* 快照读：简单的select操作，属于快照读，不加锁。(当然，也有例外)

  ```sql
  select * from table where ?; 
  ```

* 当前读：特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。

  下面语句都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。

  ```sql
  select * from table where ? lock in share mode;
  select * from table where ? for update;
  insert into table values (…);
  update table set ? where ?;
  delete from table where ?;
  ```

数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上 “串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏 感，可能更关心数据并发访问的能力。

为了解决“隔离”与“并发”的矛盾，ISO/ANSI SQL92定义了4个事务隔离级别，每个级别的隔离程度不同，允许出现的副作用也不同，应用可以根据自己的业务逻辑要求，通过选择不同的隔离级别来平衡 “隔离”与“并发”的矛盾。

### 获取InonoD行锁争用情况

可以通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况：

```sql
mysql> show status like 'innodb_row_lock%';
```


如果发现锁争用比较严重，如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高，还可以通过设置InnoDB Monitors来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。

### InnoDB的行锁模式及加锁方法

InnoDB实现了以下两种类型的行锁。

* 共享锁（s）：又称读锁。允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。
* 排他锁（Ｘ）：又称写锁。允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。

对于共享锁大家可能很好理解，就是多个事务只能读数据不能改数据。

对于排他锁大家的理解可能就有些差别，我当初就犯了一个错误，以为排他锁锁住一行数据后，其他事务就不能读取和修改该行数据，其实不是这样的。排他锁指的是一个事务在一行数据加上排他锁后，其他事务不能再在其上加其他的锁。mysql InnoDB引擎默认的修改数据语句：**update,delete,insert都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型**，如果加排他锁可以使用select …for update语句，加共享锁可以使用select … lock in share mode语句。**所以加过排他锁的数据行在其他事务种是不能修改数据的，也不能通过for update和lock in share mode锁的方式查询数据，但可以直接通过select …from…查询数据，因为普通查询没有任何锁机制。**

另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。

* 意向共享锁（IS）：事务打算给数据行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
* 意向排他锁（IX）：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。

### InnoDB行锁模式兼容性列表:

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\20InnoDB行锁模式兼容性列表.png)


如果一个事务请求的锁模式与当前的锁兼容，InnoDB就请求的锁授予该事务；反之，如果两者两者不兼容，该事务就要等待锁释放。
意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁。
事务可以通过以下语句显式给记录集加共享锁或排他锁：

* 共享锁（S）：`SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE`。
* 排他锁（X）：`SELECT * FROM table_name WHERE ... FOR UPDATE`。

用`SELECT ... IN SHARE MODE`获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。**但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT… FOR UPDATE方式获得排他锁。**

### InnoDB行锁实现方式

InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，**否则，InnoDB将使用表锁！**
在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。下面通过一些实际例子来加以说明。

（1）在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。

```sql
mysql> create table tab_no_index(id int,name varchar(10)) engine=innodb;
```

```sql
Query OK, 0 rows affected (0.15 sec)
```



```sql
mysql> insert into tab_no_index values(1,'1'),(2,'2'),(3,'3'),(4,'4');
Query OK, 4 rows affected (0.00 sec)
```

```sql
Records: 4 Duplicates: 0 Warnings: 0
```

在上面的例子中，看起来session_1只给一行加了排他锁，但session_2在请求其他行的排他锁时，却出现了锁等待！原因就是在没有索引的情况下，InnoDB只能使用表锁。当我们给其增加一个索引后，InnoDB就只锁定了符合条件的行，如下例所示：
创建tab_with_index表，id字段有普通索引：

```
mysql> create table tab_with_index(id int,name varchar(10)) engine=innodb;
mysql> alter table tab_with_index add index id(id);
```

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\22.png)

（2）由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。应用设计的时候要注意这一点。
在下面的例子中，表tab_with_index的id字段有索引，name字段没有索引：

```
mysql> alter table tab_with_index drop index name;
```

```
Query OK, 4 rows affected (0.22 sec) Records: 4 Duplicates: 0
Warnings: 0
```



```
mysql> insert into tab_with_index  values(1,'4');
```

```
Query OK, 1 row affected (0.00 sec)
```



```
mysql> select * from tab_with_index where id = 1;
```

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\23.png)

InnoDB存储引擎使用相同索引键的阻塞例子

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\24InnoDB存储引擎使用相同索引键的阻塞例子.png)


（3）当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。
在下面的例子中，表tab_with_index的id字段有主键索引，name字段有普通索引：

```
mysql> alter table tab_with_index add index name(name);
```

```
Query OK, 5 rows affected (0.23 sec) Records: 5 Duplicates: 0
Warnings: 0
```

**InnoDB存储引擎的表使用不同索引的阻塞例子**

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\25InnoDB存储引擎的表使用不同索引的阻塞例子.png)

（4）即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决 定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突 时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。

比如，在tab_with_index表里的name字段有索引，但是name字段是varchar类型的，检索值的数据类型与索引字段不同，虽然MySQL能够进行数据类型转换，但却不会使用索引，从而导致InnoDB使用表锁。通过用explain检查两条SQL的执行计划，我们可以清楚地看到了这一点。

```
mysql> explain select * from tab_with_index where name = 1 \G
mysql> explain select * from tab_with_index where name = '1' \G
```

### 间隙锁（Next-Key锁）

当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的 索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁 （Next-Key锁）。
举例来说，假如emp表中只有101条记录，其empid的值分别是 1,2,…,100,101，下面的SQL：

```
Select * from  emp where empid > 100 for update;
```

是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。

InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使 用间隙锁，如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另外一方面，是为了满足其恢复和复制的需 要。有关其恢复和复制对锁机制的影响，以及不同隔离级别下InnoDB使用间隙锁的情况，在后续的章节中会做进一步介绍。

很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。**因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。**

还要特别说明的是，InnoDB除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用间隙锁！下面这个例子假设emp表中只有101条记录，其empid的值分别是1,2,……,100,101。
InnoDB存储引擎的间隙锁阻塞例子

![](D:\Java\笔记\图片\3-day03【MySQL多表、事务】\26InnoDB存储引擎的间隙锁阻塞例子.png)

## 5.4 小结

本文重点介绍了MySQL中MyISAM表级锁和InnoDB行级锁的实现特点，并讨论了两种存储引擎经常遇到的锁问题和解决办法。

**对于MyISAM的表锁，主要讨论了以下几点：**

1. 共享读锁（S）之间是兼容的，但共享读锁（S）与排他写锁（X）之间，以及排他写锁（X）之间是互斥的，也就是说读和写是串行的。
2. 在一定条件下，MyISAM允许查询和插入并发执行，我们可以利用这一点来解决应用中对同一表查询和插入的锁争用问题。
3. MyISAM默认的锁调度机制是写优先，这并不一定适合所有应用，用户可以通过设置LOW_PRIORITY_UPDATES参数，或在INSERT、UPDATE、DELETE语句中指定LOW_PRIORITY选项来调节读写锁的争用。
4. 由于表锁的锁定粒度大，读写之间又是串行的，因此，如果更新操作较多，MyISAM表可能会出现严重的锁等待，可以考虑采用InnoDB表来减少锁冲突。

**对于InnoDB表，本文主要讨论了以下几项内容：**

1. InnoDB的行锁是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁。
2. 介绍了InnoDB间隙锁（Next-key)机制，以及InnoDB使用间隙锁的原因。
3. 在不同的隔离级别下，InnoDB的锁机制和一致性读策略不同。

**在了解InnoDB锁特性后，用户可以通过设计和SQL调整等措施减少锁冲突和死锁，包括：**

* 尽量使用较低的隔离级别； 精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会；
* 选择合理的事务大小，小事务发生锁冲突的几率也更小；
* 给记录集显式加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁；
* 不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会；
* 尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响； 不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁；
* 对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。



# 第六章 存储结构体

## 4.1 什么是存储过程？

> 在mysql中，存储过程是一组为了完成特定功能的SQL语句集合。一个存储过程是一个可编程的函数，它在数据库中创建并保存，一般由SQL语句和一些特殊的控制结构组成。使用存储过程不仅可以提高数据库的访问效率，同时也可以提高数据库使用的安全性。

存储过程是一组为了完成特定功能的 SQL 语句集合。使用存储过程的目的是将常用或复杂的工作预先用 SQL 语句写好并用一个指定名称存储起来，这个过程经编译和优化后存储在数据库服务器中，因此称为存储过程。当以后需要数据库提供与已定义好的存储过程的功能相同的服务时，只需调用“CALL存储过程名字”即可自动完成。

常用操作数据库的 SQL 语句在执行的时候需要先编译，然后执行。存储过程则采用另一种方式来执行 SQL 语句。

一个存储过程是一个可编程的函数，它在数据库中创建并保存，一般由 SQL 语句和一些特殊的控制结构组成。当希望在不同的应用程序或平台上执行相同的特定功能时，存储过程尤为合适。

MySQL 5.0 版本以前并不支持存储过程，这使 MySQL 在应用上大打折扣。MySQL 从 5.0 版本开始支持存储过程，既提高了数据库的处理速度，同时也提高了数据库编程的灵活性

存储过程是数据库中的一个重要功能，存储过程可以用来转换数据、数据迁移、制作报表，它类似于编程语言，一次执行成功，就可以随时被调用，完成指定的功能操作。

使用存储过程不仅可以提高数据库的访问效率，同时也可以提高数据库使用的安全性。

**相对于直接使用SQL 语句，在应用程序中直接调用存储过程有以下好处：**

(1)减少网络通信量。

调用一个行数不多的存储过程与直接调用SQL 语句的网络通信量可能不会有很大的差别，可是如果存储过程包含上百行SQL 语句，那么其性能绝对比一条一条的调用SQL 语句要高得多。

(2)执行速度更快。

有两个原因：首先，在存储过程创建的时候，数据库已经对其进行了一次解析和优化。其次，存储过程一旦执行，在内存中就会保留一份这个存储过程，这样下次再执行同样的存储过程时，可以从内存中直接调用。

(3)更强的适应性。

由于存储过程对数据库的访问是通过存储过程来进行的，因此数据库开发人员可以在不改动存储过程接口的情况下对数据库进行任何改动，而这些改动不会对应用程序造成影响。

(4) 分布式工作。

应用程序和数据库的编码工作可以分别独立进行，而不会相互压制。

## 4.2 存储过程优点

1. **增强SQL语言的功能和灵活性**：存储过程可以用控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。

2. **标准组件式编程**：存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，对应用程序源代码毫无影响。

3. **较快的执行速度**：如果某一操作包含大量的Transaction-SQL代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transaction-SQL语句在每次运行时都要进行编译和优化，速度相对要慢一些。

4. **减少网络流量**：针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的Transaction-SQL语句被组织进存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大减少网络流量并降低了网络负载。

5. **作为一种安全机制来充分利用**：通过对执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。

