# 第四章 多表查询

多表查询分类：

* 连接查询

  内连接：相当于查询A、B交集部分数据

  外连接：

  * 左外连接：查询坐标所有数据，以及两张表交集部分数据
  * 右外连接：查询右表所有数据，以及两张表交集部分数据

  自连接：当前表于自身的连接查询，自连接必须使用表别名

* 子查询

![](..\图片\2-01【MySQL】\4.png)

## 4.1 多表关系

多表关系有：

1. 一对一(了解)	如：人和身份证

   实现方式：一对一关系实现，可以在任意一方添加**唯一外键**指向另一方的主键。

   通常一对一的关系，我们可以合成一张表来实现。

   

2. 一对多(多对一)   如：部门和员工

   实现方式：在多的一方建立外键，指向一的一方的主键。

   ![](..\图片\2-01【MySQL】\5.png)

   

3. 多对多     如：学生和课程

   实现方式：多对多关系实现需要借助第三张中间表。

   中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键。

   ![](..\图片\2-01【MySQL】\6.png)

## 4.2 多表查询语法

```sql
-- 创建部门表
CREATE TABLE dept(
	id INT PRIMARY KEY AUTO_INCREMENT,
	NAME VARCHAR(20)
);

INSERT INTO dept (NAME) VALUES ("开发部"), ("市场部"), ("财务部");
```

```sql
-- 创建员工表
CREATE TABLE emp(
	id INT PRIMARY KEY AUTO_INCREMENT,
	NAME VARCHAR(20),
	gender CHAR(1),
	salary DOUBLE,
	join_date DATE,
	dept_id INT,
	FOREIGN KEY (dept_id) REFERENCES dept(id)	-- 外键，关联部门表
);

-- 添加6条数据
INSERT INTO emp (NAME, gender, salary, join_date, dept_id) VALUES ("孙悟空", "男", 7200, "2013-02-24", 1);
INSERT INTO emp (NAME, gender, salary, join_date, dept_id) VALUES ("猪八戒", "男", 3600, "2010-12-02", 1);
INSERT INTO emp (NAME, gender, salary, join_date, dept_id) VALUES ("唐僧", "男", 9000, "2008-08-08", 2);
INSERT INTO emp (NAME, gender, salary, join_date, dept_id) VALUES ("白骨精", "女", 5000, "2015-10-07", 2);
INSERT INTO emp (NAME, gender, salary, join_date, dept_id) VALUES ("蜘蛛精", "女", 4500, "2011-3-14", 3);
INSERT INTO emp (NAME, gender, salary, join_date, dept_id) VALUES ('白龙马', '男', 3800, '2000-06-05', NULL);
```

多表查询语句：

```sql
select * from dept, emp;			-- 查询结果一共有18条数据
```

**笛卡尔积**：

* 有两个集合，A，B，取两个集合的所有组成情况。例如上面的表，有两个表，外键存在，笛卡尔积为18，所以上面使用多表查询语句查询后会出来18条结果。
* 因此要完成多表查询，需要消除无用的数据。

```sql
SELECT * FROM emp, dept WHERE emp.`dept_id` = dept.`id`;
```

```sh
# 查询结果如下，一共5条数据：
+--------+--------+
| NAME   | NAME   |
+--------+--------+
| 孙悟空 | 开发部 |
| 猪八戒 | 开发部 |
| 唐僧   | 市场部 |
| 白骨精 | 市场部 |
| 蜘蛛精 | 财务部 |			# 需要注意的是，这里并没有查询出来白龙马，这是因为白龙马的部门为NULL
+--------+--------+
```

## 4.3 内连接查询

内连接查询：相当于查询A、B交集部分数据

![](..\图片\2-01【MySQL】\11.png)

### 4.3.1 隐式内连接

```sql
SELECT * FROM emp, dept WHERE emp.dept_id = dept.id;
```

### 4.3.2 显示内连接

```sql
select 字段列表 from 表名1 [inner] join 表名2 on 条件			-- 显示内连接语法
```

```sql
SELECT emp.NAME, dept.NAME from dept INNER JOIN emp ON dept.id = emp.dept_id;
SELECT emp.NAME, dept.NAME from dept JOIN emp ON dept.id = emp.dept_id;   -- inner可选可不选
```

```sh
# 查询结果如下，一共5条数据：
+--------+--------+
| NAME   | NAME   |
+--------+--------+
| 孙悟空 | 开发部 |
| 猪八戒 | 开发部 |
| 唐僧   | 市场部 |
| 白骨精 | 市场部 |
| 蜘蛛精 | 财务部 |			# 需要注意的是，这里并没有查询出来白龙马，这是因为白龙马的部门为NULL
+--------+--------+
```

## 4.4 外连接查询

之前我们查询数据，一直没有查询出来白龙马，因为它的部门是NULL，而我们想要查询白龙马的话就可以使用外连接了。外连接有两种，左外连接和右外连接：

* 左外连接：查询坐标所有数据，以及两张表交集部分数据
* 右外连接：查询右表所有数据，以及两张表交集部分数据

![](..\图片\2-01【MySQL】\11.png)

### 4.4.1 左外连接查询

左外连接相当于查询表1(左表)的所有数据，当然也包含表1和表2交集部分的数据。

```sql
SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ... ;
```

```sql
SELECT emp.NAME, dept.NAME from emp LEFT JOIN dept ON emp.dept_id = dept.id;
```

```sh
+--------+--------+
| NAME   | NAME   |
+--------+--------+
| 孙悟空 | 开发部 |
| 猪八戒 | 开发部 |
| 唐僧   | 市场部 |
| 白骨精 | 市场部 |
| 蜘蛛精 | 财务部 |
| 白龙马 | NULL   |				# 这时候就能够查询出来白龙马了
+--------+--------+
```

### 4.4.2 右外连接查询

右外连接相当于查询表2(右表)的所有数据，当然也包含表1和表2交集部分的数据。

```sql
 SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ... ;
```

## 4.5 自连接查询

### 4.5.1 自连接查询

自连接查询，顾名思义，就是自己连接自己，也就是把一张表连接查询多次。我们先来学习一下自连接的查询语法： 

```sql
SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ... ;
```

而对于自连接查询，可以是内连接查询，也可以是外连接查询。

```sql
select a.name , b.name from emp a , emp b where a.managerid = b.id;  -- 查询员工 及其 所属领导的名字
```

```sql
-- 查询所有员工 emp 及其领导的名字 emp , 如果员工没有领导, 也需要查询出来 因此使用左外连接查询
select a.name '员工', b.name '领导' from emp a left join emp b on a.managerid = b.id;   
```

> 在自连接查询中，必须要为表起别名，要不然我们不清楚所指定的条件、返回的字段，到底是哪一张表的字段。

### 4.5.2 联合查询

对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。

```sql
SELECT 字段列表 FROM 表A ...
UNION [ ALL ]
SELECT 字段列表 FROM 表B ....;
```

- 对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。 
- union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重。

> 如果多条查询语句查询出来的结果，字段数量不一致，在进行union/union all联合查询时，将会报错。

## 4.6 子查询

SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。子查询：查询中嵌套查询，称嵌套查询为子查询。

```sql
SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2 );
```

子查询外部的语句可以是INSERT / UPDATE / DELETE / SELECT 的任何一个。

根据子查询结果不同，分为： 

- A. 标量子查询（子查询结果为单个值） 
- B. 列子查询(子查询结果为一列) 
- C. 行子查询(子查询结果为一行) 
- D. 表子查询(子查询结果为多行多列) 

根据子查询位置，分为： 

- A. WHERE之后 
- B. FROM之后 
- C. SELECT之后

### 4.6.1 标量子查询 

子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询。 常用的操作符：`= <> > >= < <=` 

案例: 查询 "销售部" 的所有员工信息 

完成这个需求时，我们可以将需求分解为两步： 

1. 查询 "销售部" 部门ID 

   ```sql
   select id from dept where name = '销售部';
   ```

2. 根据 "销售部" 部门ID, 查询员工信息

   ```sql
   select * from emp where dept_id = (select id from dept where name = '销售部');
   ```

### 4.6.2 列子查询 

子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。 常用的操作符：IN 、NOT IN 、 ANY 、SOME 、 ALL

| 操作符 | 描述                                   |
| ------ | -------------------------------------- |
| IN     | 在指定的集合范围内，多选一             |
| NOT IN | 不在指定的集合范围内                   |
| ANY    | 子查询返回列表中，有任意一个满足即可   |
| SOME   | 与ANY等同，使用SOME的地方都可以使用ANY |
| ALL    | 子查询返回列表的所有值都必须满足       |

```sql
-- 查询销售部和市场部的所有员工信息
select * from employee where dept in (select id from dept where name = '销售部' or name = '市场部');
-- 查询比财务部所有人工资都高的员工信息
select * from employee where salary > all(select salary from employee where dept = (select id from dept where name = '财务部'));
-- 查询比研发部任意一人工资高的员工信息
select * from employee where salary > any (select salary from employee where dept = (select id from dept where name = '研发部'));
```

### 4.6.3 行子查询

返回的结果是一行（可以是多列）。

常用操作符：`=, <, >, IN, NOT IN`

```sql
-- 查询与xxx的薪资及直属领导相同的员工信息
select * from employee where (salary, manager) = (12500, 1);
select * from employee where (salary, manager) = (select salary, manager from employee where name = 'xxx');
```

### 4.6.4 表子查询

返回的结果是多行多列

常用操作符：`IN`

```sql
-- 查询与xxx1，xxx2的职位和薪资相同的员工
select * from employee where (job, salary) in (select job, salary from employee where name = 'xxx1' or name = 'xxx2');
-- 查询入职日期是2006-01-01之后的员工，及其部门信息
select e.*, d.* from (select * from employee where entrydate > '2006-01-01') as e left join dept as d on e.dept = d.id;
```

# 第五章 数据库的设计

设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。

关系数据库有六种范式：`第一范式（1NF）`、`第二范式（2NF）`、`第三范式（3NF）`、`巴斯-科德范式（BCNF）`、`第四范式(4NF）`和`第五范式（5NF，又称完美范式）`。

## 5.1 基础概念

* **函数依赖**：`A --> B`，如果通过A属性(属性组)的值，可以确定唯一B属性的值，那么称B依赖于A。

  例如：学号 --> 姓名	（学号，学号课程）--> 分数

* **完全函数依赖**：`A --> B`，如果A是一个属性组，则B属性值的确定需要依赖于A属性组中所有的属性值。

  例如：（学号，学号课程）--> 分数

* **部分函数依赖**：`A --> B`，如果A是一个属性组，则B属性值的确定只需要依赖于A属性组中某一些值。

  例如：（学号，学号课程）--> 姓名

* **传递函数依赖**：`A --> B`，`B --> C`，如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性(属性组)的值可以确定唯一C属性的值，则称C传递函数依赖于A。

  例如：学号 --> 系名，系名 --> 系主任

* **码**：如果在一张表中，一个属性或者属性组，被其他所有的属性所完全依赖，则称这个属性(属性组)为该表的码。

  例如：该表中的码：（学号，课程名称）。

* **主属性**：码属性组中的所有属性。

* **非主属性**：除码属性组的属性。

## 5.2 数据库范式

关系数据库有六种范式：`第一范式（1NF）`、`第二范式（2NF）`、`第三范式（3NF）`、`巴斯-科德范式（BCNF）`、`第四范式(4NF）`和`第五范式（5NF，又称完美范式）`，下面介绍一下前三种范式：

1. `第一范式（1NF）`：数据库表的每一列都是不可分割的原子数据项 
2. `第二范式（2NF）`：在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖） 
3. `第三范式（3NF）`：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）

### 5.2.1 第一范式

一范式，关系数据库已经帮我们控制好了。 

### 5.2.2 第二范式

二范式，就是要有主键，其他属性都要依赖于这个主键。（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。 

假定选课关系表为`SelectCourse(学号, 姓名, 年龄, 课程名称, 成绩, 学分)`，关键字为组合关键字`(学号, 课程名称)`，因为存在如下决定关系：

`(学号, 课程名称) → (姓名, 年龄, 成绩, 学分)`。这个数据库表不满足第二范式，因为存在如下决定关系： `(课程名称) → (学分)`； `(学号) → (姓名, 年龄)`。即存在组合关键字中的字段决定非关键字的情况。

由于不符合2NF，这个选课关系表会存在如下问题：

1. 数据冗余：

   同一门课程由n个学生选修，"学分"就重复n-1次；同一个学生选修了m门课程，姓名和年龄就重复了m-1次。

2. 更新异常：

   若调整了某门课程的学分，数据表中所有行的"学分"值都要更新，否则会出现同一门课程学分不同的情况。

3. 插入异常：

   假设要开设一门新的课程，暂时还没有人选修。这样，由于还没有"学号"关键字，课程名称和学分也无法记录入数据库。

4. 删除异常：

   假设一批学生已经完成课程的选修，这些选修记录就应该从数据库表中删除。但是，与此同时，课程名称和学分信息也被删除了。很显然，这也会导致插入异常。

把选课关系表SelectCourse改为如下三个表：

* 学生：`Student(学号, 姓名, 年龄)`；

* 课程：`Course(课程名称, 学分)`；

* 选课关系：`SelectCourse(学号, 课程名称, 成绩)`。

这样的数据库表是符合第二范式的，消除了数据冗余、更新异常、插入异常和删除异常。另外，所有单关键字的数据库表都符合第二范式，因为不可能存在组合关键字。

### 5.2.3 第三范式

三范式，就是不能有冗余，一张表，只能有主键，依赖主键的属性，外键，不能包含外键表的非主键属性。

假定学生关系表为`Student(学号, 姓名, 年龄, 所在学院, 学院地点, 学院电话)`，关键字为单一关键字"学号"，因为存在如下决定关系： `(学号) → (姓名, 年龄, 所在学院, 学院地点, 学院电话)` 

这个数据库是符合2NF的，但是不符合3NF，因为存在如下决定关系：      `(学号) → (所在学院) → (学院地点, 学院电话)` 。即存在非关键字段"学院地点"、"学院电话"对关键字段"学号"的传递函数依赖。      

它也会存在数据冗余、更新异常、插入异常和删除异常的情况。      

把学生关系表分为如下两个表：`学生：(学号, 姓名, 年龄, 所在学院)`； `学院：(学院, 地点, 电话)`。

这样的数据库表是符合第三范式的，消除了数据冗余、更新异常、插入异常和删除异常。 

# 第五章 事务

事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。

如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。

1. 开启事务：`start transaction;`
2. 回滚：`rollback;`
3. 提交：`commit;`

```sql
-- 开启事务，只要不提交或者回滚，一直在事务中，数据为临时数据
START TRANSACTION;

UPDATE account SET balance = balance - 500 WHERE NAME = "张三";

UPDATE account SET balance = balance + 500 WHERE NAME = "李四";

-- 发现问题，回滚
ROLLBACK;
-- 没有问题，提交
COMMIT;
```

MySQL数据库中事务是默认自动提交的。

事务提交的两种方式：

* 自动提交：MySQL就是自动提交的，一条DML（增删改）语句会自动提交一次事务。
* 手动提交：Oracle数据库默认是手动提交事务，需要先开启事务，然后再提交。

修改事务的默认提交方式：

* 查看事务的默认提交方式：

  ```sql
  select @@autocommit;		-- 1代表自动提交   0代表手动提交
  ```

* 修改默认提交方式

  ```sql
  set @@autocommit = 0；
  ```

## 7.1 事务的四大特性

<!--P532-->

`ACID`

* A原子性(atomicity)：事务中的所有操作，要么全部成功，要么全部失败。或称不可分割性。
* C一致性(consistency)：要保证数据库内部完整性约束、声明性约束。
* I隔离性(isolation)：对同一资源操作的事务不能够同时发生。又称独立性。
* D持久性(durability)：对数据库做出的一切修改将永久保存，不管是否出现故障。

## 7.2 并发事务常见问题

多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。

存在问题如下

1. **脏读**：一个事务，读取到另一个事务中没有提交的数据。

   事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据

2. **不可重复读（虚读）**：在同一个事务中，两次读取到的数据不一样。

   事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。

3. **幻读**：一个事务操作（DML）数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。

   系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。

> 小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表

| 问题       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| 脏读       | 一个事务读到另一个事务还没提交的数据                         |
| 不可重复读 | 一个事务先后读取同一条记录，但两次读取的数据不同             |
| 幻读       | 一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在 |

## 7.3 事务四种隔离级别

隔离级别一共有四种：

1. `read uncommitted`：读未提交

   产生的问题：脏读、不可重复读、幻读。

2. `read committed`：读已提交(Oracle默认隔离级别)

   产生的问题：不可重复读、幻读。

3. `repeatable read`：可重复读(MySQL默认级别)

   产生的问题：幻读。

4. `serializable`：串行化

   可以解决所有的问题

> 注意：隔离级别从小到大安全性越来越高，但是效率越来越低。隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。
>

数据库查询隔离级别：

```sql
select @@tx_isolation;
```

数据库设置隔离级别：

```sql
set global transaction isolation level 级别字符串;
```

1. 设置隔离级别是`repeatable read`可重复读，那么会把不可重复读消灭掉，想要在右表读取到数据更改，那么只能手动结束右表的事务，committed或者rollback。但是留着幻读，幻读，我们演示不了
2. 设置隔离级别是`serializable`串行化，类似于加一个锁，就是在该事务中，其他事务影响不了。只要设置了该隔离级别，那么其他的事务甚至都不能查询该事务中修改的表。右表不能够查询account表。只有等左边的事务回滚或者提交结束事务，右边的事务才能够显示出来account表格，否则一直在等待。

### read uncommitted

读未提交`read uncommitted`：

> 场景：张三给李四转账500元，由于这是事务中，所以是临时的，可以被回滚或者提交。这时候我们再打开一个客户端，让李四去查询，李四查询的时候发现账户已经修改了，那么相信了张三已经转账了，就会打欠条了。可是如果直接回滚，会发现数据都会归为原来。
>
> 产生的问题是：脏读、不可重复读、幻读(无法演示)

1. 打开一个客户端A，并设置当前事务模式为`read uncommitted`：读未提交，查询表account的初始值：

![](..\图片\2-01【MySQL】\7-1.png)

2. 在客户端A的事务提交之前，打开另一个客户端B，更新表account：

![](..\图片\2-01【MySQL】\7-2.png)

3. 这时，虽然客户端B的事务还没提交，但是客户端A就可以查询到B已经更新的数据：

![](..\图片\2-01【MySQL】\7-3.png)

4. 一旦客户端B的事务因为某种原因回滚，所有的操作都将会被撤销，那客户端A查询到的数据其实就是脏数据：

![](..\图片\2-01【MySQL】\7-4.png)

### read committed

读已提交。设置隔离级别是`read committed`读已提交，会把脏读给消灭掉，但是依然会留着不可重复读。

1. 打开一个客户端A，并设置当前事务模式为`read committed（读已提交）`，查询表`account`的所有记录：

![](..\图片\2-01【MySQL】\7-6.png)

2. 在客户端A的事务提交之前，打开另一个客户端B，更新表`account`：

![](..\图片\2-01【MySQL】\7-7.png)

3. 这时，客户端B的事务还没提交，客户端A不能查询到B已经更新的数据，解决了脏读问题：

![](..\图片\2-01【MySQL】\7-8.png)

4. 客户端B的事务提交

![](..\图片\2-01【MySQL】\7-9.png)

5. 客户端A执行与上一步相同的查询，结果与上一步不一致，即产生了不可重复读的问题

![](..\图片\2-01【MySQL】\7-10.png)

### repeatable read

可重复读。设置隔离级别是`repeatable read`可重复读，那么会把不可重复读消灭掉，想要在客户端A读取到数据更改，那么只能手动结束客户端A的事务，`committed`或者`rollback`。

1. 打开一个客户端A，并设置当前事务模式为`repeatable read`，查询表`account`的所有记录

![](..\图片\2-01【MySQL】\7-11.png)

2. 在客户端A的事务提交之前，打开另一个客户端B，更新表`account`并提交


![](..\图片\2-01【MySQL】\7-12.png)

3. 在客户端A查询表`account`的所有记录，与步骤（1）查询结果一致，没有出现不可重复读的问题

![](..\图片\2-01【MySQL】\7-13.png)

4. 在客户端A，接着执行`update balance = balance - 50 where id = 1`，`balance`没有变成`400-50=350`，lilei的balance值用的是步骤（2）中的350来算的，所以是300，数据的一致性倒是没有被破坏。

   ![](..\图片\2-01【MySQL】\7-14.png)

5. 重新打开客户端B，插入一条新数据后提交

![](..\图片\2-01【MySQL】\7-15.png)

6. 在客户端A计算balance之和，值为300+16000+2400=18700，没有把客户端B的值算进去，客户端A提交后再计算balance之和，居然变成了19300，这是因为把客户端B的600算进去了。

   站在客户的角度，客户是看不到客户端B的，它会觉得是天下掉馅饼了，多了600块，这就是幻读，站在开发者的角度，数据的一致性并没有破坏。

   但是在应用程序中，我们的代码可能会把18700提交给用户了，如果你一定要避免这情况小概率状况的发生，那么就要采取下面要介绍的事务隔离级别“串行化”


### serializable　

串行化，设置隔离级别是`serializable`串行化，类似于加一个锁，就是在该事务中，其他事务影响不了。只要设置了该隔离级别，那么其他的事务甚至都不能查询该事务中修改的表。右表不能够查询account表。只有等左边的事务回滚或者提交结束事务，右边的事务才能够显示出来account表格，否则一直在等待。

1. 打开一个客户端A，并设置当前事务模式为serializable，查询表account的初始值：

   ```sql
   mysql> set session transaction isolation level serializable;
   Query OK, 0 rows affected (0.00 sec)
   
   mysql> start transaction;
   Query OK, 0 rows affected (0.00 sec)
   
   mysql> select * from account;
   +------+--------+---------+
   | id | name | balance |
   +------+--------+---------+
   | 1 | lilei | 10000 |
   | 2 | hanmei | 10000 |
   | 3 | lucy | 10000 |
   | 4 | lily | 10000 |
   +------+--------+---------+
   rows in set (0.00 sec)
   ```

2. 打开一个客户端B，并设置当前事务模式为serializable，插入一条记录报错，表被锁了插入失败，mysql中事务隔离级别为serializable时会锁表，因此不会出现幻读的情况，这种隔离级别并发性极低，往往一个事务霸占了一张表，其他成千上万个事务只有干瞪眼，得等他用完提交才可以使用，开发中很少会用到。

   ```sql
   mysql> set session transaction isolation level serializable;
   Query OK, 0 rows affected (0.00 sec)
   
   mysql> start transaction;
   Query OK, 0 rows affected (0.00 sec)
   
   mysql> insert into account values(5,'tom',0);
   ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
   ```



