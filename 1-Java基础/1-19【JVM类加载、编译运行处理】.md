# 第一章 类加载阶段

类加载完成后会在方法区内保存类的字节码二进制数据，在堆区中保存类的Class对象。

## 1.1 加载阶段

将类的字节码载入方法区（1.8后为元空间实现，在本地内存中）中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有：

- _java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用
- _super 即父类
- _ﬁelds 即成员变量
- _methods 即方法
- _constants 即常量池
- _class_loader 即类加载器
- _vtable 虚方法表
- _itable 接口方法

如果这个类还有父类没有加载，**先加载父类**

加载和链接可能是**交替运行**的

![](D:\Java\笔记\图片\5-1【jvm】\16.png)

- instanceKlass保存在方法区。JDK 8以后，方法区由元空间实现。
- instanceKlass在方法区加载的同时，会在堆内存中生成一个_java_mirror的镜像文件，俗称的**类对象**。
- InstanceKlass和类对象互相保存了对方的地址
- 类的实例对象在对象头中保存了*.class（类对象）的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息。

## 1.2 链接阶段

将类的二进制数据合并到JRE中。

### 验证

验证类是否符合 JVM规范，安全性检查

用 UE 等支持二进制的编辑器修改 HelloWorld.class 的魔数，在控制台运行。这里用的是Notepad++，里面有插件

```java
Error: A JNI error has occurred, please check your installation and try again
Exception in thread "main" java.lang.ClassFormatError: Incompatible magic value 3405691578 in class file Demo01
        at java.lang.ClassLoader.defineClass1(Native Method)
        at java.lang.ClassLoader.defineClass(Unknown Source)
        at java.security.SecureClassLoader.defineClass(Unknown Source)
        at java.net.URLClassLoader.defineClass(Unknown Source)
        at java.net.URLClassLoader.access$100(Unknown Source)
        at java.net.URLClassLoader$1.run(Unknown Source)
        at java.net.URLClassLoader$1.run(Unknown Source)
        at java.security.AccessController.doPrivileged(Native Method)
        at java.net.URLClassLoader.findClass(Unknown Source)
        at java.lang.ClassLoader.loadClass(Unknown Source)
        at sun.misc.Launcher$AppClassLoader.loadClass(Unknown Source)
        at java.lang.ClassLoader.loadClass(Unknown Source)
        at sun.launcher.LauncherHelper.checkAndLoadMain(Unknown Source)
```

### 准备

JVM在该阶段为 static 变量分配空间，设置默认值（对应数据类型的默认初始值如：0、0L、NULL、false）。这些变量所使用的内存都将在方法区（根据版本）中进行分配。

- static变量在JDK 7以前是存储与instanceKlass末尾。但在JDK 7以后就存储在_java_mirror末尾了

- static变量在分配空间和赋值是在两个阶段完成的。分配内存空间在准备阶段完成，赋值在初始化阶段完成

  所以如果是非static变量那么不会再准备阶段分配内存空间。

  如果是static变量会在准备阶段分配内存空间，并且设置默认值，注意在这里设置了默认值了。赋值的话在初始化阶段完成。

- 如果 static 变量是 ﬁnal 的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成

- 如果 static 变量是 ﬁnal 的，但属于引用类型，那么赋值也会在初始化阶段完成

### 解析

将常量池中的符号引用解析为直接引用

```java
public class Demo01 {
    public static void main(String[] args) throws ClassNotFoundException, IOException {
		ClassLoader classloader = Demo01.class.getClassLoader();
        // loadClass 方法不会导致类的解析和初始化
        Class<?> c = classloader.loadClass("com.linxuan.demo03.C");
        // new C();
		// 阻塞主线程
        System.in.read();
	}
}

class C {
    D d = new D();
}

class D {
}
```

未解析时，常量池中的看到的对象仅是符号，未真正的存在于内存中。

使用jps命令查看进程ID：

```java
PS D:\Java\vscode-java\MavenProjects\jvm> jps
13488 Demo01
4964 Jps
```

打开HSDB：`PS E:\JAVA\jdk1.8.0_144> java -cp ./lib/sa-jdi.jar sun.jvm.hotspot.HSDB` 需要进入jdk安装目录.

输入进程ID，打开`Tools->Class Brwser`，可以看到此时只加载了类C。

![](D:\Java\笔记\图片\5-1【jvm】\17.png)

点击类C，查看类C的常量池，可以看到类D未被解析，只是存在于常量池中的符号：

![](D:\Java\笔记\图片\5-1【jvm】\17-1.png)

这时候让D解析：

```java
public class Demo01 {
    public static void main(String[] args) throws ClassNotFoundException, IOException {
		// ClassLoader classloader = Demo01.class.getClassLoader();
        // loadClass 方法不会导致类的解析和初始化
        // Class<?> c = classloader.loadClass("com.linxuan.demo03.C");
        new C();
		// 阻塞主线程
        System.in.read();
	}
}

class C {
    D d = new D();
}

class D {
}

```

解析以后，会将常量池中的符号引用解析为直接引用。可以看到，此时已加载并解析了类C和类D

![](D:\Java\笔记\图片\5-1【jvm】\17-2.png)

## 1.3 初始化阶段

初始化阶段就是执行类构造器`cinit()`（有一个老师说是`clint()`）方法的过程，虚拟机会保证这个类的『构造方法』的线程安全，加锁。

`cinit()`方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的。

类的初始化是懒惰的，以下情况会初始化

- main 方法所在的类，总会被首先初始化
- 首次访问这个类的静态变量或静态方法时
- 子类初始化，如果父类还没初始化，会引发
- 子类访问父类的静态变量，只会触发父类的初始化
- Class.forName
- new 会导致初始化

以下情况不会初始化

- 访问类的 static ﬁnal 静态常量（基本类型和字符串）
- 类对象.class 不会触发初始化
- 创建该类对象的数组
- 类加载器的.loadClass方法
- Class.forNamed的参数2为false时

**验证类是否被初始化，可以看该类的静态代码块是否被执行**

```java
class A {
    static int a = 0;
    static {
        System.out.println("a init");
    }
}
class B extends A {
    final static double b = 5.0;
    static boolean c = false;
    static {
        System.out.println("b init");
    }
}
```

```java
// 验证（实验时请先全部注释，每次只执行其中一个）
public class Load3 {
    static {
        System.out.println("main init");
    }
    
    public static void main(String[] args) throws ClassNotFoundException {
        // 1. 静态常量（基本类型和字符串）不会触发初始化
        System.out.println(B.b);
        // 2. 类对象.class 不会触发初始化
        System.out.println(B.class);
        // 3. 创建该类的数组不会触发初始化
        System.out.println(new B[0]);
        // 4. 不会初始化类 B，但会加载 B、A
        ClassLoader cl = Thread.currentThread().getContextClassLoader();
        cl.loadClass("cn.itcast.jvm.t3.B");
        // 5. 不会初始化类 B，但会加载 B、A
        ClassLoader c2 = Thread.currentThread().getContextClassLoader();
        Class.forName("cn.itcast.jvm.t3.B", false, c2);
        
        // 1. 首次访问这个类的静态变量或静态方法时
        System.out.println(A.a);
        // 2. 子类初始化，如果父类还没初始化，会引发
        System.out.println(B.c);
        // 3. 子类访问父类静态变量，只触发父类初始化
        System.out.println(B.a);
        // 4. 会初始化类 B，并先初始化类 A
        Class.forName("cn.itcast.jvm.t3.B");
    }
}
```

## 1.4 练习初始化阶段

从字节码分析，使用 a，b，c 这三个常量是否会导致 E 初始化

```java
public class Load4 {
    public static void main(String[] args) {
        System.out.println(E.a);
        System.out.println(E.b);
        System.out.println(E.c);
    }
}
class E {
    public static final int a = 10;
    public static final String b = "hello";
    public static final Integer c = 20;
}

```

如果是a，b两个常量并不会导致E初始化，他们会在链接准备阶段就赋值完毕了。但是如果是c的话，因为是包装类型，所以会初始化。

> 如果 static 变量是 ﬁnal 的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成。



典型应用 - 完成懒惰初始化单例模式

```java
public class Singleton{
    public static void test() {
        System.out.println("test");
    }
    
    private Singleton() { }

    // 内部类中保存单例
    private static class LazyHolder {
        static final Singleton INSTANCE = new Singleton();
        static{
            System.out.println("lazy holder init...");
        }
    }
    // 第一次调用 getInstance 方法，才会导致内部类加载和初始化其静态成员
    public static Singleton getInstance() {
        return LazyHolder.INSTANCE;
    }
}
```

```java
public class Demo01 {
    public static void main(String[] args) {
        Singleton.test();           // 打印 test
        Singleton.getInstance();    // 打印 lazy holder init...
    }
}
```

以上的实现特点是：

- 懒惰实例化
- 初始化时的线程安全是有保障的

# 第二章 类加载器

Java虚拟机设计团队有意把类加载阶段中的 `通过一个类的全限定名来获取描述该类的二进制字节流` 这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”（ClassLoader）

类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段。

对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。

以JDK 8为例

| 名称                                        | 加载的类              | 说明                            |
| ------------------------------------------- | --------------------- | ------------------------------- |
| Bootstrap ClassLoader（启动类加载器）       | JAVA_HOME/jre/lib     | 无法直接访问                    |
| Extension ClassLoader（拓展类加载器）       | JAVA_HOME/jre/lib/ext | 上级为Bootstrap，**显示为null** |
| Application ClassLoader（应用程序类加载器） | classpath             | 上级为Extension                 |
| 自定义类加载器                              | 自定义                | 上级为Application               |

## 2.1 启动类加载器

用 Bootstrap 类加载器加载类：

```java
package com.linxuan.demo03;

public class TestBootstrapClassLoader {
    static {
        System.out.println("bootstrap BootstrapClassLoader init");
    }
}
```

```java
package com.linxuan.demo03;

public class Demo01 {
    public static void main(String[] args) throws ClassNotFoundException {
        Class<?> bootStrapClass = Class.forName("com.linxuan.demo03.TestBootstrapClassLoader");
        System.out.println(bootStrapClass.getClassLoader());
    }
}
```

执行命令，可以看到如下输出：

```apl
# 进入class文件输出目录键入命令 设置该class字节码加载器为Bootstrap ClassLoader
PS D:\Java\vscode-java\MavenProjects\jvm\target\classes> 
											java -Xbootclasspath/a:. com/linxuan/demo03/Demo01   
bootstrap BootstrapClassLoader init
null			# 打印为NULL说明设置成功 因为Bootstrap ClassLoader是由C++编写 所以无法打印出来
```

可通过在控制台输入指令，使得类被启动类加器加载：

- -Xbootclasspath 表示设置 bootclasspath
- 其中 `/a:.` 表示将当前目录追加至 bootclasspath 之后

- 可以用这个办法替换核心类
  - `java -Xbootclasspath:<new bootclasspath>`，完全替换
  - `java -Xbootclasspath/a:<追加路径>`，后追加
  - `java -Xbootclasspath/p:<追加路径>`，前追加

## 2.2 拓展类加载器

```java
package com.linxuan.demo03;

public class Test {
    static {
        System.out.println("ClassPath Test init");
    }
}
```

```java
package com.linxuan.demo03;

public class Demo01 {
    public static void main(String[] args) throws ClassNotFoundException {
        Class<?> testClass = Class.forName("com.linxuan.demo03.Test");
        System.out.println(testClass.getClassLoader());
    }
}
```

直接运行主方法会输出如下内容：

```apl
ext G init
sun.misc.Launcher$AppClassLoader@6d06d69c
```



写一个同名的类

```java
package com.linxuan.demo03;
public class Test {
    static {
        System.out.println("ext G init");
    }
}
```

将其打成 jar 包，就会在`PS D:\Java\vscode-java\MavenProjects\jvm\target\classes`目录下面生成一个jar包。

```java
PS D:\Java\vscode-java\MavenProjects\jvm\target\classes> 
    											jar -cvf my.jar .\com\linxuan\demo03\Test.class   
已添加清单
正在添加: com/linxuan/demo03/Test.class(输入 = 501) (输出 = 327)(压缩了 34%)
```

将 jar 包拷贝到 `JAVA_HOME/jre/lib/ext`，重新执行Demo01类里面的main方法，这时候输出就大不一样了：

```apl
ext G init
sun.misc.Launcher$ExtClassLoader@232204a1
```

这是因为如果`classpath`和`JAVA_HOME/jre/lib/ext` 下有同名类，加载时会使用拓展类加载器加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载。

## 2.3 双亲委派模式

双亲委派模式，即调用类加载器ClassLoader 的 loadClass 方法时，查找类的规则

> 这里的双亲，翻译为上级似乎更为合适，因为它们并没有继承关系

loadClass源码如下：

```java
protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
    synchronized (getClassLoadingLock(name)) {
        // 1. 检查该类是否已经加载
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    // 2. 有上级的话，委派上级 loadClass
                    c = parent.loadClass(name, false);
                } else {
                    // 3. 如果没有上级了（ExtClassLoader），则委派
                    BootstrapClassLoader
                        c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
            }
            if (c == null) {
                long t1 = System.nanoTime();
                // 4. 每一层找不到，调用 findClass 方法（每个类加载器自己扩展）来加载
                c = findClass(name);
                // 5. 记录耗时
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```

```java
public class Demo01 {
    public static void main(String[] args) throws ClassNotFoundException {
        Class<?> testClass = Demo01.class.getClassLoader().loadClass("com.linxuan.demo03.Test");
        System.out.println(testClass.getClassLoader());
    }
}
```

执行流程为：

1. `sun.misc.Launcher$AppClassLoader` //1 处， 开始查看已加载的类，结果没有
2. `sun.misc.Launcher$AppClassLoader` // 2 处，委派上级`sun.misc.Launcher$ExtClassLoader.loadClass()`
3. `sun.misc.Launcher$ExtClassLoader` // 1 处，查看已加载的类，结果没有
4. `sun.misc.Launcher$ExtClassLoader` // 3 处，没有上级了，则委派 `BootstrapClassLoader`查找
5. `BootstrapClassLoader` 是在 `JAVA_HOME/jre/lib` 下找 H 这个类，显然没有
6. `sun.misc.Launcher$ExtClassLoader` // 4 处，调用自己的 findClass 方法，是在`JAVA_HOME/jre/lib/ext` 下找 H 这个类，显然没有，回到 `sun.misc.Launcher$AppClassLoader`的 // 2 处
7. 继续执行到 `sun.misc.Launcher$AppClassLoader` // 4 处，调用它自己的 findClass 方法，在classpath 下查找，找到了

## 2.4 线程上下文类加载器

我们在使用 JDBC 时，都需要加载 Driver 驱动，如果不写`Class.forName("com.mysql.jdbc.Driver")`，也是可以让 `com.mysql.jdbc.Driver` 正确加载的。

让我们追踪一下源码：

```java
public class Driver extends NonRegisteringDriver implements java.sql.Driver {
    //
    // Register ourselves with the DriverManager
    //
    static {
        try {
            java.sql.DriverManager.registerDriver(new Driver());
        } catch (SQLException E) {
            throw new RuntimeException("Can't register driver!");
        }
    }
}
```

```java
public class DriverManager {
    // 注册驱动的集合
    private final static CopyOnWriteArrayList<DriverInfo> registeredDrivers 
        														= new CopyOnWriteArrayList<>();
    // 初始化驱动
    static {
        loadInitialDrivers();
        println("JDBC DriverManager initialized");
    }
}
```

先不看别的，看看 DriverManager 的类加载器：

```java
System.out.println(DriverManager.class.getClassLoader());
```

打印 null，表示它的类加载器是 Bootstrap ClassLoader，会到 `JAVA_HOME/jre/lib` 下搜索类，但 `JAVA_HOME/jre/lib` 下显然没有 `mysql-connector-java-5.1.47.jar` 包，这样问题来了，在`DriverManager` 的静态代码块中，怎么能正确加载 `com.mysql.jdbc.Driver` 呢？

继续看 loadInitialDrivers() 方法：

```java
private static void loadInitialDrivers() {
    String drivers;
    try {
        drivers = AccessController.doPrivileged(new PrivilegedAction<String> () {
                                                    public String run() {
                                                        return System.getProperty("jdbc.drivers");
                                                    }
                                                });
    } catch (Exception ex) {
        drivers = null;
    }
    // 1）使用 ServiceLoader 机制加载驱动，即 SPI
    AccessController.doPrivileged(new PrivilegedAction<Void>() {
        public Void run() {
            ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);
            Iterator<Driver> driversIterator = loadedDrivers.iterator();
            try{
                while(driversIterator.hasNext()) {
                    driversIterator.next();
                }
            } catch(Throwable t) {
                // Do nothing
            }
            return null;
        }
    });
    println("DriverManager.initialize: jdbc.drivers = " + drivers);
    // 2）使用 jdbc.drivers 定义的驱动名加载驱动
    if (drivers == null || drivers.equals("")) {
        return;
    }
    String[] driversList = drivers.split(":");
    println("number of Drivers:" + driversList.length);
    for (String aDriver : driversList) {
        try {
            println("DriverManager.Initialize: loading " + aDriver);
            // 这里的 ClassLoader.getSystemClassLoader() 就是应用程序类加载器
            Class.forName(aDriver, true, ClassLoader.getSystemClassLoader());
        } catch (Exception ex) {
            println("DriverManager.Initialize: load failed: " + ex);
        }
    }
}

```

先看 2）发现它最后是使用 Class.forName 完成类的加载和初始化，关联的是应用程序类加载器，因此可以顺利完成类加载

再看 1）它就是大名鼎鼎的 Service Provider Interface （SPI）

约定如下，在 jar 包的 META-INF/services 包下，以接口全限定名名为文件，文件内容是实现类名称

![](D:\Java\笔记\图片\5-1【jvm】\18.png)

这样就可以使用

```java
ServiceLoader<接口类型> allImpls = ServiceLoader.load(接口类型.class);
Iterator<接口类型> iter = allImpls.iterator();
while(iter.hasNext()) {
    iter.next();
}
```

来得到实现类，体现的是【面向接口编程+解耦】的思想，在下面一些框架中都运用了此思想：

- JDBC
- Servlet 初始化器
- Spring 容器
- Dubbo（对 SPI 进行了扩展）

接着看 ServiceLoader.load 方法：

```java
public static <S> ServiceLoader<S> load(Class<S> service) {
    // 获取线程上下文类加载器
    ClassLoader cl = Thread.currentThread().getContextClassLoader();
    return ServiceLoader.load(service, cl);
}
```

线程上下文类加载器是当前线程使用的类加载器，默认就是应用程序类加载器，它内部又是由 Class.forName 调用了线程上下文类加载器完成类加载，具体代码在 ServiceLoader 的内部类 LazyIterator 中：

```java
private S nextService() {
    if (!hasNextService())
        throw new NoSuchElementException();
    String cn = nextName;
    nextName = null;
    Class<?> c = null;
    try {
        c = Class.forName(cn, false, loader);
    } catch (ClassNotFoundException x) {
        fail(service, "Provider " + cn + " not found");
    }
    if (!service.isAssignableFrom(c)) {
        fail(service,
             "Provider " + cn + " not a subtype");
    }
    try {
        S p = service.cast(c.newInstance());
        providers.put(cn, p);
        return p;
    } catch (Throwable x) {
        fail(service,
             "Provider " + cn + " could not be instantiated",
             x);
    }
    throw new Error(); // This cannot happen
}

```



## 2.5 自定义类加载器

使用场景如下：

- 想加载非 classpath 随意路径中的类文件
- 通过接口来使用实现，希望解耦时，常用在框架设计
- 这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器

步骤如下：

- 继承ClassLoader父类
- 要遵从双亲委派机制，重写 ﬁndClass 方法。不是重写loadClass方法，否则不会走双亲委派机制
- 读取类文件的字节码
- 调用父类的 deﬁneClass 方法来加载类
- 使用者调用该类加载器的 loadClass 方法

准备好一个类文件放入 `D:\Bprogram\java\myclasspath`，先反编译看一下：

```java
D:\Bprogram\java\myclasspath>javap HelloWorld.class
Compiled from "HelloWord.java"
class HelloWorld {
  HelloWorld();
  public static void main(java.lang.String[]);
}
```

接下来做一个我们自己的类加载器：

```java
class MyClassLoader extends ClassLoader {

    @Override // name 就是类名称
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        String path = "D:\\Bprogram\\java\\myclasspath\\" + name + ".class";

        try {
            ByteArrayOutputStream os = new ByteArrayOutputStream();
            Files.copy(Paths.get(path), os);

            // 得到字节数组
            byte[] bytes = os.toByteArray();

            // byte[] -> *.class
            return defineClass(name, bytes, 0, bytes.length);

        } catch (IOException e) {
            e.printStackTrace();
            throw new ClassNotFoundException("类文件未找到", e);
        }
    }

}
```

```java
public class Demo01 {
    public static void main(String[] args) throws Exception {
        MyClassLoader classLoader = new MyClassLoader();
        Class<?> c1 = classLoader.loadClass("HelloWorld");
        System.out.println(c1.getClassLoader());
    }
}
// 输出信息如下：com.linxuan.demo01.MyClassLoader@42a57993
```

破坏双亲委派模式

- 双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代

  建议用户重写findClass()方法，在类加载器中的loadClass()方法中也会调用该方法

- 双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的

  如果有基础类型又要调用回用户的代码，此时也会破坏双亲委派模式

- 双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的

  这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等

# 第三章 编译期处理-语法糖

所谓的语法糖 ，其实就是指 java 编译器把 *.java 源码编译为 \*.class 字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利。

注意，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的结果直接就是 class 字节码，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。

## 3.1 默认构造函数

```java
public class Candy1 {
}
```

经过编译期优化后

```java
public class Candy1 {
   //这个无参构造器是java编译器帮我们加上的
   public Candy1() {
      //即调用父类 Object 的无参构造方法，即调用 java/lang/Object." <init>":()V
      super();
   }
}
```

## 3.2 自动拆装箱

基本类型和其包装类型的相互转换过程，称为拆装箱。

这个特性是 `JDK 5` 开始加入的， `代码片段1` ：

```java
public class Demo2 {
   public static void main(String[] args) {
      Integer x = 1;
      int y = x;
   }
}
```

这段代码在 `JDK 5` 之前是无法编译通过的，必须改写为 `代码片段2` :

```java
public class Demo2 {
   public static void main(String[] args) {
      //基本类型赋值给包装类型，称为装箱
      Integer x = Integer.valueOf(1);
      //包装类型赋值给基本类型，称谓拆箱
      int y = x.intValue();
   }
}
```

显然之前版本的代码太麻烦了，需要在基本类型和包装类型之间来回转换（尤其是集合类中操作的都是包装类型），因此这些转换的事情在 `JDK 5` 以后都由编译器在编译阶段完成。即 `代码片段1` 都会在编译阶段被转换为 `代码片段2`。

## 3.3 泛型擦除和反射

泛型也是在 JDK 5 开始加入的特性，但 java 在编译泛型代码后会执行 `泛型擦除` 的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都当做了 Object 类型来处理：

```java
public class Demo01 {
   public static void main(String[] args) {
      List<Integer> list = new ArrayList<>();
      list.add(10);
      Integer x = list.get(0);
   }
}
```

```java
  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=3, args_size=1
         0: new           #16           // class java/util/ArrayList
         3: dup
         4: invokespecial #18           // Method java/util/ArrayList."<init>":()V
         7: astore_1
         8: aload_1
         9: bipush        10
        11: invokestatic  #19           // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;   
        14: invokeinterface #25,  2     // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z   
        19: pop
        20: aload_1
        21: iconst_0
        22: invokeinterface #31,  2      // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object; 
        27: checkcast     #20            // class java/lang/Integer
        30: astore_2
        31: return
```

所以调用get函数取值时，有一个类型转换的操作

```java
Integer x = (Integer) list.get(0);
```

如果前面的 x 变量类型修改为 int 基本类型那么最终生成的字节码是：

```java
// 需要将 Object 转为 Integer, 并执行拆箱操作
int x = ((Integer)list.get(0)).intValue();
```

当然JDK5以后这些我们都不用来做。

擦除的是字节码上的泛型信息，可以看到 `LocalVariableTypeTable` 仍然保留了方法参数泛型的信息：

```java
      LocalVariableTypeTable:
        Start  Length  Slot  Name   Signature
            8      24     1  list   Ljava/util/List<Ljava/lang/Integer;>;
```

局部变量的泛型信息虽然没有被擦除，但是我们也没有办法使用反射来拿到。只有在方法的参数和返回值上面才可以拿到：

```java
public Set<Integer> test(List<String> list, Map<Integer, Object> map) {
}
```

```java
Method test = Candy3.class.getMethod("test", List.class, Map.class);
Type[] types = test.getGenericParameterTypes();
for (Type type : types) {
    if (type instanceof ParameterizedType) {
        ParameterizedType parameterizedType = (ParameterizedType) type;
        System.out.println("原始类型 - " + parameterizedType.getRawType());
        Type[] arguments = parameterizedType.getActualTypeArguments();
        for (int i = 0; i < arguments.length; i++) {
            System.out.printf("泛型参数[%d] - %s\n", i, arguments[i]);
        }
    }
}
```

```apl
# 打印结果如下：
原始类型 - interface java.util.List
泛型参数[0] - class java.lang.String
原始类型 - interface java.util.Map
泛型参数[0] - class java.lang.Integer
泛型参数[1] - class java.lang.Object
```



## 3.4 可变参数

```java
public class Demo04 {
   public static void foo(String... args) {
      String[] arr = args;
      System.out.println(arr.length);
   }

   public static void main(String[] args) {
      foo("hello", "world");
   }
}
```

可变参数 String… args 其实是一个 String[] args ，从代码中的赋值语句中就可以看出来。 同样 java 编译器会在编译期间将上述代码变换为：

```java
public class Demo04 {
    public static void foo(String[] args) {
        String[] array = args; // 直接赋值
        System.out.println(array);
    }
    public static void main(String[] args) {
        foo(new String[]{"hello", "world"});
    }
}
```

注意，如果调用的是`foo()`，即未传递参数时，等价代码为`foo(new String[]{})`，创建了一个空数组，而不是直接传递的null。

## 3.5 foreach循环

仍是 `JDK 5` 开始引入的语法糖，数组的循环：

```java
public class Demo05 {
	public static void main(String[] args) {
		int[] arr = {1, 2, 3, 4, 5};		//数组赋初值的简化写法也是一种语法糖。
		for(int x : arr) {
			System.out.println(x);
		}
	}
}
```

编译器会帮我们转换为

```java
public class Demo05 {
    public Demo05 {}

	public static void main(String[] args) {
		int[] arr = new int[]{1, 2, 3, 4, 5};
		for(int i = 0; i < arr.length; ++i) {
			int x = arr[i];
			System.out.println(x);
		}
	}
}
```

如果是集合循环：

```java
public class Demo05 {
   public static void main(String[] args) {
      List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
      for (Integer x : list) {
         System.out.println(x);
      }
   }
}
```

实际被编译器转换为对迭代器的调用：

```java
public class Demo05 {
    public Demo05 {}
    
   public static void main(String[] args) {
      List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
      Iterator<Integer> iterator = list.iterator();			//获得该集合的迭代器
      while(iterator.hasNext()) {
         Integer x = iterator.next();
         System.out.println(x);
      }
   }
}
```

> foreach 循环写法，能够配合数组，以及所有实现了 Iterable 接口的集合类一起使用，其中 Iterable 用来获取集合的迭代器（ Iterator ）

## 3.6 switch字符串

从 `JDK 7` 开始，switch 可以作用于字符串和枚举类，这个功能其实也是语法糖，例如：

```java
public class Demo06 {
   public static void main(String[] args) {
      String str = "hello";
      switch (str) {
         case "hello" :
            System.out.println("h");
            break;
         case "world" :
            System.out.println("w");
            break;
         default:
            break;
      }
   }
}
```

> switch 配合 String 和枚举使用时，变量不能为null。

在编译器中执行的操作：

```java
public class Demo06 {
   public Demo06() {
      
   }
   public static void main(String[] args) {
      String str = "hello";
      int x = -1;
      
      switch (str.hashCode()) {
         case 99162322 :
            if(str.equals("hello")) {	//再次比较，因为字符串的hashCode有可能相等
               x = 0;
            }
            break;
         case 11331880 :
            if(str.equals("world")) {
               x = 1;
            }
            break;
         default:
            break;
      }

      //用第二个switch在进行输出判断
      switch (x) {
         case 0:
            System.out.println("h");
            break;
         case 1:
            System.out.println("w");
            break;
         default:
            break;
      }
   }
}
```

在编译期间，单个的switch被分为了两个：
- 第一个用来匹配字符串，并给x赋值。字符串的匹配用到了字符串的hashCode，还用到了equals方法。使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突。
- 第二个用来根据x的值来决定输出语句

## 3.7 switch枚举

```java
enum SEX {
   MALE, FEMALE;
}
```

```java
public class Demo07 {
   public static void main(String[] args) {
      SEX sex = SEX.MALE;
      switch (sex) {
         case MALE:
            System.out.println("man");
            break;
         case FEMALE:
            System.out.println("woman");
            break;
         default:
            break;
      }
   }
}
```

编译器中执行的代码如下

```java
public class Demo07 {
   /**     
    * 定义一个合成类（仅 jvm 使用，对我们不可见）     
    * 用来映射枚举的 ordinal 与数组元素的关系     
    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始     
    * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1     
    */ 
   static class $MAP {
      //数组大小即为枚举元素个数，里面存放了case用于比较的数字
      static int[] map = new int[2];
      static {
         //ordinal即枚举元素对应所在的位置，MALE为0，FEMALE为1
         map[SEX.MALE.ordinal()] = 1;
         map[SEX.FEMALE.ordinal()] = 2;
      }
   }

   public static void main(String[] args) {
      SEX sex = SEX.MALE;
      //将对应位置枚举元素的值赋给x，用于case操作
      int x = $MAP.map[sex.ordinal()];
      switch (x) {
         case 1:
            System.out.println("man");
            break;
         case 2:
            System.out.println("woman");
            break;
         default:
            break;
      }
   }
}
```



## 3.8 枚举类

`JDK 7` 新增了枚举类，以前面的性别枚举为例：

```java
enum SEX {
   MALE, FEMALE;
}
```

转换后的代码

```java
public final class Sex extends Enum<Sex> {   
   //对应枚举类中的元素
   public static final Sex MALE;    
   public static final Sex FEMALE;    
   private static final Sex[] $VALUES;
   
    static {       
    	//调用构造函数，传入枚举元素的值及ordinal
    	MALE = new Sex("MALE", 0);    
        FEMALE = new Sex("FEMALE", 1);   
        $VALUES = new Sex[]{MALE, FEMALE}; 
   }
 	
    //调用父类中的方法
    private Sex(String name, int ordinal) {     
        super(name, ordinal);    
    }
   
    public static Sex[] values() {  
        return $VALUES.clone();  
    }
    public static Sex valueOf(String name) { 
        return Enum.valueOf(Sex.class, name);  
    } 
   
}
```

## 3.9 try-with-resources

`JDK 7` 开始新增了对需要关闭的资源处理的特殊语法 `try-with-resources`：

```java
try(资源变量 = 创建资源对象){
    
} catch( ) {
    
}
```

其中资源对象需要实现 `AutoCloseable` 接口，例如 `InputStream` 、 `OutputStream` 、`Connection` 、 `Statement` 、 `ResultSet` 等接口都实现了 `AutoCloseable` ，使用 `try-withresources` 可以不用写 finally 语句块，编译器会帮助生成关闭资源代码，例如：

```java
public class Demo01 {
    public static void main(String[] args) {
        try(InputStream is = new FileInputStream("d:\\1.txt")) {
            System.out.println(is);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

会被转换为：

```java
public class Demo01 {
    public Demo01() {
    }
    
    public static void main(String[] args) {
        try {
            InputStream is = new FileInputStream("d:\\1.txt");
            Throwable t = null;
            try {
                System.out.println(is);
            } catch (Throwable e1) {
                // t 是我们代码出现的异常
                t = e1;
                throw e1;
            } finally {
                // 判断了资源不为空
                if (is != null) {
                    // 如果我们代码有异常
                    if (t != null) {
                        try {
                            is.close();
                        } catch (Throwable e2) {
                            // 如果 close 出现异常，作为被压制异常添加
                            t.addSuppressed(e2);
                        }
                    } else {
                        // 如果我们代码没有异常，close 出现的异常就是最后 catch 块中的 e
                        is.close();
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

为什么要设计一个 `addSuppressed(Throwable e)` （添加被压制异常）的方法呢？是为了防止异常信息的丢失（想想 try-with-resources 生成的 fianlly 中如果抛出了异常）：

```java
public class Test6 {
    public static void main(String[] args) {
        try (MyResource resource = new MyResource()) {
            int i = 1/0;
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
class MyResource implements AutoCloseable {
    public void close() throws Exception {
        throw new Exception("close 异常");
    }
}
```

输出：

```apl
java.lang.ArithmeticException: / by zero
    at test.Test6.main(Test6.java:7)
    Suppressed: java.lang.Exception: close 异常
        at test.MyResource.close(Test6.java:18)
        at test.Test6.main(Test6.java:6)
```

如以上代码所示，两个异常信息都不会丢。

## 3.10 方法重写时的桥接方法

我们都知道，方法重写时对返回值分两种情况：

- 父子类的返回值完全一致

- 子类返回值可以是父类返回值的子类（比较绕口，见下面的例子）

  ```java
  class A {
      public Number m() {
          return 1;
      }
  }
  ```

  ```java
  class B extends A {
      @Override
      // 子类 m 方法的返回值是 Integer 是父类 m 方法返回值 Number 的子类
      public Integer m() {
          return 2;
      }
  }
  ```

对于子类，java 编译器会做如下处理：

```java
class B extends A {
    public Integer m() {
        return 2;
    }
    // 此方法才是真正重写了父类 public Number m() 方法
    public synthetic bridge Number m() {
        // 调用 public Integer m()
        return m();
    }
}
```

其中桥接方法比较特殊，仅对 java 虚拟机可见，并且与原来的 `public Integer m()` 没有命名冲突，可以用下面反射代码来验证：

```java
for (Method m : B.class.getDeclaredMethods()) {
    System.out.println(m);
}
```

会输出：

```java
public java.lang.Integer test.candy.B.m()
public java.lang.Number test.candy.B.m()
```



## 3.11 匿名内部类

```java
public class Candy11 {
    public static void main(String[] args) {
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println("ok");
            }
        };
    }
}
```

转换后的代码

```java
// 额外生成的类
final class Candy11$1 implements Runnable {
    Candy11$1() {
    }
    public void run() {
        System.out.println("ok");
    }
}
```

```java
public class Candy11 {
    public static void main(String[] args) {
        Runnable runnable = new Candy11$1();
    }
}
```



引用局部变量的匿名内部类，源代码：

```java
public class Candy11 {
    public static void test(final int x) {
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println("ok:" + x);
            }
        };
    }
}
```

转化后代码

```java
// 额外生成的类
final class Candy11$1 implements Runnable {
    int val$x;
    Candy11$1(int x) {
        this.val$x = x;
    }
    public void run() {
        System.out.println("ok:" + this.val$x);
    }
}
```

```java
public class Candy11 {
    public static void test(final int x) {
        Runnable runnable = new Candy11$1(x);
    }
}
```

这同时解释了为什么匿名内部类引用局部变量时，局部变量必须是 `final` 的：因为在创建 `Candy11$1` 对象时，将 `x` 的值赋值给了 `Candy11$1` 对象的 `val$x` 属性，所以 `x` 不应该再发生变化了，如果变化，那么 `val$x` 属性没有机会再跟着一起变化。

# 第四章 运行期优化

## 4.1 即时编译

### 4.1.1 分层编译

```java
public class Demo01 {
    public static void main(String[] args) {
        for (int i = 0; i < 200; i++) {
            long start = System.nanoTime();
            for (int j = 0; j < 1000; j++) {
                new Object();
            }
            long end = System.nanoTime();
            System.out.printf("%d\t%d\n", i, (end - start));
        }
    }
}
```

```java
0       31900
1       36700
...
62      43100		
63      14100		// 时间变短了
64      16900
...
188     19300
189     200			// 时间变短了
190     300
...
```

原因是什么呢？

JVM 将执行状态分成了 5 个层次：

- 0层：解释执行，用解释器将字节码翻译为机器码
- 1层：使用 C1 即时编译器编译执行（不带 proﬁling）
- 2层：使用 C1 即时编译器编译执行（带基本的profiling）
- 3层：使用 C1 即时编译器编译执行（带完全的profiling）
- 4层：使用 C2 即时编译器编译执行

> proﬁling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等

即时编译器（JIT）与解释器的区别如下：

- 解释器是将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释
- JIT 是将一些字节码编译为机器码，并存入 Code Cache，下次遇到相同的代码，直接执行，无需再编译
- 解释器是将字节码解释为针对所有平台都通用的机器码
- JIT 会根据平台类型，生成平台特定的机器码

对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter < C1 < C2，总的目标是发现热点代码（hotspot名称的由 来），并优化这些热点代码

### 4.1.2 逃逸分析

逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术。

逃逸分析的 JVM 参数如下：

- 开启逃逸分析：`-XX:+DoEscapeAnalysis`
- 关闭逃逸分析：`-XX:-DoEscapeAnalysis`
- 显示分析结果：`-XX:+PrintEscapeAnalysis`

逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数

- **全局逃逸（GlobalEscape）**：一个对象的作用范围逃出了当前方法或者当前线程。有以下几种场景：对象是一个静态变量、对象是一个已经发生逃逸的对象、对象作为当前方法的返回值。
- **参数逃逸（ArgEscape）**：即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的。
- **没有逃逸**：即方法中的对象没有发生逃逸

针对上面第三点，当一个对象没有逃逸时，可以得到以下几个虚拟机的优化

**锁消除**

我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁

例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作

锁消除的 JVM 参数如下：

- 开启锁消除：`-XX:+EliminateLocks`
- 关闭锁消除：`-XX:-EliminateLocks`

锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上

**标量替换**

首先要明白标量和聚合量，基础类型和对象的引用可以理解为标量，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象

对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做标量替换。

这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能

标量替换的 JVM 参数如下：

- 开启标量替换：`-XX:+EliminateAllocations`
- 关闭标量替换：`-XX:-EliminateAllocations`
- 显示标量替换详情：`-XX:+PrintEliminateAllocations`

标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上

**栈上分配**

当对象没有发生逃逸时，该对象就可以通过标量替换分解成成员标量分配在栈内存中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能

### 4.1.3 方法内联

内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换。

如下：

```java
private static int square(final int i) {
    return i * i;
}
```

```java
System.out.println(square(9));
```

如果发现 square 是热点方法，并且长度不太长时，会进行内联，所谓的内联就是把方法内代码拷贝、 粘贴到调用者的位置：

```java
System.out.println(9 * 9);
```

接下来实验一下：

```java
public class JIT2 {
    // -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining （解锁隐藏参数）打印内联信息
    // -XX:CompileCommand=dontinline,*JIT2.square 禁止某个方法 inlining
    // -XX:+PrintCompilation 打印编译信息
    public static void main(String[] args) {
        int x = 0;
        for (int i = 0; i < 500; i++) {
            long start = System.nanoTime();
            for (int j = 0; j < 1000; j++) {
                x = square(9);
            }
            long end = System.nanoTime();
            System.out.printf("%d\t%d\t%d\n",i,x,(end - start));
        }
    }
    private static int square(final int i) {
        return i * i;
    }
}
```

C++是否为内联函数由自己决定，Java由编译器决定。Java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字final修饰 用来指明那个函数是希望被JVM内联的。

总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数

JVM内建有许多运行时优化。首先短方法更利于JVM推断。流程更明显，作用域更短，副作用也更明显。如果是长方法JVM可能直接就跪了。

第二个原因则更重要：方法内联

### 4.1.4 字段优化

JMH 基准测试请参考：http://openjdk.java.net/projects/code-tools/jmh/

创建 maven 工程，添加依赖如下

```xml
<dependency>
    <groupId>org.openjdk.jmh</groupId>
    <artifactId>jmh-core</artifactId>
    <version>1.35</version>
</dependency>

<dependency>
    <groupId>org.openjdk.jmh</groupId>
    <artifactId>jmh-generator-annprocess</artifactId>
    <version>1.35</version>
    <scope>provided</scope>
</dependency>
```

```json
{
    "java.configuration.updateBuildConfiguration": "automatic", //maven、gradle的配置文件变更后自动更新
    "java.eclipse.downloadSources": true,       // 设置导入jar包下载源代码
    "java.maven.downloadSources": true,         // 设置导入jar包下载源代码
    "java.configuration.runtimes": [            // 设置运行项目jdk VSCode使用jdk9不行
        {
            "name": "JavaSE-1.8",
            "path": "E:\\JAVA\\jdk1.8.0_144",
            "default": true
        }
    ]
}
```

```java
@Warmup(iterations = 2, time = 1)
@Measurement(iterations = 5, time = 1)
@State(Scope.Benchmark)
public class Demo01 {
    int[] elements = randomInts(1_000);

    private static int[] randomInts(int size) {
        Random random = ThreadLocalRandom.current();
        int[] values = new int[size];
        for (int i = 0; i < size; i++) {
            values[i] = random.nextInt();
        }
        return values;
    }

    @Benchmark
    public void test1() {
        for (int i = 0; i < elements.length; i++) {
            doSum(elements[i]);
        }
    }

    @Benchmark
    public void test2() {
        int[] local = this.elements;
        for (int i = 0; i < local.length; i++) {
            doSum(local[i]);
        }
    }

    @Benchmark
    public void test3() {
        for (int element : elements) {
            doSum(element);
        }
    }

    static int sum = 0;

    @CompilerControl(CompilerControl.Mode.INLINE)
    static void doSum(int x) {
        sum += x;
    }

    public static void main(String[] args) throws RunnerException {
        Options opt = new OptionsBuilder()
        .include(Demo01.class.getSimpleName())
        .forks(1)
        .build();
        new Runner(opt).run();
    }
}
```

首先启用 doSum 的方法内联，测试结果如下（每秒吞吐量，分数越高的更好）：

```apl
Benchmark Mode Samples Score Score error Units
t.Benchmark1.test1 thrpt 5 2420286.539 390747.467 ops/s
t.Benchmark1.test2 thrpt 5 2544313.594 91304.136 ops/s
t.Benchmark1.test3 thrpt 5 2469176.697 450570.647 ops/s
```

接下来禁用 doSum 方法内联

```java
@CompilerControl(CompilerControl.Mode.DONT_INLINE)
static void doSum(int x) {
    sum += x;
}
```

测试结果如下：

```apl
Benchmark Mode Samples Score Score error Units
t.Benchmark1.test1 thrpt 5 296141.478 63649.220 ops/s
t.Benchmark1.test2 thrpt 5 371262.351 83890.984 ops/s
t.Benchmark1.test3 thrpt 5 368960.847 60163.391 ops/s
```

分析：在刚才的示例中，doSum 方法是否内联会影响 elements 成员变量读取的优化？

如果 doSum 方法内联了，刚才的 test1 方法会被优化成下面的样子（伪代码）：

```java
@Benchmark
public void test1() {
    // elements.length 首次读取会缓存起来 -> int[] local
    for (int i = 0; i < elements.length; i++) { // 后续 999 次 求长度 <- local
        sum += elements[i]; // 1000 次取下标 i 的元素 <- local
    }
}
```

可以节省 1999 次 Field 读取操作。但如果 doSum 方法没有内联，则不会进行上面的优化。

内联或者不内联对后两个方法没有影响：

* 自己本省就是用了数组存起来
* foreach编译期优化，语法糖也是数据。

## 4.2 反射优化

```java
package cn.itcast.jvm.t3.reflect;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class Reflect1 {
    public static void foo() {
        System.out.println("foo...");
    }
    public static void main(String[] args) throws Exception {
        Method foo = Reflect1.class.getMethod("foo");
        for (int i = 0; i <= 16; i++) {
            System.out.printf("%d\t", i);
            foo.invoke(null);
        }
        System.in.read();
    }
}
```

foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现，源码如下：

```java
class NativeMethodAccessorImpl extends MethodAccessorImpl {
    private final Method method;
    private DelegatingMethodAccessorImpl parent;
    private int numInvocations;
    
    NativeMethodAccessorImpl(Method method) {
        this.method = method;
    }
    
    public Object invoke(Object target, Object[] args)
        throws IllegalArgumentException, InvocationTargetException {
        // inflationThreshold 膨胀阈值，默认 15
        if (++this.numInvocations > ReflectionFactory.inflationThreshold()
            && !ReflectUtil.isVMAnonymousClass(this.method.getDeclaringClass())) {
            // 使用 ASM 动态生成的新实现代替本地实现，速度较本地实现快 20 倍左右
            MethodAccessorImpl generatedMethodAccessor =
                (MethodAccessorImpl)
                (new MethodAccessorGenerator())
                .generateMethod(
                this.method.getDeclaringClass(),
                this.method.getName(),
                this.method.getParameterTypes(),
                this.method.getReturnType(),
                this.method.getExceptionTypes(),
                this.method.getModifiers()
            );
            this.parent.setDelegate(generatedMethodAccessor);
        }
        // 调用本地实现
        return invoke0(this.method, target, args);
    }
    void setParent(DelegatingMethodAccessorImpl parent) {
        this.parent = parent;
    }
    private static native Object invoke0(Method method, Object target, Object[] args);
}
```

当调用到第 16 次（从0开始算）时，会采用运行时生成的类代替掉最初的实现，可以通过 debug 得到 类名为 sun.reflect.GeneratedMethodAccessor1

可以使用阿里的 arthas 工具：

```apl
java -jar arthas-boot.jar
[INFO] arthas-boot version: 3.1.1
[INFO] Found existing java process, please choose one and hit RETURN.
* [1]: 13065 cn.itcast.jvm.t3.reflect.Reflect1
```

选择 1 回车表示分析该进程

```apl
1
[INFO] arthas home: /root/.arthas/lib/3.1.1/arthas
[INFO] Try to attach process 13065
[INFO] Attach process 13065 success.
[INFO] arthas-client connect 127.0.0.1 3658
,---. ,------. ,--------.,--. ,--. ,---. ,---.
/ O \ | .--. ''--. .--'| '--' | / O \ ' .-'
| .-. || '--'.' | | | .--. || .-. |`. `-.
| | | || |\ \ | | | | | || | | |.-' |
`--' `--'`--' '--' `--' `--' `--'`--' `--'`-----'
wiki https://alibaba.github.io/arthas
tutorials https://alibaba.github.io/arthas/arthas-tutorials
version 3.1.1
pid 13065
time 2019-06-10 12:23:54
```

再输入【jad + 类名】来进行反编译

```java
$ jad sun.reflect.GeneratedMethodAccessor1
    ClassLoader:
+-sun.reflect.DelegatingClassLoader@15db9742
    +-sun.misc.Launcher$AppClassLoader@4e0e2f2a
    +-sun.misc.Launcher$ExtClassLoader@2fdb006e
    Location:
/*
* Decompiled with CFR 0_132.
*
* Could not load the following classes:
* cn.itcast.jvm.t3.reflect.Reflect1
*/
package sun.reflect;
import cn.itcast.jvm.t3.reflect.Reflect1;
import java.lang.reflect.InvocationTargetException;
import sun.reflect.MethodAccessorImpl;

public class GeneratedMethodAccessor1
    extends MethodAccessorImpl {
    /*
    * Loose catch block
    * Enabled aggressive block sorting
    * Enabled unnecessary exception pruning
    * Enabled aggressive exception aggregation
    * Lifted jumps to return sites
    */
    public Object invoke(Object object, Object[] arrobject) throws
        InvocationTargetException {
        // 比较奇葩的做法，如果有参数，那么抛非法参数异常
        block4 : {
            if (arrobject == null || arrobject.length == 0) break block4;
            throw new IllegalArgumentException();
        }
        try {
            // 可以看到，已经是直接调用了😱😱😱
            Reflect1.foo();
            // 因为没有返回值
            return null;
        }
        catch (Throwable throwable) {
            throw new InvocationTargetException(throwable);
        }
        catch (ClassCastException | NullPointerException runtimeException) {
            throw new IllegalArgumentException(Object.super.toString());
        }
    }
}
Affect(row-cnt:1) cost in 1540 ms
```

通过查看 `ReflectionFactory` 源码可知

- sun.reflect.noInflation 可以用来禁用膨胀（直接生成 GeneratedMethodAccessor1，但首次生成比较耗时，如果仅反射调用一次，不划算）
- sun.reflect.inflationThreshold 可以修改膨胀阈值
