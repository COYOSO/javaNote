![](D:\Java\笔记\图片\Java版本\5-10.png)

# 第一章 自动装箱/拆箱

由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：

```java
Integer i = 4; // 自动装箱。相当于Integer i = Integer.valueOf(4);
i = i + 5; // 等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;
// 加法运算完成后，再次装箱，把基本数值转成对象。
```

看一下下面的题目：

```java
public class Main {
    public static void main(String[] args) {
         
        Integer i1 = 100;
        Integer i2 = 100;
        Integer i3 = 200;
        Integer i4 = 200;
         
        System.out.println(i1==i2);    //true
        System.out.println(i3==i4);    //false
    }
}
```

为什么会这样呢？看下`Integer`的`valueOf`方法的具体实现：

```java
public static Integer valueOf(int i) {
    final int offset = 128;
    if (i >= -128 && i <= 127) { // must cache 
        return IntegerCache.cache[i + offset];
    }
    return new Integer(i);
}
```

而其中`IntegerCache`类的实现为：

```java
// 省略了很多
private static class IntegerCache {
    private IntegerCache(){}
    static final Integer cache[] = new Integer[127 - (-128) + 1];

    static {
        for(int i = 0; i < cache.length; i++)
            cache[i] = new Integer(i - 128);
    }
}
```

由上可知，Integer包装类型如果数值在`[-128,127]`之间，便返回指向`IntegerCache.cache`中已经存在的对象的引用；否则创建一个新的Integer对象。

`Integer`、`Short`、`Byte`、`Character`、`Long`这几个类的`valueOf`方法的实现是类似的，而`Double`、`Float`的`valueOf`方法的实现就和他们不一样了，这是因为他们都是浮点数，根本无法确定值。

对于`Boolean`类型比较一下就一目了然：

```java
public class Main {
    public static void main(String[] args) {

        Boolean i1 = false;
        Boolean i2 = false;
        Boolean i3 = true;
        Boolean i4 = true;

        System.out.println(i1==i2);    //true
        System.out.println(i3==i4);    //true
    }
}
```

源码：

```java
public static Boolean valueOf(boolean b) {
    return (b ? TRUE : FALSE);
}

public static final Boolean TRUE = new Boolean(true);
public static final Boolean FALSE = new Boolean(false);
```

另外还有一点需要注意：当 `"=="`运算符的两个操作数都是包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程），对基础数据类型进行运算。

对于包装器类型，equals方法并不会进行类型转换。

```java
public class Main {
    public static void main(String[] args) {
         
        Integer a = 1;
        Integer b = 2;
        Integer c = 3;
        Integer d = 3;
        Integer e = 321;
        Integer f = 321;
        Long g = 3L;
        Long h = 2L;
         
        System.out.println(c==d);            //true
        System.out.println(e==f);            //false
        System.out.println(c==(a+b));        //true
        System.out.println(c.equals(a+b));   //true
        System.out.println(g==(a+b));        //true
        System.out.println(g.equals(a+b));   //false
        System.out.println(g.equals(a+h));   //true
    }
}
```

`equals()`方法源码

```java
//Integer类中
public boolean equals(Object obj) {
	if (obj instanceof Integer) {
	    return value == ((Integer)obj).intValue();
	}
	return false;
}
 
//Long类中
public boolean equals(Object obj) {
    if (obj instanceof Long) {
	return value == ((Long)obj).longValue();
    }
	return false;
}
```

指定equals比较的是内容本身，并且我们也可以看到equals的参数是一个Object对象，我们传入的是一个int类型，所以首先会进行装箱，然后比较，之所以返回true，是由于它比较的是对象里面的value值。当内容和类型都相同时才会返回true。

# 第二章 枚举

问题：要定义星期几或性别的变量，该怎么定义？

假设用1-7分别表示星期一到星期日，但有人可能会写成`int weekday = 0;`，这样根本不行，因为没有星期0的存在。所以这时候就可以使用枚举！

枚举就是要让某个类型的变量的取值只能为若干个固定值中的一个，否则，编译器就会报错。枚举可以让编译器在编译时就可以控制源程序中填写的非法值，普通变量的方式在开发阶段无法实现这一目标。

### 枚举的基本应用

1. 通过enum关键字定义枚举类，枚举类是一个特殊的类，每个元素都是该类的一个实例对象。

2. 用枚举类规定值，如上面的WeekDay类。以后用此类型定义的值只能是这个类中规定好的那些值，若不是这些值，编译器不会通过。

3. 好处：在编译时期就会发现错误，表明值不符合，减少了运行时期的错误。

4. 如果调用者想打印枚举类中元素的信息，需由编写此类的人定义toString方法。
   注：枚举类是一个class，而且是一个不可被继承的final类，其中的元素都是类静态常量。

5. 常用方法：

   * 构造器：

     1. 构造器只是在构造枚举值的时候被调用。

     2. 构造器只有私有`private`，绝不允许有`public`构造器。这样可以保证外部代码无法重新构造枚举类的实例。因为枚举值是`public static final`的常量，但是枚举类的方法和数据域是可以被外部访问的。

     3. 构造器可以有多个，调用哪个即初始化相应的值。

   * 非静态方法：（所有的枚举类都继承了Enum方法）

     1. `String toString()`：返回枚举量的名称

     2. `int ordinal()`：返回枚举值在枚举类中的顺序，按定义的顺序排，默认第一个是0

     3. `Class getClass()`：获取对应的类名

     4. `String name()`：返回此枚举常量的名称，在其枚举声明中对其进行声明。

   * 静态方法：

     1. `valueOf(String e)`：转为对应的枚举对象，即将字符串转为对象

     2. `values()`：获取所有的枚举对象元素


```java
/*
 * 用普通类如何实现枚举功能，定义一个Weekday的类来模拟枚举功能。 
	1、私有的构造方法
	2、每个元素分别用一个公有的静态成员变量表示
	3、可以有若干公有方法或抽象方法。采用抽象方法定义nextDay就将大量的if.else语句转移成了一个个独立的类。
*/
public abstract class WeekDay {
	private WeekDay(){}
 
	public final static WeekDay SUN = new WeekDay(){
		public WeekDay nextDay(){
			return MON;
		}
	};
	
	public final static WeekDay MON = new WeekDay(){
		public WeekDay nextDay(){
			return SUN;
		}
	};
	
	public abstract WeekDay nextDay();
 
	public String toString(){
		return this == SUN ? "SUM" : "MON";
	}
}
```

```java
public class EnumDemo {
    public static void main(String[] args) {
        WeekDay weekDay = WeekDay.MON;
        System.out.println(weekDay);//输出枚举常量名
        System.out.println("=====================1");
        System.out.println(weekDay.name());//输出对象名
        System.out.println("=====================2");
        System.out.println(weekDay.getClass());//输出对应类
        System.out.println("=====================3");
        System.out.println(weekDay.toString());//输出枚举对象名
        System.out.println("=====================4");
        System.out.println(weekDay.ordinal());//输出此对象在枚举常量的次序
        System.out.println("=====================5");
        System.out.println(WeekDay.valueOf("WED"));//将字符串转化为枚举常量
        System.out.println("=====================6");
        System.out.println(WeekDay.values().length);//获取所以的枚举元素，并打印其长度
    }
    //定义枚举内部类
    public enum WeekDay{
        SUN(1),MON,TUE,WED,THI,FRI,SAT;
        //分号可有可无，但如果下面还有方法或其他成员时，分号不能省。
        //而且当有其他方法时，必须在这些枚举变量的下方。

        //无参构造器
        private WeekDay(){
            System.out.println("First");
        }
        //带参数的构造器
        private WeekDay(int day){
            System.out.println("Second");
        }
    }
}

/*
	Second
	First
	First
	First
	First
	First
	First
	MON
	=====================1
	MON
	=====================2
	class Demo$WeekDay
	=====================3
	MON
	=====================4
	1
	=====================5
	WED
	=====================6
	7
*/
```

### 枚举的高级应用

1. 枚举就相当于一个类，其中也可以定义构造方法、成员变量、普通方法和抽象方法。
2. 枚举元素必须位于枚举体中的最开始部分，枚举元素列表的后要有分号与其他成员分隔。把枚举中的成员方法或变量等放在枚举元素的前面，编译器报告错误。
3. 带构造方法的枚举
   * 构造方法必须定义成私有的
   * 如果有多个构造方法，该如何选择哪个构造方法？
   * 枚举元素MON和MON()的效果一样，都是调用默认的构造方法。

4. 带方法的枚举

```java
/*
 * 抽象的枚举方法
 * 此时枚举中的常量需要子类来实现，这是可以利用内部类的方式来定义枚举常量
 * 带方法的枚举
	1）定义枚举TrafficLamp
	2）实现普通的next方法
	3）实现抽象的next方法：每个元素分别是由枚举类的子类来生成的实例对象，这些子类
	4）用类似内部类的方式进行定义。
	5）增加上表示时间的构造方法
 * */
 
package cn.itheima;
 
public class EnumTest {
	public enum TrafficLamp{
		RED(30){
			public TrafficLamp nextLamp(){
				return GREEN;
			}
		},
		GREEN(30){
			public TrafficLamp nextLamp(){
				return YELLOW;
			}
		},
		YELLOW(5){
			public TrafficLamp nextLamp(){
				return RED;
			}
		};
		private int time;
		//构造器
		private TrafficLamp(int time){
			this.time=time;}
		//抽象方法
		public abstract TrafficLamp nextLamp();
	}		
}
```

### 小结

1. 匿名内部类比较常用
2. 类的方法返回的类型可以是本类的类型
3. 类中可定义静态常量，常量的结果就是自己这个类型的实例对象
4. 枚举只有一个成员时，就可以作为一种单例的实现方式。

> 注意：
>
> * 所有的枚举都继承自java.lang.Enum类。由于Java不支持多继承，所以枚举对象不能再继承其他类。
>
> * switch语句支持int,char,enum类型，使用枚举，能让我们的代码可读性更强。

# 第三章 静态导入

静态导入是JDK1.5中对import语句的增强,语法格式:`import static 包名….类名.方法名`;或者导入类中所有静态成员，此时方法名用`*`代替。

静态导入注意事项：

- 方法或变量必须是静态的
- 如果有多个同名的静态方法，这个时候要使用，必须加前缀。

示例：

```java
import static java.lang.System.out; 
import static java.lang.Integer.*; 
 
public class Test {
     
    public static void main(String[] args) { 
        out.println(MAX_VALUE);         //2147483647
        out.println(toHexString(42));   //2a
    } 
}
```

静态导入节省了大量重复代码的击键次数，但同时也牺牲了代码的可阅读性。

# 第三章 可变参数

格式如下：

1. `数据类型...参数名`   真的是三个点,不要写多
2. 可以传入当前类型的任意个值
3. 可变参数本质就是一个数组可以直接传入数组

> 注意：
>
> * 一个方法只能有一个可变参数
>
> * 如果方法有多个参数,可变参数一定要放在最后    因为可变参数会将所有传入的值获取到,后面的形参永远拿不到值
>
> * 如果可变参数的类型为Object...obj    那么可以传入任意类型,任意个数

```java
public static void main(String[] args) {
 
        sum();
        sum(1);
        sum(10,20,30,40);
        sum(1,1,1,1,1,1,1,1,1,1);
 
        int[] arr = {3,8,2,5,0};
        int sum = sum(arr);
        System.out.println(sum);
 
    }
 
    public static int sum(int...a){
        int sum = 0;
        for (int i : a) {
            sum+=i;
        }
        return sum;
    }

    //本质上就是数组
    public static int sum(int[] arr){
        int sum = 0;
        for(int[] i : arr){
            sum+=i;
        }
        return sum;
    }
}
```

```java
/*
     Collections方法
       static void  addAll(Collection<T>  c ,T...t)
 */
public class Test {
    public static void main(String[] args) {
 
        List<String> list = new ArrayList<>();
 
//        list.add("abc");
//        list.add("bcd");
//        list.add("aaa");
 
        Collections.addAll(list,"abc","bcd","aa");
 
        System.out.println(list);
    }
}
```

# 第四章 内省

### 什么是内省

在计算机科学中，内省是指计算机程序在运行时（Run time）检查对象（Object）类型的一种能力，通常也可以称作**运行时类型检查**。 不应该将内省和反射混淆。

相对于内省，反射更进一步，是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力。

内省(Introspector) 是Java 语言对 JavaBean 类属性、事件的一种缺省处理方法。

JavaBean是一种特殊的类，主要用于传递数据信息，这种类中的方法主要用于访问私有的字段，且方法名符合某种命名规则。如果在两个模块之间传递信息，可以将信息封装进JavaBean中，这种对象称为“值对象”(Value Object)，或“VO”。方法比较少。这些信息储存在类的私有变量中，通过set()、get()获得。

### 内省和反射的区别

**反射**是在运行状态把Java类中的各种成分映射成相应的Java类，可以动态的获取所有的属性以及动态调用任意一个方法，强调的是运行状态。
.
**内省**(IntroSpector)是Java 语言**针对 Bean 类**属性、事件的一种缺省处理方法。　JavaBean是一种特殊的类，主要用于传递数据信息，这种类中的方法主要用于访问私有的字段，且方法名符合某种命名规则。如果在两个模块之间传递信息，可以将信息封装进JavaBean中，这种对象称为“值对象”(Value Object)，或“VO”。方法比较少。这些信息储存在类的私有变量中，通过set()、get()获得。内省机制是通过反射来实现的，BeanInfo用来暴露一个bean的属性、方法和事件，以后我们就可以操纵该JavaBean的属性。

![在这里插入图片描述](D:\Java\笔记\图片\Java版本\内省)

在Java内省中，用到的基本上就是上述几个类。

通过BeanInfo这个类就可以获取到类中的方法和属性。例如类 A 中有属性 name, 那我们可以通过 getName,setName 来得到其值或者设置新的值。通过 getName/setName 来访问 name 属性，这就是默认的规则。

Java 中提供了一套 API 用来访问某个属性的 getter/setter 方法，通过这些 API 可以使你不需要了解这个规则（但你最好还是要搞清楚），这些 API 存放于包 java.beans 中,

一般的做法是通过类 Introspector 的 getBeanInfo方法 来获取某个对象的 BeanInfo 信息,然后通过 BeanInfo 来获取属性的描述器(PropertyDescriptor),通过这个属性描述器就可以获取某个属性对应的 getter/setter 方法,然后我们就可以通过反射机制来调用这些方法，这就是内省机制。

例如类UserInfo :
```java
package com.peidasoft.Introspector;

public class UserInfo {
    private long userId;
    private String userName;
    private int age;
    private String emailAddress;

    public long getUserId() {
        return userId;
    }
    public void setUserId(long userId) {
        this.userId = userId;
    }
    public String getUserName() {
        return userName;
    }
    public void setUserName(String userName) {
        this.userName = userName;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public String getEmailAddress() {
        return emailAddress;
    }
    public void setEmailAddress(String emailAddress) {
        this.emailAddress = emailAddress;
    }
}
```

在类UserInfo中有属性 userName, 那我们可以通过 getUserName,setUserName来得到其值或者设置新的值。通过 getUserName/setUserName来访问 userName属性，这就是默认的规则。 Java JDK中提供了一套 API 用来访问某个属性的 getter/setter 方法，这就是内省。

### JDK内省类库

#### PropertyDescriptor类

`PropertyDescriptor`类表示JavaBean类通过存储器导出一个属性。主要方法如下：

- `getPropertyType()`，获得属性的Class对象;
- `getReadMethod()`，获得用于读取属性值的方法；getWriteMethod()，获得用于写入属性值的方法;
- `hashCode()`，获取对象的哈希值;
- `setReadMethod(Method readMethod)`，设置用于读取属性值的方法;
- `setWriteMethod(Method writeMethod)`，设置用于写入属性值的方法。

　　实例代码如下：

```java
package com.peidasoft.Introspector;

import java.beans.BeanInfo;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.Method;

public class BeanInfoUtil {   
    public static void setProperty(UserInfo userInfo,String userName)throws Exception{
        PropertyDescriptor propDesc=new PropertyDescriptor(userName,UserInfo.class);
        Method methodSetUserName=propDesc.getWriteMethod();
        methodSetUserName.invoke(userInfo, "wong");
        System.out.println("set userName:"+userInfo.getUserName());
    }  
    public static void getProperty(UserInfo userInfo,String userName)throws Exception{
        PropertyDescriptor proDescriptor =new PropertyDescriptor(userName,UserInfo.class);
        Method methodGetUserName=proDescriptor.getReadMethod();
        Object objUserName=methodGetUserName.invoke(userInfo);
        System.out.println("get userName:"+objUserName.toString());
    }
}
```

#### Introspector类

将JavaBean中的属性封装起来进行操作。在程序把一个类当做JavaBean来看，就是调用Introspector.getBeanInfo()方法，得到的BeanInfo对象封装了把这个类当做JavaBean看的结果信息，即属性的信息。

getPropertyDescriptors()，获得属性的描述，可以采用遍历BeanInfo的方法，来查找、设置类的属性。具体代码如下：

```java
package com.peidasoft.Introspector;

import java.beans.BeanInfo;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.Method;


public class BeanInfoUtil {
        
    public static void setPropertyByIntrospector(UserInfo userInfo,String userName)throws Exception{
        BeanInfo beanInfo=Introspector.getBeanInfo(UserInfo.class);
        PropertyDescriptor[] proDescrtptors=beanInfo.getPropertyDescriptors();
        if(proDescrtptors!=null&&proDescrtptors.length>0){
            for(PropertyDescriptor propDesc:proDescrtptors){
                if(propDesc.getName().equals(userName)){
                    Method methodSetUserName=propDesc.getWriteMethod();
                    methodSetUserName.invoke(userInfo, "alan");
                    System.out.println("set userName:"+userInfo.getUserName());
                    break;
                }
            }
        }
    }
    
    public static void getPropertyByIntrospector(UserInfo userInfo,String userName)throws Exception{
        BeanInfo beanInfo=Introspector.getBeanInfo(UserInfo.class);
        PropertyDescriptor[] proDescrtptors=beanInfo.getPropertyDescriptors();
        if(proDescrtptors!=null&&proDescrtptors.length>0){
            for(PropertyDescriptor propDesc:proDescrtptors){
                if(propDesc.getName().equals(userName)){
                    Method methodGetUserName=propDesc.getReadMethod();
                    Object objUserName=methodGetUserName.invoke(userInfo);
                    System.out.println("get userName:"+objUserName.toString());
                    break;
                }
            }
        }
    }
    
}
```

通过这两个类的比较可以看出，都是需要获得PropertyDescriptor，只是方式不一样：前者通过创建对象直接获得，后者需要遍历，所以使用PropertyDescriptor类更加方便。

使用实例：

```java
package com.peidasoft.Introspector;

public class BeanInfoTest {

    /**
     * @param args
     */
    public static void main(String[] args) {
        UserInfo userInfo=new UserInfo();
        userInfo.setUserName("peida");
        try {
            BeanInfoUtil.getProperty(userInfo, "userName");
            
            BeanInfoUtil.setProperty(userInfo, "userName");
            
            BeanInfoUtil.getProperty(userInfo, "userName");
            
            BeanInfoUtil.setPropertyByIntrospector(userInfo, "userName");            
            
            BeanInfoUtil.getPropertyByIntrospector(userInfo, "userName");
            
            BeanInfoUtil.setProperty(userInfo, "age");
            
        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

    }

}
```

输出：

```java
get userName:peida
set userName:wong
get userName:wong
set userName:alan
get userName:alan
java.lang.IllegalArgumentException: argument type mismatch
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
    at java.lang.reflect.Method.invoke(Method.java:597)
    at com.peidasoft.Introspector.BeanInfoUtil.setProperty(BeanInfoUtil.java:14)
    at com.peidasoft.Introspector.BeanInfoTest.main(BeanInfoTest.java:22)
```

**说明：**BeanInfoUtil.setProperty(userInfo, "age");报错是应为age属性是int数据类型，而setProperty方法里面默认给age属性赋的值是String类型。所以会爆出argument type mismatch参数类型不匹配的错误信息。

### BeanUtils工具包

由上述可看出，内省操作非常的繁琐，所以所以Apache开发了一套简单、易用的API来操作Bean的属性——BeanUtils工具包。
BeanUtils工具包：下载：`http://commons.apache.org/beanutils/`　
								 注意：应用的时候还需要一个logging包 `http://commons.apache.org/logging/`

使用BeanUtils工具包完成上面的测试代码:

```java
package com.peidasoft.Beanutil;

import java.lang.reflect.InvocationTargetException;

import org.apache.commons.beanutils.BeanUtils;
import org.apache.commons.beanutils.PropertyUtils;

import com.peidasoft.Introspector.UserInfo;

public class BeanUtilTest {
    public static void main(String[] args) {
        UserInfo userInfo=new UserInfo();
         try {
            BeanUtils.setProperty(userInfo, "userName", "peida");
            
            System.out.println("set userName:"+userInfo.getUserName());
            
            System.out.println("get userName:"+BeanUtils.getProperty(userInfo, "userName"));
            
            BeanUtils.setProperty(userInfo, "age", 18);
            System.out.println("set age:"+userInfo.getAge());
            
            System.out.println("get age:"+BeanUtils.getProperty(userInfo, "age"));
             
            System.out.println("get userName type:"+BeanUtils.getProperty(userInfo, "userName").getClass().getName());
            System.out.println("get age type:"+BeanUtils.getProperty(userInfo, "age").getClass().getName());
            
            PropertyUtils.setProperty(userInfo, "age", 8);
            System.out.println(PropertyUtils.getProperty(userInfo, "age"));
            
            System.out.println(PropertyUtils.getProperty(userInfo, "age").getClass().getName());
                  
            PropertyUtils.setProperty(userInfo, "age", "8");   
        } 
         catch (IllegalAccessException e) {
            e.printStackTrace();
        } 
         catch (InvocationTargetException e) {
            e.printStackTrace();
        }
        catch (NoSuchMethodException e) {
            e.printStackTrace();
        }
    }
}
```

运行结果：

```java
set userName:peida
get userName:peida
set age:18
get age:18
get userName type:java.lang.String
get age type:java.lang.String
8
java.lang.Integer
Exception in thread "main" java.lang.IllegalArgumentException: Cannot invoke com.peidasoft.Introspector.UserInfo.setAge 
on bean class 'class com.peidasoft.Introspector.UserInfo' - argument type mismatch - had objects of type "java.lang.String" 
but expected signature "int"
    at org.apache.commons.beanutils.PropertyUtilsBean.invokeMethod(PropertyUtilsBean.java:2235)
    at org.apache.commons.beanutils.PropertyUtilsBean.setSimpleProperty(PropertyUtilsBean.java:2151)
    at org.apache.commons.beanutils.PropertyUtilsBean.setNestedProperty(PropertyUtilsBean.java:1957)
    at org.apache.commons.beanutils.PropertyUtilsBean.setProperty(PropertyUtilsBean.java:2064)
    at org.apache.commons.beanutils.PropertyUtils.setProperty(PropertyUtils.java:858)
    at com.peidasoft.orm.Beanutil.BeanUtilTest.main(BeanUtilTest.java:38)
Caused by: java.lang.IllegalArgumentException: argument type mismatch
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
    at java.lang.reflect.Method.invoke(Method.java:597)
    at org.apache.commons.beanutils.PropertyUtilsBean.invokeMethod(PropertyUtilsBean.java:2170)
    ... 5 more
```

说明：

1. 获得属性的值，例如，BeanUtils.getProperty(userInfo,"userName")，返回字符串
2. 设置属性的值，例如，BeanUtils.setProperty(userInfo,"age",8)，参数是字符串或基本类型自动包装。设置属性的值是字符串，获得的值也是字符串，不是基本类型。
3. BeanUtils的特点：
   * 对基本数据类型的属性的操作：在WEB开发、使用中，录入和显示时，值会被转换成字符串，但底层运算用的是基本类型，这些类型转到动作由BeanUtils自动完成。
   *  对引用数据类型的属性的操作：首先在类中必须有对象，不能是null，例如，private Date birthday=new Date();。操作的是对象的属性而不是整个对象，例如，BeanUtils.setProperty(userInfo,"birthday.time",111111);　

```java
package com.peidasoft.Introspector;
import java.util.Date;

public class UserInfo {

    private Date birthday = new Date();
    
    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }
    public Date getBirthday() {
        return birthday;
    }      
}
```

```java
package com.peidasoft.Beanutil;

import java.lang.reflect.InvocationTargetException;
import org.apache.commons.beanutils.BeanUtils;
import com.peidasoft.Introspector.UserInfo;

public class BeanUtilTest {
    public static void main(String[] args) {
        UserInfo userInfo=new UserInfo();
         try {
            BeanUtils.setProperty(userInfo, "birthday.time","111111");  
            Object obj = BeanUtils.getProperty(userInfo, "birthday.time");  
            System.out.println(obj);          
        } 
         catch (IllegalAccessException e) {
            e.printStackTrace();
        } 
         catch (InvocationTargetException e) {
            e.printStackTrace();
        }
        catch (NoSuchMethodException e) {
            e.printStackTrace();
        }
    }
}
```

3. PropertyUtils类和BeanUtils不同在于，运行getProperty、setProperty操作时，没有类型转换，使用属性的原有类型或者包装类。由于age属性的数据类型是int，所以方法PropertyUtils.setProperty(userInfo, "age", "8")会爆出数据类型不匹配，无法将值赋给属性。

# 第五章 泛型

集合中可以存放任意对象，只要把对象存储集合后，那么这时他们都会被提升成Object类型。但是，当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。

~~~java
public class GenericDemo {
	public static void main(String[] args) {
		Collection coll = new ArrayList();
		coll.add("abc");
		coll.add("itcast");
		coll.add(5); // 由于集合没有做任何限定，任何类型都可以给其中存放
		Iterator it = coll.iterator();
		while(it.hasNext()){
			//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型
			String str = (String) it.next();
			System.out.println(str.length());
		}
	}
}
~~~

上述程序在运行时发生了问题**java.lang.ClassCastException**类强制转换异常。这是由于集合中什么类型的元素都可以存储，上述集合中存储了int类型的5，取出的时候强制转为String类型，这样导致取出时会产生异常`ClassCastException`强制转换类异常。

```java
Exception in thread "main" java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String
        at com.linxuan.demo01.Demo02.main(Demo02.java:16)
```

Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了**泛型**(**Generic**)语法，在使用API时可以指定类或方法支持泛型，并得到了编译时期的语法检查。

泛型的英文是 generics，generic 的意思是通用，而翻译成中文，泛应该意为广泛，型是类型。所以泛型就是能广泛适用的类型。

但泛型还有一种较为准确的说法就是为了参数化类型，或者说可以将类型当作参数传递给一个类或者是方法。泛型，即“参数化类型”。

**泛型**：可以在类或方法中预支地使用未知的类型。一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。

泛型的优点如下：

* 将运行时期的`ClassCastException`，转移到了编译时期变成了编译失败。
* 避免了向下转型，避免了类型强转的麻烦。
* 优化了程序设计，解决了黄色警告

~~~java
public class GenericDemo2 {
	public static void main(String[] args) {
        Collection<String> list = new ArrayList<String>();
        list.add("abc");
        list.add("itcast");
        // list.add(5);//当集合明确类型后，存放类型不一致就会编译报错
        // 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型
        Iterator<String> it = list.iterator();
        while(it.hasNext()){
            String str = it.next();
            //当使用Iterator<String>控制元素类型后，就不需要强转了。获取到的元素直接就是String类型
            System.out.println(str.length());
        }
	}
}
~~~

## 5.1 泛型的定义与使用

泛型可以用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。定义格式为：`修饰符 class/method/interface 名称<代表泛型的变量> {  }`

使用泛型就是什么时候确定泛型，要求在创建对象的时候确定泛型。 例如，`ArrayList<String> list = new ArrayList<String>();`

### 5.1.1 泛型类

格式：`public class 类名<泛型类型1,...>`

```java
// 此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
// 在实例化泛型类时，必须指定T的具体类型
public class Generic<T,R>{     // 一个类上可以定义多种泛型声明
    // key这个成员变量的类型为T,T的类型由外部指定  
    private T key;

    public Generic(T key) { // 泛型构造方法形参key的类型也为T，T的类型由外部指定
        this.key = key;
    }
     
    public T getKey(){ // 泛型方法getKey的返回值类型为T，T的类型由外部指定
        return key;
    }
    public R fun(T p){  // R是返回值类型，T为方法参数类型
        teturn null;    
    }
}
```

```java
public class GenericTest{
    public static void main(String[] args){
       // 泛型的类型参数只能是类类型（包括自定义类），不能是简单类型
       // 传入的实参类型需与泛型的类型参数类型相同，即为Integer.
       Generic<Integer,String> genericInteger = new Generic<Integer,String>(123456);
       // 传入的实参类型需与泛型的类型参数类型相同，即为String.
       Generic<String,Integer> genericString = new Generic<String,Integer>("key_vlaue");
       System.out.println("泛型测试","key is " + genericInteger.getKey());
       System.out.println("泛型测试","key is " + genericString.getKey());
    }
}

/*
    泛型测试: key is 123456
    泛型测试: key is key_vlaue
*/
```

泛型类的所有实例都具有相同的运行时类，而不管它们的实际类型参数如何。

```java
List<String> l1 = new ArrayList<String>();
List<Integer> l2 = new ArrayList<Integer>();
System.out.println(l1.getClass()== l2.getClass());    //true
```

注意：

* 定义的泛型类，要么传入所有的泛型类型实参，要么不传入任何泛型类型实参。
* 泛型的类型参数只能是类类型，不能是简单类型。
* 不能对确切的泛型类型使用`instanceof`操作。如下操作是非法的，编译时会报错。`if(ex_num instanceof Generic<Number>){}`

### 5.1.2 泛型方法

格式：`修饰符<泛型类型> 返回值类型 方法名(参数列表){}`

1. 泛型方法即在方法上设置泛型类型，参数中可以出现泛型类或类中未定义的泛型标识。
2. 在方法上定义泛型时，这个方法不一定要在泛型类中定义。
3. 泛型方法中可以出现任意多个泛型标识符。
4. 静态的泛型方法需要额外的泛型声明，即使使用了泛型类声明过的泛型类型。
5. 静态方法若有返回值其类型不能为泛型。

```java
class Generic<T>{
	private T key;

	//这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。
	public T getKey(){
	    return key;
    }
    
	/* 因为在类的声明中并未声明泛型K，所以在使用K做形参和返回值类型时，编译器会无法识别。
	 * K cannot be resolved to a type
	 * public K setKey(K key){	
	    this.key = key;
	}*/
    
	// 在泛型类中声明了一个泛型方法，使用泛型T，这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型
	public <T> void show(T t){
		System.out.println(t);
	}
    
	public <E> T fun(E e){
		System.out.println(e);
		return key;
	}
    
	//泛型的数量也可以为任意多个 
	public <R,V> R showKeyName(R r,V v){
		return null;
	} 
    
	/*
	 * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）
	 * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。
	 * 如：public static void method(T t){...},此时编译器会提示错误信息：
	 * Cannot make a static reference to the non-static type T
	 */
	public static <E> void method(E t){}

}
```

```java
public class GenericTest {
	public static void main(String[] args) {
		Generic od = new Generic();
		od.show("hello");    //hello
		Generic<Integer> od2 = new Generic<Integer>();
		od2.show(132);       //132
	}
}
```

### 5.1.3 泛型接口

格式：`public interface 接口名<泛型类型1,...>`

任何情况下如果要使用接口，就必须定义相应的子类，而对于实现了泛型接口的子类而言，有以下两种实现方式：

1. 在子类继续设置泛型标记
2. 在子类不是设置泛型，而为接口明确定义一个泛型类型

```java
// 泛型接口
interface Inter<T>{
	void show(T t);
}
```

```java
// 实现类
// 1)知道实现什么泛型
class InterImpl implements Inter<String>{
	@Override
	public void show(String s) {
		System.out.println(s);
	}
}
// 2)不知道实现什么泛型
class InterImpl02<T> implements Inter<T>{
	@Override
	public void show(T t) {
		System.out.println(t);
	}
}
```

```java
public class GenericDemo03 {
	public static void main(String[] args) {
		// 1)
		InterImpl i = new InterImpl();
		i.show("hello");           // hello
		
		// 2)
		InterImpl02<String> i2 = new InterImpl02<String>();
		i2.show("world");          //world
		InterImpl02<Integer> i3 = new InterImpl02<Integer>();
		i3.show(13);               //13
	}    
}
```

如果不声明泛型，如：`class InterImpl02 implements Inter<T>`，编译会报错`“Unknown class”`

## 5.2 泛型通配符

除了用 `<T>`表示泛型外，还有 `<?>`这种形式。`？` 被称为通配符。

```java
class Base{}

class Sub extends Base{}

Sub sub = new Sub();
Base base = sub;			
```

```java
List<Sub> lsub = new ArrayList<>();
List<Base> lbase = lsub;
```

最后一行代码成立吗？编译会通过吗？答案是否定的。编译器不会让它通过的。Sub 是 Base 的子类，不代表 `List<Sub>`和 `List<Base>`有继承关系。

但是，在现实编码中，确实有这样的需求，希望泛型能够处理某一范围内的数据类型，比如某个类和它的子类，对此 Java 引入了通配符这个概念。所以，**通配符的出现是为了指定泛型中的类型范围**。

* `?`：表示任意类型
* `？ extends 类`：上边界限定通配符；
* `? super 类`：下边界限定通配符；

```java
//通配符
class Animal{}
class Cat extends Animal{}
class Dog extends Animal{}
```

```java
public class GenericDemo05 {
	public static void main(String[] args) {
		//？ 任意类型
		Collection<?> c1 = new ArrayList<Animal>();
		Collection<?> c2 = new ArrayList<Cat>();
		Collection<?> c3 = new ArrayList<Dog>();
		
		//? extends E 
		Collection<? extends Animal> c4 = new ArrayList<Cat>();
		Collection<? extends Animal> c5 = new ArrayList<Dog>();
		Collection<? extends Animal> c6 = new ArrayList<Animal>();
         // 编译无法通过
		// Collection<? extends Animal> c4 = new ArrayList<Object>();
		
		//? super E
		Collection<? super Animal> c7 = new ArrayList<Animal>();
		Collection<? super Animal> c8 = new ArrayList<Object>();
        // 编译无法通过
        // Collection<? super Animal> c7 = new ArrayList<Cat>();	
	}
}
```

### 5.2.1 无限定通配符

无限定通配符经常与容器类配合使用，它其中的 `?` 其实代表的是未知类型，所以涉及到 `?` 时的操作，一定与具体类型无关。

```
public void testWildCards(Collection<?> collection){
}
```

上面的代码中，方法内的参数是被无限定通配符修饰的 `Collection` 对象，它隐略地表达了一个意图或者可以说是限定，那就是 `testWidlCards()` 这个方法内部无需关注 `Collection` 中的真实类型，因为它是未知的。所以我们只能调用 `Collection` 中与类型无关的方法。

![](D:\Java\笔记\图片\1-00【Java基础】\11-0.png)

我们可以看到，当 `<?>`存在时，`Collection` 对象丧失了 `add()` 方法的功能，编译器不通过。再看如下代码：

```java
List<?> list = new ArrayList<String>();
list.add(123); // 编译不通过
```

`<?>`提供了只读的功能，也就是它删减了增加具体类型元素的能力，只保留与具体类型无关的功能。它不管装载在这个容器内的元素是什么类型，它只关心元素的数量、容器是否为空？我想这种需求还是很常见的吧。

这样提高了代码的可读性，程序员看到这段代码时，就能够迅速对此建立极简洁的印象，能够快速推断源码作者的意图。

### 5.2.2 上边界限定通配符

上边界限定通配符：`？ extends 类`。最上面只能是该类。

上界`<? extends T>`不能往里存，只能往外取

```java
public class GenericsAndCovariance {
    public static void main(String[] args) {
        // Wildcards allow covariance:
        List<? extends Fruit> list = new ArrayList<Apple>();
        // Compile Error: can’t add any type of object:
        // list.add(new Apple());
        // list.add(new Fruit());
        // list.add(new Object());
        list.add(null); // Legal but uninteresting
        // We know that it returns at least Fruit:
        Fruit f = list.get(0);
    }
}
```

如上所述，通配符 `List<? extends Fruit>` 表示某种特定类型 ( `Fruit` 或者其子类 ) 的 List，但是并不关心这个实际的类型到底是什么，反正是 `Fruit` 的子类型，`Fruit` 是它的上边界。

其实如果我们不知道这个 List 到底持有什么类型，怎么可能安全的添加一个对象呢？在上面的代码中，向 `list` 中添加任何对象，无论是 `Apple` 还是 `Orange` 甚至是 `Fruit` 对象，编译器都不允许，唯一可以添加的是 `null`。所以如果做了泛型的向上转型 (`List<? extends Fruit> list = new ArrayList<Apple>()`)，那么我们也就失去了向这个 List 添加任何对象的能力，即使是 `Object` 也不行。

另一方面，如果调用某个返回 `Fruit` 的方法，这是安全的。因为我们知道，在这个 List 中，不管它实际的类型到底是什么，但肯定能转型为 `Fruit`，所以编译器允许返回 `Fruit`。

了通配符的作用和限制后，好像任何接受参数的方法我们都不能调用了。其实倒也不是，看下面的例子：

```java
public class CompilerIntelligence {
    public static void main(String[] args) {
        List<? extends Fruit> flist = Arrays.asList(new Apple());
        Apple a = (Apple)flist.get(0); // No warning
        flist.contains(new Apple()); // Argument is ‘Object’
        flist.indexOf(new Apple()); // Argument is ‘Object’
        
        // flist.add(new Apple());   无法编译
    }
}
```

在上面的例子中，`flist` 的类型是 `List<? extends Fruit>`，泛型参数使用了受限制的通配符，所以我们失去了向其中加入任何类型对象的例子，最后一行代码无法编译。

但是 `flist` 却可以调用 `contains` 和 `indexOf` 方法，它们都接受了一个 `Apple` 对象做参数。如果查看 `ArrayList` 的源代码，可以发现 `add()` 接受一个泛型类型作为参数，但是 `contains` 和 `indexOf` 接受一个 `Object` 类型的参数，下面是它们的方法签名：

```java
public boolean add(E e)
public boolean contains(Object o)
public int indexOf(Object o)
```

所以如果我们指定泛型参数为 `<? extends Fruit>` 时，`add()` 方法的参数变为 `? extends Fruit`，编译器无法判断这个参数接受的到底是 `Fruit` 的哪种类型，所以它不会接受任何类型。

然而，`contains` 和 `indexOf` 的类型是 `Object`，并没有涉及到通配符，所以编译器允许调用这两个方法。这意味着一切取决于泛型类的编写者来决定那些调用是 “安全” 的，并且用 `Object` 作为这些安全方法的参数。如果某些方法不允许类型参数是通配符时的调用，这些方法的参数应该用类型参数，比如 `add(E e)`。

当我们自己编写泛型类时，上面介绍的就有用了。下面编写一个 `Holder` 类：

```java
public class Holder<T> {
    
    private T value;
    public Holder() {}
    public Holder(T val) { value = val; }
    public void set(T val) { value = val; }
    public T get() { return value; }
    public boolean equals(Object obj) {
    	return value.equals(obj);
    }
    
    public static void main(String[] args) {
        
        Holder<Apple> Apple = new Holder<Apple>(new Apple());
        Apple d = Apple.get();
        Apple.set(d);
        
        // Holder<Fruit> Fruit = Apple; // Cannot upcast
        Holder<? extends Fruit> fruit = Apple; // OK
        Fruit p = fruit.get();
        d = (Apple)fruit.get(); // Returns ‘Object’
        
        try {
            Orange c = (Orange)fruit.get(); // No warning
        } catch(Exception e) { 
            System.out.println(e); 
        }
        
        // fruit.set(new Apple()); // Cannot call set()
        // fruit.set(new Fruit()); // Cannot call set()
        System.out.println(fruit.equals(d)); // OK
    }
} 
/* Output: (Sample)
java.lang.ClassCastException: Apple cannot be cast to Orange
true
*///:~

```

在 `Holer` 类中，`set()` 方法接受类型参数 `T` 的对象作为参数，`get()` 返回一个 `T` 类型，而 `equals()` 接受一个 `Object` 作为参数。`fruit` 的类型是 `Holder<? extends Fruit>`，所以`set()`方法不会接受任何对象的添加，但是 `equals()` 可以正常工作。

### 5.2.3 下边界限定通配符

通配符的另一个方向是“超类型的通配符“: `? super T`，`T` 是类型参数的下界。使用这种形式的通配符，我们就可以 ”传递对象” 了。

`List<? super T>`因为存的都是类型T的父类，所以如果去添加T类或者T类子类的元素，肯定是可以的。但是如果将元素取出来，则不知道到底是什么类型，所以`? super T`可以添加元素但是没法取出来，这个叫put原则。

还是用例子解释：

```java
public class SuperTypeWildcards {
    static void writeTo(List<? super Apple> apples) {
        apples.add(new Apple());
        apples.add(new Jonathan());
        // apples.add(new Fruit()); // Error
    }
}
```

`writeTo` 方法的参数 `apples` 的类型是 `List<? super Apple>`，它表示某种类型的 List，这个类型是 `Apple` 的基类型。也就是说，我们不知道实际类型是什么，但是这个类型肯定是 `Apple` 的父类型。因此，我们可以知道向这个 List 添加一个 `Apple` 或者其子类型的对象是安全的，这些对象都可以向上转型为 `Apple`。但是我们不知道加入 `Fruit` 对象是否安全，因为那样会使得这个 List 添加跟 `Apple` 无关的类型。

在了解了子类型边界和超类型边界之后，我们就可以知道如何向泛型类型中 “写入” ( 传递对象给方法参数) 以及如何从泛型类型中 “读取” ( 从方法中返回对象 )。下面是一个例子：

```java
public class Collections { 
    public static <T> void copy(List<? super T> dest, List<? extends T> src) {
        for (int i = 0; i < src.size(); i++) 
            dest.set(i,src.get(i)); 
    } 
}
```

`src` 是原始数据的 List，因为要从这里面读取数据，所以用了上边界限定通配符：`<? extends T>`，取出的元素转型为 `T`。`dest` 是要写入的目标 List，所以用了下边界限定通配符：`<? super T>`，可以写入的元素类型是 `T` 及其子类型。

## 5.3 类型擦除

```java
List<String> l1 = new ArrayList<String>();
List<Integer> l2 = new ArrayList<Integer>();
		
System.out.println(l1.getClass() == l2.getClass());
```

正确答案是 true。上面的代码中涉及到了泛型，而输出的结果缘由是**类型擦除**。泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除。通俗地讲，泛型类和普通类在 java 虚拟机内是没有什么特别的地方。

打印的结果为 true 是因为 `List<String>`和 `List<Integer>`在 jvm 中的 Class 都是 List.class，泛型信息被擦除了。而类型 String 和 Integer之间就发生了泛型转译。

### 5.3.1 反射研究类型擦除

我们可以通过反射来看一下，Erasure 是一个泛型类，我们查看它在运行时的状态信息可以通过反射：

```java
public class Erasure <T>{
	T object;

	public Erasure(T object) {
		this.object = object;
	}
}
```

```java
Erasure<String> erasure = new Erasure<String>("hello");
Class clazz = erasure.getClass();
System.out.println("erasure class is:" + clazz.getName());
// 打印结果：erasure class is:com.linxuan.demo01.Erasure
```

Class 的类型仍然是 Erasure 并不是 `Erasure<T>`这种形式，那我们再看看泛型类中 `T` 的类型在 `jvm` 中是什么具体类型：

```java
Field[] fs = clazz.getDeclaredFields();
for (Field f : fs) {
    // 打印结果为：Field name object type:java.lang.Object
	System.out.println("Field name " + f.getName() + " type:" + f.getType().getName());
}
```

那我们可不可以说，泛型类被类型擦除后，相应的类型就被替换成 Object 类型呢？这种说法，不完全正确。我们更改一下代码。

```java
public class Erasure <T extends String>{
//	public class Erasure <T>{
	T object;

	public Erasure(T object) {
		this.object = object;
	}
}
```

现在再看测试结果：`Field name object type:java.lang.String`

我们现在可以下结论了，在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 `<T>`则会被转译成普通的 Object 类型，如果指定了上限如 `<T extends String>`则类型参数就被替换成类型上限。

所以在反射中，下面的代码中的`add()` 这个方法对应的 Method 的签名应该是 `Object.class`。

```java
public class Erasure <T>{
	T object;

	public Erasure(T object) {
		this.object = object;
	}
	
	public void add(T object){
	}
}
```

```java
Erasure<String> erasure = new Erasure<String>("hello");
Class clazz = erasure.getClass();
System.out.println("erasure class is:" + clazz.getName());

Method[] methods = clazz.getDeclaredMethods();
for ( Method m:methods ){
     // 打印结果为： method:public void com.frank.test.Erasure.add(java.lang.Object)
	System.out.println(" method:"+m.toString());
}
```

也就是说，如果要在反射中找到 add 对应的 Method，应该调用 `getDeclaredMethod("add",Object.class)`否则程序会报错，提示没有这么一个方法，原因就是类型擦除的时候，T 被替换成 Object 类型了。

### 5.3.2 类型擦除局限性

类型擦除，是泛型能够与之前的 java 版本代码兼容共存的原因。但也因为类型擦除，它会抹掉很多继承相关的特性，这是它带来的局限性。

理解类型擦除有利于我们绕过开发当中可能遇到的雷区，同样理解类型擦除也能让我们绕过泛型本身的一些限制。比如下面的代码：

![](D:\Java\笔记\图片\1-00【Java基础】\11-1.png)

正常情况下，因为泛型的限制，编译器不让最后一行代码编译通过，因为类似不匹配，但是，基于对类型擦除的了解，利用反射，我们可以绕过这个限制。

```java
// List接口和其中的 add() 方法的源码
public interface List<E> extends Collection<E>{
	 boolean add(E e);
}
```

因为 E 代表任意的类型，所以类型擦除时，add 方法其实等同于

```java
boolean add(Object obj);
```

那么，利用反射，我们绕过编译器去调用 add 方法。

```java
public class Demo01 {
    public static void main(String[] args) throws Exception {
		List<Integer> list = new ArrayList<>();
		list.add(123);
		// 编译无法通过
		// list.add("test");

		Class<? extends List> clazz = list.getClass();
		Method method = clazz.getDeclaredMethod("add", Object.class);
		method.invoke(list, "test");
		method.invoke(list, 42.9f);

		for (Object o : list){
			System.out.println(o);
		}
	}
}
```

打印结果是：

```html
<!--
    23
    test
    42.9
-->
```

可以看到，利用类型擦除的原理，用反射的手段就绕过了正常开发中编译器不允许的操作限制。

## 5.4 泛型与数组

> 简单看看

在The Java™ Tutorials: Generics中讲到了泛型数组，并说道：除非使用通配符，否则一个数组对象的元素不能是泛型。即：在java中是”不能创建一个确切的泛型类型的数组”的。也就是说下面的这个例子是不可以的：

```java
// Cannot create a generic array of ArrayList<String>
List<String>[] ls = new ArrayList<String>[10];
```

 而使用通配符创建泛型数组是可以的，如下面这个例子：

```java
List<?>[] ls = new ArrayList<?>[10]; 
//这样也是可以的：
List<String>[] ls = new ArrayList[10];
```

这么做的原因，是为了防止下述代码产生的类型安全问题：

```java
// Not really allowed.
List<String>[] lsa = new List<String>[10];     //1
Object o = lsa;
Object[] oa = (Object[]) o;
List<Integer> li = new ArrayList<Integer>();
li.add(new Integer(3));
// Unsound, but passes run time store check
oa[1] = li;

// Run-time error: ClassCastException.
String s = lsa[1].get(0);                      //2
```

如果允许泛型数组的存在（第1处代码编译通过），那么在第2处代码就会报出`ClassCastException`，因为lsa[1]是List<Integer>。Java设计者本着首要保证类型安全（type-safety）的原则，不允许泛型数组的存在，使得编译期就可以检查到这类错误。

解决方案

但是连Java的设计者也承认，这样在使用上很令人恼火（原文是annoying），所以提供了变向的解决方案：显式类型转换。

①通配符

The Java™ Tutorials: Generics给出的解决方案如下：

```java
// OK, array of unbounded wildcard type.
List<?>[] lsa = new List<?>[10];                //1
Object o = lsa;
Object[] oa = (Object[]) o;
List<Integer> li = new ArrayList<Integer>();
li.add(new Integer(3));
// Correct.
oa[1] = li;
// Run time error, but cast is explicit.
String s = (String) lsa[1].get(0);              //2
```

 在第1处，用?取代了确定的参数类型。根据通配符的定义以及Java类型擦除的保留上界原则，在2处lsa[1].get(0)取出的将会是Object，所以需要程序员做一次显式的类型转换。

②反射

使用java.util.reflect.Array，可以不使用通配符，而达到泛型数组的效果：

```java
List<String>[] lsa = (List<String>[])Array.newInstance(ArrayList.class, 4);     //1
Object o = lsa;
Object[] oa = (Object[]) o;
List<Integer> li = new ArrayList<Integer>();
li.add(new Integer(3));
// Correct.
oa[1] = li;
// Run time error, but cast is explicit.
String s = lsa[1].get(0);                                                      //2
```

 可以看到，我们利用了Array.newInstance()生成了泛型数组，这里没有使用任何通配符，在第2处也没有做显式的类型转换，但是在第1处，仍然存在显式类型转换。

类似地，尝试创建元素类型为类型变量的数组对象会导致编译时错误：

```java
//不能用泛型来建立数组的实例
private T[] arr= new T[10];    //Cannot create a generic array of T
//可以参数化数组本身类型
private T[] arr;

<T> T[] makeArray(T t) {
    return new T[100]; // Error.
}
```

# 第六章 for-each循环

foreach 语法格式如下：

```java
for(元素类型t 元素变量x : 遍历对象obj){ 
     引用了x的java语句; 
} 
```

* 实例：用foreach遍历数组、集合

  ```java
  import java.util.ArrayList;
  import java.util.List;
   
  public class AddForDemo {
  	public static void main(String[] args) {
  		// foreach遍历数组
  		int[] arr = {1,2,3,4,5};
  		for(int num:arr){//num指的是arr数组里面所有元素
  			System.out.println(num);
  		}
  		//foreach遍历List
  		List<String> list = new ArrayList<String>();
  		list.add("hello");
  		list.add("world");
  		list.add("java");
  		for(String str:list){//str指的是list集合中所有元素
  			System.out.println(str);
  		}
  	}
  }
  ```

> **注意：**foreach虽然能遍历数组或者集合，但是只能用来遍历，无法在遍历的过程中对数组或者集合进行修改，而for循环可以在遍历的过程中对源数组或者集合进行修改。

* 实例：

  ```java
  public static void main(String[] args) {
      List<String> names = new ArrayList<String>();
      names.add("beibei");
      names.add("jingjing");
      //foreach
      for(String name:names){
        name = "huanhuan";
      }
      System.out.println(Arrays.toString(names.toArray()));
      //for
      for (int i = 0; i < names.size(); i++) {
        names.set(i,"huanhuan");
      }
      System.out.println(Arrays.toString(names.toArray()));
    }
  }
   
  输出：
  [beibei, jingjing]
  [huanhuan, huanhuan]
  ```

foreach遍历的是一组元素，但可以在外部定义一个索引(int index = 0;)，在内部进行自增操作(index++)，来实现类似普通for中需要使用索引的操作。

foreach遍历集合类型和数组类型底层实现的不同

- 集合类型的遍历本质是使用迭代器实现的
- 数组的遍历是通过for循环来实现的



