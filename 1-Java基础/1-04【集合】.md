 **集合**：集合是java中提供的一种容器，可以用来存储多个数据。

集合和数组既然都是容器，它们有啥区别呢？

* 数组的长度是固定的。集合的长度是可变的。
* 数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。

JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。

由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：

- `Hashtable`：一种线程安全的`Map`实现；
- `Vector`：一种线程安全的`List`实现；
- `Stack`：基于`Vector`实现的`LIFO`的栈。

还有一小部分接口是遗留接口，也不应该继续使用：

- `Enumeration<E>`：已被`Iterator<E>`取代。

集合按照其存储结构可以分为两大类，分别是单列集合`java.util.Collection`和双列集合`java.util.Map`。

# 第一章 Collection集合

**Collection**：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是`java.util.List`、`java.util.Queue`和`java.util.Set`。

`List`的特点是元素有序、元素可重复。`Set`的特点是元素无序，而且不可重复。`List`接口的主要实现类有`java.util.ArrayList`和`java.util.LinkedList`，`Set`接口的主要实现类有`java.util.HashSet`和`java.util.TreeSet`。

![](D:\Java\笔记\图片\1-04【集合】\1-1.png)

集合本身是一个工具，它存放在java.util包中。在`Collection`接口定义着单列集合框架中最共性的内容。

## 1.1 Collection 常用功能

Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：

* `public boolean add(E e)`：  把给定的对象添加到当前集合中 。
* `public void clear()` :清空集合中所有的元素。
* `public boolean remove(E e)`: 把给定的对象在当前集合中删除。
* `public boolean contains(E e)`: 判断当前集合中是否包含给定的对象。
* `public boolean isEmpty()`: 判断当前集合是否为空。
* `public int size()`: 返回集合中元素的个数。
* `public Object[] toArray()`: 把集合中的元素，存储到数组中。

## 1.2 List接口

`java.util.List`接口继承自`Collection`接口，是单列集合的一个重要分支，习惯性地会将实现了`List`接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。

List接口特点：

1. 它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。
2. 它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。
3. 集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。

### 1.2.1 List接口中常用方法

List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：

- `public void add(int index, E element)`: 将指定的元素，添加到该集合中的指定位置上。
- `public E get(int index)`:返回集合中指定位置的元素。索引从0开始。
- `public E remove(int index)`: 移除列表中指定位置的元素, 返回的是被移除的元素。
- `public E set(int index, E element)`:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。

### 1.2.1 Vector

Vector 类实现了一个动态数组。和 ArrayList 很相似，但是两者是不同的：

- Vector 是同步访问的。
- Vector 包含了许多传统的方法，这些方法不属于集合框架。

Vector 主要用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况。

```java
public class Vector<E>
    extends AbstractList<E>
    implements List<E>, RandomAccess, Cloneable, java.io.Serializable{}
```

### 1.2.2 ArrayList集合

![](D:\Java\笔记\图片\1-04【集合】\2-2.png)

`java.util.ArrayList`集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以`ArrayList`是最常用的集合。

`ArrayList`是一个动态数组，查询快效率、而在增、删的过程中会涉及到数组的复制，所以效率低。`ArrayList`是线程不安全的，运行效率快，允许元素为`null`。

> 增如果导致扩容，则会修改`modCount`；删一定会修改`modCount`；改和查一定不会修改`modCount`。

* 当修改、查询或者只在数组末尾增、删时，时间复杂度为`O(1)`；
* 对指定位置的元素进行增、删时，时间复杂度为`O(n)`。

ArrayList的底层是数组，数组的名称是`elementData`，类型是`Object[]`，所以`ArrayList`里面可以存放任意类型的元素。

```java
// 定义elementData数组 对于transient修饰的成员变量，在类的实例对象的序列化处理过程中会被忽略。
transient Object[] elementData; // non-private to simplify nested class access

public ArrayList() {
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}
```

ArrayList底层数组的默认初始化容量是10。当超出这个大小时，每次扩容1.5倍。当向`ArrayList`中增加一个对象的时候，Java首先会判断`ArrayList`的底层数组`elementData`是否还有足够的空间来存储这个对象，如果有，就直接存，如果没有，就会基于原有的数组扩容出一个1.5倍的新数组，并将数据全部复制到新数组中。新建了一个数组，旧数组的对象被复制到了新的数组中，并且现有的数组引用指向新的数组。

ArrayList集合中方法执行流程：

- 当向ArrayList集合中添加元素时需要调用`add()`方法，执行流程如下：

  * 调用`add()`方法时，`add()`方法首先调用`ensureCapacityInternal()`来判断`elementData`数组容量是否足够。
  * `ensureCapacityInternal()`之所以能够判断，是因为它内部调用了`ensureExplicitCapacity()`方法，这个方法才是真正判断`elementData`数组容量是否够用的关键方法。
  * 如果容量足够，则直接将元素添加到`ArrayList`中；如果容量不够，则`ensureExplicityCapacity()`方法内部会调用`grow()`方法来对数组进行扩容。扩容成功之后，再将元素添加到`ArrayList`扩容之后的新数组中。

- 在调用ArrayList的`remove(int index)`方法时，执行流程如下：

  * 首先判断`index`是否合理，如果合理的话，会调用`System.arraycopy()`方法把指定下标到数组末尾的元素向前移动一个单位，并且会把数组最后一个元素设为`null`。这样是为了方便GC回收。
- ArrayList在调用`get(int index)`方法查询的时候，执行流程如下：

  * 首先判断`index`是否合理，然后调用`elementData()`方法，`elementData()`方法返回根据i`ndex`查到的具体的元素。这里的返回值都经过了向下转型（Object -> E）


### 1.2.3 LinkedList集合

`java.util.LinkedList`集合数据存储的结构是链表结构。方便元素添加、删除的集合。LinkedList是一个双向链表。

实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可：

* `public void addFirst(E e)`:将指定元素插入此列表的开头。
* `public void addLast(E e)`:将指定元素添加到此列表的结尾。
* `public E getFirst()`:返回此列表的第一个元素。
* `public E getLast()`:返回此列表的最后一个元素。
* `public E removeFirst()`:移除并返回此列表的第一个元素。
* `public E removeLast()`:移除并返回此列表的最后一个元素。
* `public E pop()`:从此列表所表示的堆栈处弹出一个元素。
* `public void push(E e)`:将元素推入此列表所表示的堆栈。
* `public boolean isEmpty()`：如果列表不包含元素，则返回true。

LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。

### 1.2.4 ArrayList 和 LinkedList

* `ArrayList`的底层数据结构为数组，增删慢、查询快，线程不安全，效率高。当对数据的主要操作为索引或只在集合的末端增加、删除数据时，使用`ArrayList`效率比较高；

* `LinkedList`的底层数据结构为链表，增删快、查询慢，线程不安全，效率高。当对数据的操作主要为指定位置的插入或删除操作时，使用`LinkedList`效率比较高。

从底层实现角度来看：

- `ArrayList`：是基于动态数组的数据结构；名称是`elementData`，类型是`Object[]`，所以`ArrayList`里面可以存放任意类型的元素

- `LinkedList`：是基于双向循环链表的数据结构

从随机访问（索引）元素角度来看：

- `ArrayList`：数据存储是连续的，因此支持用下标来访问元素`get(int index)`，直接返回`index`位置上的元素，随机访问元素速度快 `O(1)`
- `LinkedList`：需要通过`for`循环进行查找，虽然`LinkedList`已经在查找方法上做了优化，比如`index < size / 2`，则从左边开始查找，反之从右边开始查找，但是还是比`ArrayList`要慢。 `O(N)`

从插入，删除元素角度来看：

- `ArrayList`：想要在指定位置插入或删除元素时，主要耗时的是`System.arraycopy`动作，会移动`index`后面所有的元素，从而会重新调整索引顺序,调整索引顺序会消耗一定的时间，所以速度上就会比`LinkedList`要慢许多；`O(N)`
- `LinkedList`：主耗时的是要先通过`for`循环找到`index`，再改变前后对象的引用，然后直接插入或删除，效率较高。`O(N)`

从初始容量和扩容来看：

- `ArrayList`：默认初始化容量是10，当存储元素大小超过初始容量时，需要动态扩容为原来的1.5倍加1。

  如果设置后的新容量还不够，则直接新容量设置为传入的参数（也就是所需的容量），而后用`Arrays.copyof()`方法将元素拷贝到新的数组。从中可以看出，当容量不够时，每次增加元素，都要将原来的元 素拷贝到一个新的数组中，非常之耗时。因此我们可以指定容量，避免扩容，

- `LinkedList`：使用了链表的结构，因此不需要维护容量的大小。

从实现栈和队列角度来看：

- `LinkedList`要优于`ArrayList`。因为`LinkedList`是个双向链表，它同样可以被当作栈、队列或双端队列来使用。例如`Queue queue=new LinkedList<>()`;

**当对数据的主要操作为索引或者只在集合末端增加、删除元素时候，使用ArrayList效率比较高。当对数据的主要操作为指定位置的插入或者删除操作时，使用LinkedList效率比较高。**

## 1.3 Queue接口

队列（`Queue`）是一种经常使用的集合。`Queue`实际上是实现了一个先进先出（FIFO：First In First Out）的有序表。它和`List`的区别在于，`List`可以在任意位置添加和删除元素，而`Queue`只有两个操作：

- 把元素添加到队列末尾；
- 从队列头部取出元素。

在Java的标准库中，队列接口`Queue`定义了以下几个方法：

- `int size()`：获取队列长度；
- `boolean add(E)`/`boolean offer(E)`：添加元素到队尾；
- `E remove()`/`E poll()`：获取队首元素并从队列中删除；
- `E element()`/`E peek()`：获取队首元素但并不从队列中删除。

对于具体的实现类，有的Queue有最大队列长度限制，有的Queue没有。注意到添加、删除和获取队列元素总是有两个方法，这是因为在添加或获取元素失败时，这两个方法的行为是不同的。我们用一个表格总结如下：

|                    | throw Exception | 返回false或null    |
| :----------------- | :-------------- | ------------------ |
| 添加元素到队尾     | add(E e)        | boolean offer(E e) |
| 取队首元素并删除   | E remove()      | E poll()           |
| 取队首元素但不删除 | E element()     | E peek()           |

注意：不要把`null`添加到队列中，否则`poll()`方法返回`null`时，很难确定是取到了`null`元素还是队列为空。

### 1.3.1 PriorityQueue

优先队列：`PriorityQueue`。

`PriorityQueue`和`Queue`的区别在于，它的出队顺序与元素的优先级有关，对`PriorityQueue`调用`remove()`或`poll()`方法，返回的总是优先级最高的元素。

要使用`PriorityQueue`，我们就必须给每个元素定义“优先级”。我们以实际代码为例，先看看`PriorityQueue`的行为：

```java
public class Main {
    public static void main(String[] args) {
        Queue<String> q = new PriorityQueue<>();
        // 添加3个元素到队列:
        q.offer("apple");
        q.offer("pear");
        q.offer("banana");
        System.out.println(q.poll()); // apple
        System.out.println(q.poll()); // banana
        System.out.println(q.poll()); // pear
        System.out.println(q.poll()); // null,因为队列为空
    }
}
```

我们放入的顺序是`"apple"`、`"pear"`、`"banana"`，但是取出的顺序却是`"apple"`、`"banana"`、`"pear"`，这是因为从字符串的排序看，`"apple"`排在最前面，`"pear"`排在最后面。

因此，放入`PriorityQueue`的元素，必须实现`Comparable`接口，`PriorityQueue`会根据元素的排序顺序决定出队的优先级。

如果我们要放入的元素并没有实现`Comparable`接口怎么办？`PriorityQueue`允许我们提供一个`Comparator`对象来判断两个元素的顺序。我们以银行排队业务为例，实现一个`PriorityQueue`：

```java
public class Main {
    public static void main(String[] args) {
        Queue<User> q = new PriorityQueue<>(new UserComparator());
        // 添加3个元素到队列:
        q.offer(new User("Bob", "A1"));
        q.offer(new User("Alice", "A2"));
        q.offer(new User("Boss", "V1"));
        System.out.println(q.poll()); // Boss/V1
        System.out.println(q.poll()); // Bob/A1
        System.out.println(q.poll()); // Alice/A2
        System.out.println(q.poll()); // null,因为队列为空
    }
}
```

```java
class UserComparator implements Comparator<User> {
    public int compare(User u1, User u2) {
        if (u1.number.charAt(0) == u2.number.charAt(0)) {
            // 如果两人的号都是A开头或者都是V开头,比较号的大小:
            return u1.number.compareTo(u2.number);
        }
        if (u1.number.charAt(0) == 'V') {
            // u1的号码是V开头,优先级高:
            return -1;
        } else {
            return 1;
        }
    }
}
```

### 1.3.2 Deque

我们知道，`Queue`是队列，只能一头进，另一头出。

如果把条件放松一下，允许两头都进，两头都出，这种队列叫双端队列（Double Ended Queue），学名`Deque`。

Java集合提供了接口`Deque`来实现一个双端队列，它的功能是：

- 既可以添加到队尾，也可以添加到队首；
- 既可以从队首获取，又可以从队尾获取。

我们来比较一下`Queue`和`Deque`出队和入队的方法：

|                    | Queue                  | Deque                           |
| :----------------- | :--------------------- | ------------------------------- |
| 添加元素到队尾     | add(E e) / offer(E e)  | addLast(E e) / offerLast(E e)   |
| 取队首元素并删除   | E remove() / E poll()  | E removeFirst() / E pollFirst() |
| 取队首元素但不删除 | E element() / E peek() | E getFirst() / E peekFirst()    |
| 添加元素到队首     | 无                     | addFirst(E e) / offerFirst(E e) |
| 取队尾元素并删除   | 无                     | E removeLast() / E pollLast()   |
| 取队尾元素但不删除 | 无                     | E getLast() / E peekLast()      |

对于添加元素到队尾的操作，`Queue`提供了`add()`/`offer()`方法，而`Deque`提供了`addLast()`/`offerLast()`方法。添加元素到队首、取队尾元素的操作在`Queue`中不存在，在`Deque`中由`addFirst()`/`removeLast()`等方法提供。

注意到`Deque`接口实际上扩展自`Queue`：

```java
public interface Deque<E> extends Queue<E> {
    ...
}
```

因此，`Queue`提供的`add()`/`offer()`方法在`Deque`中也可以使用，但是，使用`Deque`，最好不要调用`offer()`，而是调用`offerLast()`：

```java
public class Main {
    public static void main(String[] args) {
        Deque<String> deque = new LinkedList<>();
        deque.offerLast("A"); // A
        deque.offerLast("B"); // A <- B
        deque.offerFirst("C"); // C <- A <- B
        System.out.println(deque.pollFirst()); // C, 剩下A <- B
        System.out.println(deque.pollLast()); // B, 剩下A
        System.out.println(deque.pollFirst()); // A
        System.out.println(deque.pollFirst()); // null
    }
}
```

如果直接写`deque.offer()`，我们就需要思考，`offer()`实际上是`offerLast()`，我们明确地写上`offerLast()`，不需要思考就能一眼看出这是添加到队尾。

因此，使用`Deque`，推荐总是明确调用`offerLast()`/`offerFirst()`或者`pollFirst()`/`pollLast()`方法。

`Deque`是一个接口，它的实现类有`ArrayDeque`和`LinkedList`。

我们发现`LinkedList`真是一个全能选手，它即是`List`，又是`Queue`，还是`Deque`。但是我们在使用的时候，总是用特定的接口来引用它，这是因为持有接口说明代码的抽象层次更高，而且接口本身定义的方法代表了特定的用途。

```java
// 不推荐的写法:
LinkedList<String> d1 = new LinkedList<>();
d1.offerLast("z");
// 推荐的写法：
Deque<String> d2 = new LinkedList<>();
d2.offerLast("z");
```

可见面向抽象编程的一个原则就是：尽量持有接口，而不是具体的实现类。

### 1.3.3 Stack

栈（Stack）是一种后进先出（LIFO：Last In First Out）的数据结构。

`Stack`只有入栈和出栈的操作：

- 把元素压栈：`push(E)`；
- 把栈顶的元素“弹出”：`pop()`；
- 取栈顶元素但不弹出：`peek()`。

在Java中，我们用`Deque`可以实现`Stack`的功能：

- 把元素压栈：`push(E)`/`addFirst(E)`；
- 把栈顶的元素“弹出”：`pop()`/`removeFirst()`；
- 取栈顶元素但不弹出：`peek()`/`peekFirst()`。

为什么Java的集合类没有单独的`Stack`接口呢？因为有个遗留类名字就叫`Stack`，出于兼容性考虑，所以没办法创建`Stack`接口，只能用`Deque`接口来“模拟”一个`Stack`了。

当我们把`Deque`作为`Stack`使用时，注意只调用`push()`/`pop()`/`peek()`方法，不要调用`addFirst()`/`removeFirst()`/`peekFirst()`方法，这样代码更加清晰。

## 1.4 Set接口

`java.util.Set`接口和`java.util.List`接口一样，同样继承自`Collection`接口，它与`Collection`接口中的方法基本一致，并没有对`Collection`接口进行功能上的扩充，只是比`Collection`接口更加严格了。与`List`接口不同的是，`Set`接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。

`Set`集合有多个子类，这里我们介绍其中的`java.util.HashSet`、`java.util.LinkedHashSet`这两个集合。Set集合取出元素的方式可以采用：迭代器、增强for。

### 1.4.1 HashSet集合

`java.util.HashSet`是`Set`接口的一个实现类，它所存储的元素是**不可重复**的，并且元素都是无序的(即存取顺序不一致)。`java.util.HashSet`底层的实现其实是一个`java.util.HashMap`支持。

`HashSet`是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：`hashCode`与`equals`方法。给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一。

HashSet集合存储数据的结构是哈希表，什么是哈希表呢？

在**JDK1.8**之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。

简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。

![](D:\Java\笔记\图片\1-04【集合】\4-0哈希表.png)

看到这张图就有人要问了，这个是怎么存储的呢？结合一个存储流程图来说明一下：

![](D:\Java\笔记\图片\1-04【集合】\4-1哈希流程图.png)

总而言之，**JDK1.8**引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。

### 1.4.3 LinkedHashSet

我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？在HashSet下面有一个子类`java.util.LinkedHashSet`，它是链表和哈希表组合的一个数据存储结构。

~~~java
public class LinkedHashSetDemo {
	public static void main(String[] args) {
		Set<String> set = new LinkedHashSet<String>();
		set.add("bbb");
		set.add("aaa");
		set.add("abc");
		set.add("bbc");
        Iterator<String> it = set.iterator();
		while (it.hasNext()) {
			System.out.println(it.next());
		}
	}
}
结果：
  bbb
  aaa
  abc
  bbc
~~~

# 第二章 Map集合

现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即`java.util.Map`接口。

我们通过查看`Map`接口描述，发现`Map`接口下的集合与`Collection`接口下的集合，它们存储数据的形式不同，如下图。

![](D:\Java\笔记\图片\1-04【集合】\5-1Collection与Map.bmp)

* `Collection`中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。
* `Map`中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。
* `Collection`中的集合称为单列集合，`Map`中的集合称为双列集合。
* 需要注意的是，`Map`中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。

Map接口中的集合都有两个泛型变量<K,V>,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量<K,V>的数据类型可以相同，也可以不同。

Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。

## 2.1 Map接口常用子类

![](D:\Java\笔记\图片\1-04【集合】\6-1.png)

通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。

* **HashMap<K,V>**：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。
* **LinkedHashMap<K,V>**：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。

## 2.2 Map接口常用方法

Map接口中定义了很多方法，常用的如下：

* `public V put(K key, V value)`:  把指定的键与指定的值添加到Map集合中。
  使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； 若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 
* `public V remove(Object key)`: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。
* `public V get(Object key)` 根据指定的键，在Map集合中获取对应的值。
* `boolean containsKey(Object key)  ` 判断集合中是否包含指定的键。
* `public Set<K> keySet()`: 获取Map集合中所有的键，存储到Set集合中。
* `public Set<Map.Entry<K,V>> entrySet()`: 获取到Map集合中所有的键值对对象的集合(Set集合)。

我们已经知道，`Map`中存放的是两种对象，一种称为**key**(键)，一种称为**value**(值)，它们在在`Map`中是一一对应关系，这一对对象又称做`Map`中的一个`Entry(项)`。`Entry`将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历`Map`集合时，就可以从每一个键值对（`Entry`）对象中获取对应的键与对应的值。

在Map集合中也提供了获取所有Entry对象的方法：

* `public Set<Map.Entry<K,V>> entrySet()`: 获取到Map集合中所有的键值对对象的集合(Set集合)。

 既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法：

* `public K getKey()`：获取Entry对象中的键。
* `public V getValue()`：获取Entry对象中的值。

## 2.3 HashMap

练习：每位学生（姓名，年龄）都有自己的家庭住址。那么，既然有对应关系，则将学生对象和家庭住址存储到map集合中。学生作为键, 家庭住址作为值。

编写学生类：

~~~java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Student {

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        Student student = (Student) o;
        return age == student.age && Objects.equals(name, student.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}
~~~

编写测试类：

~~~java 
public class HashMapTest {
    public static void main(String[] args) {
        //1,创建Hashmap集合对象。
        Map<Student,String>map = new HashMap<Student,String>();
        //2,添加元素。
        map.put(newStudent("lisi",28), "上海");
        map.put(newStudent("wangwu",22), "北京");
        map.put(newStudent("zhaoliu",24), "成都");
        map.put(newStudent("zhouqi",25), "广州");
        map.put(newStudent("wangwu",22), "南京");
        
        //3,取出元素。键找值方式
        Set<Student>keySet = map.keySet();
        for(Student key: keySet){
            Stringvalue = map.get(key);
            System.out.println(key.toString()+"....."+value);
        }
    }
}
~~~

当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。

如果要保证map中存放的key和取出的顺序一致，可以使用`java.util.LinkedHashMap`集合来存放。

## 2.4 LinkedHashMap

我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？

在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。

~~~java
public class LinkedHashMapDemo {
    public static void main(String[] args) {
        LinkedHashMap<String, String> map = new LinkedHashMap<String, String>();
        map.put("邓超", "孙俪");
        map.put("李晨", "范冰冰");
        map.put("刘德华", "朱丽倩");
        Set<Entry<String, String>> entrySet = map.entrySet();
        for (Entry<String, String> entry : entrySet) {
            System.out.println(entry.getKey() + "  " + entry.getValue());
        }
    }
}
~~~

结果:

~~~
邓超  孙俪
李晨  范冰冰
刘德华  朱丽倩
~~~

## 2.5 Hashtable

HashTable是较为远古的使用Hash算法的容器结构了，现在基本已被淘汰，单线程转为使用HashMap，多线程使用ConcurrentHashMap。

HashMap是线程不安全的类，多线程下会造成并发冲突，但单线程下运行效率较高；HashTable是线程安全的类，很多方法都是用synchronized修饰，但同时因为加锁导致并发效率低下，单线程环境效率也十分低；

## 2.6 ConcurrentHashMap

concurrentHashMap是一个支持高并发更新与查询的哈希表(基于HashMap)。在保证安全的前提下，进行检索不需要锁定。与hashtable不同，该类不依赖于synchronization去保证线程操作的安全。

## 2.7 Properties

<!--Properties 所有物; 财产; 财物; 不动产; 房地产; 房屋及院落; 庄园;-->

`java.util.Properties`继承于`Hashtable`，来表示一个持久的属性集。它使用键值结构存储数据，每个键与其对应值都是一个字符串。该类也被许多java类使用，比如获取系统属性时，`System.getProperties`方法就是返回一个`Properties`对象。

```java
public class Properties extends Hashtable<Object,Object> {}
```

```java
public class Hashtable<K,V>
    extends Dictionary<K,V>
    implements Map<K,V>, Cloneable, java.io.Serializable {}
```

`Properties`类表示了一个持久的属性集，`Properties`可保存在流中或从流中加载。

* `public Properties()`: 创建一个空的属性列表。
* `public Object setProperty(String key, String value)`: 保存一对属性，等于调用Hashtable的方法put。
* `public String getProperty(String key)`: 使用此属性列表中指定的键搜索属性值。通过key找到value值，此方法相当于Map集合中的get(key)方法。
* `public Set<String> stringPropertyNames()`: 所有键的名称的集合。返回此属性列表中的键集，其中该键及其对应值是字符串，此方法相当于Map集合中的keySet方法。

```java
public class Demo01Properties {
    public static void main(String[] args) {
        // 创建Properties集合对象
        Properties prop = new Properties();
        // 使用setProperty往集合中添加数据
        prop.setProperty("迪丽热巴", "168");
        prop.setProperty("古力娜扎", "165");
        prop.setProperty("稀里哗啦", "169");

        // 使用stringPropertyNames把Properties集合中的键取出，存储到一个set集合中
        Set<String> set = prop.stringPropertyNames();
        
        // 遍历Set集合，取出Properties集合中的每一个键
        for (String key : set) {
            // 使用getProperty方法通过key获取value
            String value = prop.getProperty(key);
            System.out.println(key + " = " + value);

        }
    }
}
```

`Properties`集合是一个唯一和IO流相结合的集合

* 可以使用`Properties`集合中的方法`store`，把集合中的临时数据，持久化写入到硬盘中存储。

  `void store(OutputStream out， String comments)` 字节输入流，不能使用中文
  `void store(Writer writer, String comments)` 字符输入流，可以使用中文。
  `String comments`：注释，用来解释说明保存的文件是做什么用的，在保存的文件中的第一行会显示。不能使用中文，会乱码，因为计算机默认的是Unicode编码。一般使用“ ”空字符串

  ```java
  public class Demo02Properties {
      public static void main(String[] args) throws IOException {
          // 1.创建Properties集合对象,添加数据
          Properties prop = new Properties();
          prop.setProperty("迪丽热巴", "168");
          prop.setProperty("古力娜扎", "165");
          prop.setProperty("稀里哗啦", "169");
  
          // 创建字节输出流对象，不用释放资源，因为匿名，所以直接会释放资源的
          // 因为是字节输出流，并且不能使用中文，可是之前有中文，所以会出现乱码
          prop.store(new FileOutputStream("09_IOAndProperties\\prop2.txt"), " ");
      }
  }
  ```

* 可以使用`Properties`集合中的方法`load`，把硬盘中保存的文件(键值对)，读取到集合中使用。

  `void load(InputStream inStream)` 字节输入流，不能读取含有中文键值对的文件
  `void load(Reader reader)` 字符输入流，可以读取含有中文键值对的文件

  ```properties
  # properties文件
  package=com.linxuan.demo01.Student
  method=out
  ```

  ```java
  public class Demo03Properties {
      public static void main(String[] args) throws IOException {
          // 创建Properties集合对象
          Properties prop = new Properties();
          // 使用Properties集合中的方法load读取保存键值对的文件
          prop.load(new FileReader("D:\\linxuan.properties"));
          // 遍历Properties集合
          Set<String> set = prop.stringPropertyNames();
          for (String key : set) {
              String value = prop.getProperty(key);
              System.out.println(key + "=" + value);
          }
      }
  }
  ```

  * 存储键值对的文件中，键与值默认的连接符号可以使用=，空格（其他符号）。
  * 存储键值对的文件中，可以使用#进行注释，被注释的键值对不会再被读取。
  * 存储键值对的文件中，键与值默认都是字符串，不用再加引号

# 第三章  Collections

`java.utils.Collections`是集合工具类，用来对集合进行操作。部分方法如下：

- `public static <T> boolean addAll(Collection<T> c, T... elements)  `:往集合中添加一些元素。
- `public static void shuffle(List<?> list) 打乱顺序`:打乱集合顺序。
- `public static <T> void sort(List<T> list)`:将集合中元素按照默认规则排序。
- `public static <T> void sort(List<T> list，Comparator<? super T> )`:将集合中元素按照指定规则排序。

代码演示：

```java
public class CollectionsDemo {
    public static void main(String[] args) {
        ArrayList<Integer> list = new ArrayList<Integer>();
        //原来写法
        //list.add(12);
        //list.add(14);
        //list.add(15);
        //list.add(1000);
        //采用工具类 完成 往集合中添加元素  
        Collections.addAll(list, 5, 222, 1, 2);
        System.out.println(list);
        //排序方法 
        Collections.sort(list);
        System.out.println(list);
    }
}
结果：
[5, 222, 1, 2]
[1, 2, 5, 222]
```

代码演示之后 ，发现我们的集合按照顺序进行了排列，可是这样的顺序是采用默认的顺序，如果想要指定顺序就需要使用这个方法了，`public static <T> void sort(List<T> list，Comparator<? super T> )`：将集合中元素按照指定规则排序。

说到排序，简单的说就是两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用`java.lang.Comparable`接口去实现，一种是灵活的当我需要做排序的时候在去选择的`java.util.Comparator`接口完成。

## 4.1 Comparable接口

我们采用的`public static <T> void sort(List<T> list)`这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上如下：

```java
public final class String implements java.io.Serializable, Comparable<String>, CharSequence {}
```

**Comparable**：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。

创建一个学生类，存储到ArrayList集合中完成指定排序操作。Student 初始类

~~~java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Student{
    private String name;
    private int age;

}
~~~

测试类：

~~~java
public class Demo {
    public static void main(String[] args) {
        // 创建四个学生对象 存储到集合中
        ArrayList<Student> list = new ArrayList<Student>();

        list.add(new Student("rose",18));
        list.add(new Student("jack",16));
        list.add(new Student("abc",16));
        list.add(new Student("ace",17));
        list.add(new Student("mark",16));

        /*
          让学生 按照年龄排序 升序
         */
//        Collections.sort(list);//要求 该list中元素类型  必须实现比较器Comparable接口


        for (Student student : list) {
            System.out.println(student);
        }

    }
}
~~~

发现，当我们调用Collections.sort()方法的时候 程序报错了。原因：如果想要集合中的元素完成排序，那么必须要实现比较器Comparable接口。

于是我们就需要完成Student类的一个实现，如下：

~~~java
public class Student implements Comparable<Student>{
    ....
    @Override
    public int compareTo(Student o) {
        return this.age-o.age;//升序
    }
}
~~~

再次测试，代码就OK 了。

String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码，这是不可能的了。

那么这个时候我们可以使用`public static <T> void sort(List<T> list，Comparator<? super T> )`方法灵活的完成，这个里面就涉及到了Comparator这个接口，位于位于java.util包下。

## 4.1 Comparator比较器

排序是comparator能实现的功能之一，该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是：

* ` public int compare(String o1, String o2)`：比较其两个参数的顺序。

  两个对象比较的结果有三种：大于，等于，小于。

  如果要按照升序排序，则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）
  如果要按照降序排序，则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数）

**Comparator**强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。

```java
public class CollectionsDemo3 {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<String>();
        list.add("cba");
        list.add("aba");
        list.add("sba");
        list.add("nba");
        //排序方法  按照第一个单词的降序
        Collections.sort(list, new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                return o2.charAt(0) - o1.charAt(0);
            }
        });
        System.out.println(list);
    }
}
[sba, nba, cba, aba]
```

在上面的案例中，如果在使用的时候，想要独立的定义规则去使用 可以采用`Collections.sort(List list,Comparetor<T> c)`方式，自己定义规则：

~~~java
Collections.sort(list, new Comparator<Student>() {
    @Override
    public int compare(Student o1, Student o2) {
        return o2.getAge()-o1.getAge();//以学生的年龄降序
    }
});
~~~

~~~java
Student{name='rose', age=18}
Student{name='ace', age=17}
Student{name='jack', age=16}
Student{name='abc', age=16}
Student{name='mark', age=16}
~~~

如果想要规则更多一些，可以参考下面代码：

~~~java
Collections.sort(list, new Comparator<Student>() {
    @Override
    public int compare(Student o1, Student o2) {
        // 年龄降序
        int result = o2.getAge()-o1.getAge();//年龄降序

        if(result==0){//第一个规则判断完了 下一个规则 姓名的首字母 升序
            result = o1.getName().charAt(0)-o2.getName().charAt(0);
        }

        return result;
    }
});
~~~

效果如下：

~~~java
Student{name='rose', age=18}
Student{name='ace', age=17}
Student{name='abc', age=16}
Student{name='jack', age=16}
Student{name='mark', age=16}
~~~

# 第四章 Iterator迭代器

在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口`java.util.Iterator`。`Iterator`接口也是Java集合中的一员，但它与`Collection`、`Map`接口有所不同，`Collection`接口与`Map`接口主要用于存储元素，而`Iterator`主要用于迭代访问（即遍历）`Collection`中的元素，因此`Iterator`对象也被称为迭代器。

想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：`public Iterator iterator()`: 获取集合对应的迭代器，用来遍历集合中的元素的。

**迭代**：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。

Iterator接口的常用方法如下：

* `public E next()`:返回迭代的下一个元素。
* `public boolean hasNext()`:如果仍有元素可以迭代，则返回 true。

~~~java
public class IteratorDemo {
  	public static void main(String[] args) {
        // 使用多态方式 创建对象
        Collection<String> coll = new ArrayList<String>();

        // 添加元素到集合
        coll.add("串串星人");
        coll.add("吐槽星人");
        coll.add("汪星人");
        //遍历
        //使用迭代器 遍历   每个集合对象都有自己的迭代器
        Iterator<String> it = coll.iterator();
        //  泛型指的是 迭代出 元素的数据类型
        while(it.hasNext()){ //判断是否有迭代元素
            String s = it.next();//获取迭代出的元素
            System.out.println(s);
        }
  	}
}
~~~

> 在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。

## 4.1 迭代器的实现原理

我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。

Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程：

![](D:\Java\笔记\图片\1-04【集合】\7-1迭代器的实现原理(1).bmp)

在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。

## 4.2 增强for

增强for循环(也称for each循环)是**JDK1.5**以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。

格式：

~~~java
for(元素的数据类型  变量 : Collection集合or数组){ 
  	//写操作代码
}
~~~

它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。

# 第五章 扩展

## 5.1 可变参数

在**JDK1.5**之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：

```
修饰符 返回值类型 方法名(参数类型... 形参名){  }
```

其实这个书写完全等价与

```
修饰符 返回值类型 方法名(参数类型[] 形参名){  }
```

只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。

**JDK1.5**以后。出现了简化操作。**...** 用在参数上，称之为可变参数。

同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。

代码演示：    

```java
public class ChangeArgs {
    public static void main(String[] args) {
        int[] arr = { 1, 4, 62, 431, 2 };
        int sum = getSum(arr);
        System.out.println(sum);
        //  6  7  2 12 2121
        // 求 这几个元素和 6  7  2 12 2121
        int sum2 = getSum(6, 7, 2, 12, 2121);
        System.out.println(sum2);
    }

    /*
     * 完成数组  所有元素的求和 原始写法
     
      public static int getSum(int[] arr){
        int sum = 0;
        for(int a : arr){
            sum += a;
        }
        
        return sum;
      }
    */
    //可变参数写法
    public static int getSum(int... arr) {
        int sum = 0;
        for (int a : arr) {
            sum += a;
        }
        return sum;
    }
}
```

> tips: 上述add方法在同一个类中，只能存在一个。因为会发生调用的不确定性
>
> 注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。

## 5.2 JDK9对集合添加的优化

通常，我们在代码中创建一个集合（例如，List或者Set），并直接用一些元素填充它，实例化集合，几个add方法调用，是的代码重复。

**集合往里面添加元素，单列集合使用add；双列集合Map可以使用put方法。**

**代码如下：**

```java
import java.util.List;
import java.util.ArrayList;

public class Demo04 {

    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("abc");
        list.add("def");
        list.add("ghi");
        System.out.println(list);
    }
}
```

但是，如上代码所示，这种方法有点麻烦，一次只能添加一个元素。

Java 9，添加了几种集合工厂方法，更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可以更加方便的创建集合的不可变实例。

**特性：**

​	List接口， Set接口，Map接口，里面增加了一个静态的方法of，可以给集合一次性添加多个元素

**实例：**

​	static<E> List<E> of (E... elements)

**使用前提：**

​	当集合中存储的元素的个数已经确定了，不再改变时使用

**注意：**

1. of方法只适用于List接口，Set接口，Map接口，不适用于接口的实现类（ArrarList, HashSet, HashMap）。
2. of方法的返回值是一个不能改变的集合，集合不能再使用add，put方法添加元素，会抛出异常。
3. Set接口和Map接口在调用of方法的时候，不能有重复的元素，否则会抛出异常。
4. of方法前面没有new。

**代码如下：**

```java
import java.util.List;
import java.util.Map;
import java.util.Set;

public class Demo01JDK9 {

    public static void main(String[] args) {
        List<String> list = List.of("a", "b", "a", "c", "d");
        System.out.println(list);
        // list.add("w");// UnsupportedOperationException 不支持操作异常

        // Set<String> set =Set.of("a", "b", "a", "c", "d");// IllegalArgumentException 非法参数异常 有重复的元素
        Set<String> set =Set.of("a", "b", "c", "d");
        System.out.println(set);
        // set.add("w");// UnsupportedOperationException 不支持操作异常

        // Map<String, Integer> map = Map.of("张三", 18, "李四", 19, "王五", 20, "张三", 19);// IllegalArgumentException 非法参数异常 有重复的元素
        Map<String, Integer> map = Map.of("张三", 18, "李四", 19, "王五", 20);// IllegalArgumentException 非法参数异常 有重复的元素
        System.out.println(map);
        // map.put("赵四", 30);// UnsupportedOperationException 不支持操作异常
    }
}
```
