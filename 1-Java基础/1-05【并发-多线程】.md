学习路线如下：

![](D:\Java\笔记\图片\1-06【并发】\0-00000005.png)

本系列代码在JDK8下实现：

```xml
<properties>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
</properties>
<dependencies>
    <!--导入Lombok，简化JavaBean的编写-->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>1.18.10</version>
    </dependency>
    <!--使用Logback日志来实现-->
    <dependency>
        <groupId>ch.qos.logback</groupId>
        <artifactId>logback-classic</artifactId>
        <version>1.2.3</version>
    </dependency>
</dependencies>
```

```xml
<!--logback.xml配置文件-->
<?xml version="1.0" encoding="UTF-8"?>
<configuration
               xmlns="http://ch.qos.logback/xml/ns/logback"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xsi:schemaLocation="http://ch.qos.logback/xml/ns/logback logback.xsd">
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%date{HH:mm:ss} [%t] %logger - %m%n</pattern>
        </encoder>
    </appender>
    <logger name="c" level="debug" additivity="false">
        <appender-ref ref="STDOUT"/>
    </logger>
    <root level="ERROR">
        <appender-ref ref="STDOUT"/>
    </root>
</configuration>
```

# 第一章 基础概念

## 1.1 进程与线程

进程是资源分配的最小单位，线程是CPU调度的最小单位。

* **进程**

  程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。
  进程就是用来加载指令、管理内存、管理 IO 的。当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）。

* **线程**

  一个进程之内可以分为一到多个线程。一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 。
  Java 中，进程是资源分配的最小单位，线程是CPU调度的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器。

**进程和线程对比**

- 进程基本上相互独立的，而线程存在于进程内，是进程的一个子集
- 进程拥有共享的资源，如内存空间等，供其内部的线程共享
- 进程间通信较为复杂
  - 同一台计算机的进程通信称为 `IPC`（`Inter-process communication`）
  - 不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP
- 线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量
- 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低。进程切换涉及内存空间的切换而线程不会。因为每个进程都有自己的内存空间，而线程是共享所在进程的内存空间的，因此同一个进程中的线程进行线程切换时不涉及内存空间的转换。所以线程上下文切换成本低。

## 1.2 并发与并行

* **并发**

  在单核 cpu 下，线程实际还是串行执行的。
  操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows 下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感觉是同时运行的 。一般会将这种线程轮流使用 CPU 的做法称为并发（concurrent）。

* **并行**

  多核 cpu下，每个核（core） 都可以调度运行线程，这时候线程可以是并行的，不同的线程同时使用不同的cpu在执行。

引用 Rob Pike 的一段描述：并发是同一时间应对（dealing with）多件事情的能力，并行（parallel）是同一时间动手做（doing）多件事情的能力。

举个例子：

- 家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发。
- 雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是并行。
- 家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一 个人用锅时，另一个人就得等待）。

## 1.3 多线程应用

**异步调用**

首先来看一下同步和异步的概念：

- 需要等待结果返回，才能继续运行就是同步
- 不需要等待结果返回，就能继续运行就是异步

多线程可以使方法的执行变成异步的，比如说读取磁盘文件时，假设读取操作花费了5秒，如果没有线程的调度机制，这么cpu只能等5秒，啥都不能做。

**提高效率**

这里用的式JMH测试，但是我不会使用。就凉了。之后学一下JMH。直接说结论：

1. 单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，让不同线程轮流使用cpu ，不至于一个线程总占用 cpu，别的线程没法干活
2. 多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的
  * 有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任
    务都能拆分。
  * 也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义
3. IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化。

# 第二章 java线程

## 2.1 创建线程三种方法

### 2.1.1 Thread

```java
// 构造方法的参数是给线程指定名字，推荐给线程起个名字
Thread t1 = new Thread("t1") {
    @Override
    // run 方法内实现了要执行的任务
    public void run() {
        log.debug("hello");
    }
};
t1.start();
```

### 2.1.2 Runnable配合Thread

把【线程】和【任务】（要执行的代码）分开，Thread 代表线程，Runnable 可运行的任务（线程要执行的代码）

```java
// 创建任务对象
Runnable task2 = new Runnable() {
    @Override
    public void run() {
        log.debug("hello");
    }
};
// 参数1 是任务对象; 参数2 是线程名字，推荐给线程起个名字
Thread t2 = new Thread(task2, "t2");
t2.start();
```

方法1 是把线程和任务合并在了一起，方法2是把线程和任务分开了，用 Runnable 更容易与线程池等高级 API 配合，用 Runnable 让任务类脱离了 Thread 继承体系，更灵活。设计模式里面提到组合优先于继承。

通过查看源码可以发现，方法二其实到底还是通过方法一执行的！

### 2.1.3 FutureTask配合Thread

这种就是函数式接口的应用。

FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况。

```java
@Slf4j
public class Demo01 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // 实现多线程的第三种方法可以返回数据
        FutureTask<Integer> futureTask = new FutureTask<>(new Callable<Integer>() {
            @Override
            public Integer call() throws Exception {
                log.debug("多线程任务");
                Thread.sleep(100);
                return 100;
            }
        });
        // 主线程阻塞，同步等待 task 执行完毕的结果
        new Thread(futureTask,"linxuan").start();
        log.debug("主线程");
        log.debug("{}",futureTask.get());
    }
}
```

Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。

追踪一下源码：

```java
public class FutureTask<V> implements RunnableFuture<V> {
    // 省略类中内容
}
```

```java
public interface RunnableFuture<V> extends Runnable, Future<V> {
    void run();
}
```

```java
public interface Future<V> {
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException;
    V get(long timeout, TimeUnit unit) 
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

Future提供了三种功能：

1. 判断任务是否完成；
2. 能够中断任务；
3. 能够获取任务执行结果。

可以看一下这篇文章：[FutureTask是Future和Runable的实现](https://mp.weixin.qq.com/s/RX5rVuGr6Ab0SmKigmZEag)

## 2.2 查看进程的方法

**windows**

- 任务管理器可以查看进程和线程数，也可以用来杀死进程

- tasklist 查看进程

- taskkill 杀死进程

  ```java
  D:\Java\vscode-java\JUC>tasklist | findstr java
  java.exe                      5284 Console                    3    368,928 K
  java.exe                      8964 Console                    3     17,428 K
  java.exe                      2860 Console                    3    238,616 K
  java.exe                      9032 Console                    3     21,252 K
  
  D:\Java\vscode-java\JUC>jps // jps命令是Java中的命令
  5284 org.eclipse.equinox.launcher_1.6.400.v20210924-0641.jar
  8964 XMLServerLauncher
  9032 Demo02
  2860 BootLanguageServerBootApp
  4076 Jps
  
  D:\Java\vscode-java\JUC>taskkill /F /PID 9032
  成功: 已终止 PID 为 9032 的进程。
  ```

**linux**

- ps -ef 查看所有进程
- ps -fT -p 查看某个进程（PID）的所有线程
- kill 杀死进程
- top 按大写 H 切换是否显示线程
- top -H -p 查看某个进程（PID）的所有线程

**Java**

- ps 命令查看所有 Java 进程

- jstack 查看某个 Java 进程（PID）的所有线程状态

- jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）

  下面来看一下Jconsole远程连接：

  ```apl
  # 使用下面的方式运行Java类 ''需要删除掉
  java -Djava.rmi.server.hostname=`ip地址` -Dcom.sun.management.jmxremote -
  Dcom.sun.management.jmxremote.port=`连接端口` -Dcom.sun.management.jmxremote.ssl=是否安全连接 -
  Dcom.sun.management.jmxremote.authenticate=是否认证 java类
  ```


## 2.2 线程运行原理

**虚拟机栈与栈帧**

Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。

每个线程运行需要的内存空间，称为虚拟机栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用，是线程私有的。

每个栈由多个栈帧组成，对应着每次调用方法时所占用的内存。每个线程只能有一个活动栈帧，对应着当前正在执行的方法。

- 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存
- 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法

**线程上下文切换**

线程上下文切换（Thread Context Switch）：因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码

- 线程的 cpu 时间片用完(每个线程轮流执行，看前面并行的概念)
- 垃圾回收
- 有更高优先级的线程需要运行
- 线程自己调用了 `sleep`、`yield`、`wait`、`join`、`park`、`synchronized`、`lock` 等方法

当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的。

操作系统需要保存的状态信息包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等。Context Switch 频繁发生会影响性能

## 2.3 Thread的常见方法

非静态方法：

| 方法名           | 功能说明                                                     |
| ---------------- | ------------------------------------------------------------ |
| start()          | 启动一个新线程，运行线程内的run方法<br />该方法只是让线程进入就绪，代码不一定运行，比如CUP的时间片还没有分配给该线程。每个线程对象的start方法只能调用一次，如果调用多次会出现`IllegalThreadStateException` |
| run()            | 新线程启用后会调用的方法<br />如果在构造Thread对象时传递了Runnable参数，则线程启动后调用Runnable中的run方法，否则默认不执行任何操作。但可以创建Thread的子类对象，来覆盖默认行为 |
| join()           | 等待线程运行结束                                             |
| join(long n)     | 等待线程运行结束，最多等待n毫秒                              |
| getId()          | 获取线程长整型的id，id唯一                                   |
| getName()        | 获取线程名                                                   |
| setName(String)  | 修改线程名                                                   |
| getPriority()    | 获取线程优先级                                               |
| getPriority(int) | 修改线程优先级<br />java中规定优先级是1~10的整数，比较大优先级能提高该线程被CPU调用的几率 |
| getState()       | 获取线程状态<br />Java 中线程状态是用 6 个 enum 表示，分别为： `NEW`, `RUNNABLE`, `BLOCKED`, `WAITING`, `TIMED_WAITING`, `TERMINATED` |
| isAlive()        | 判断线程是否存活 ，是否运行完毕                              |
| interrupt()      | 打断线程<br />如果被打断线程在 `sleep`、`wait`、`join`则会导致被打断的线程抛出`InterruptedException`异常，并清除打断标记 ；<br />如果打断的是正在运行的线程，则会设置打断标 记 ；<br />park的线程被打断，也会设置打断标记 |
| isInterrupted()  | 判断线程是否被打断，不会清除 `"打断标记"`                    |

 四个静态方法如下：

| 方法名          | static | 功能说明                                                | 注意               |
| --------------- | ------ | ------------------------------------------------------- | ------------------ |
| interrupted()   | static | 判断当前线程是否被打断                                  | 会清除打断标记     |
| currentThread() | static | 获取当前正在执行的线程                                  |                    |
| sleep(long n)   | static | 当前执行的线程休眠n毫秒 休眠时让出cpu的时间片给其它线程 |                    |
| yield()         | static | 提示线程调度器 让出当前线程对 CPU的使用                 | 主要为了测试和调试 |

### 2.3.1 start 与 run

**start方法**

调用start方法，能不能运行任务调度器说了算。

```java
public static void main(String[] args) throws InterruptedException {
    Thread thread = new Thread(){
        @Override
        public void run(){
            log.debug("我是一个新建的线程正在运行中");
        }
    };
    thread.setName("新建线程");
    thread.start();
    Thread.sleep(1000);
    log.debug("主线程");
}
```

输出信息如下：	

```properties
09:12:24.559 [新建线程] DEBUG com.linxuan.demo01.Demo01 - 我是一个新建的线程正在运行中
09:12:25.563 [main] DEBUG com.linxuan.demo01.Demo01 - 主线程
```

**调用run**

将上面代码的`thread.start();`改为 `thread.run();`。输出结果如下：

```properties
09:17:07.175 [main] DEBUG com.linxuan.demo01.Demo01 - 我是一个新建的线程正在运行中
09:17:08.185 [main] DEBUG com.linxuan.demo01.Demo01 - 主线程
```

程序仍在 main 线程运行， `run()`方法里面内容的调用还是同步的

**小结**

直接调用 `run()` 是在主线程中执行了 `run()`，没有启动新的线程。使用 `start()` 是启动新的线程，通过新的线程间接执行 `run()`方法 中的代码

当调用start方法，线程状态会由“`NEW`”变为“`RUNABLE`”，此时再次调用start方法会报错`IllegalThreadStateException`非法的状态异常。

### 2.3.2 sleep 与 yield

**sleep**

sleep方法是静态的，所以调用的时候直接`Thread.sleep(long n);单位是毫秒`就可以了，sleep方法在哪个线程使用那么就是哪个线程睡眠阻塞。

1. 调用 sleep 会让当前线程从 `Running` 进入 `Timed Waiting` 状态（阻塞）

2. 可以使用`interrupt`方法打断正在睡眠的线程，那么被打断的线程这时就会抛出 `InterruptedException`异常【注意：这里打断的是正在休眠的线程，而不是其它状态的线程】

3. 睡眠结束后的线程未必会立刻得到执行(需要分配到cpu时间片)

4. 建议用 TimeUnit 的 `sleep()` 代替 Thread 的 `sleep()`来获得更好的可读性。TimeUnit有时间单位，例如：`TimeUnit.SECONDS.sleep(1);`。当然二者效果一样。

5. 可以使用sleep方法来限制程序的CPU的使用
   在没有利用 cpu 来计算时，不要让 while(true) 空转浪费 cpu，这时可以使用 yield 或 sleep 来让出 cpu 的使用权 给其他程序

   ```java
   while(true) {
       try {
           Thread.sleep(50);
       } catch (InterruptedException e) {
           e.printStackTrace();
       }
   }
   // 加上sleep方法后CPU占用为4%，不加sleep方法CPU占用为100%
   ```

   可以用 wait 或 条件变量达到类似的效果，不同的是，后两种都需要加锁，并且需要相应的唤醒操作，一般适用于要进行同步的场景。sleep 适用于无需锁同步的场景。

这里我们封装一个sleep方法自己使用，以后再次使用sleep的时候导包就可以了：

```java
package com.linxuan.util;
import java.util.concurrent.TimeUnit;

public class Sleeper {
    public static void sleep(int i) {
        try {
            TimeUnit.SECONDS.sleep(i);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static void sleep(double i) {
        try {
            TimeUnit.MILLISECONDS.sleep((int) (i * 1000));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

**yield**

1. 调用 yield 会让当前线程从 `Running` 进入 `Runnable` 就绪状态，然后调度执行其它线程。`Runnable` 就绪状态不同于 `Timed Waiting` 阻塞状态，`Runnable`就绪状态有可能分配时间片，而`Timed Waiting`阻塞状态在阻塞期间内不会分配时间片。
2. 具体的实现依赖于操作系统的任务调度器，就是可能没有其它的线程正在执行，虽然调用了`yield`方法，但是没有任何卵用，依然执行该线程。

**线程优先级**

* 线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它

* 如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用

  ```java
  public static void main(String[] args) throws InterruptedException {
      
      Runnable task1 = () -> {
          int count = 0;
          for (;;) {
              System.out.println("---->1 " + count++);
          }
      };
      Runnable task2 = () -> {
          int count = 0;
          for (;;) {
              // 设置线程2让出时间片 从Running状态进入Runnable状态
              // Thread.yield();
              System.out.println("    ---->2 " + count++);
          }
      };
      Thread t1 = new Thread(task1, "t1");
      Thread t2 = new Thread(task2, "t2");
      // 设置线程优先级 线程1优先级为最低1级 线程2优先级为最高2级
      // t1.setPriority(Thread.MIN_PRIORITY);
      // t2.setPriority(Thread.MAX_PRIORITY);
      t1.start();
      t2.start();
  }
  ```

### 2.3.3 join

`join()` ：等待线程运行结束，非静态方法，哪个线程调用join方法就会等待哪个线程运行结束。

`join(long n)` ：等待线程运行结束，最多等待n毫秒。

下面代码不加上join方法那么结果为0，加上join方法结果为10。在主线程中调用t1.join，则主线程会等待t1线程执行完之后再继续执行。

```java
static int r = 0;

public static void main(String[] args) throws InterruptedException {
    log.debug("开始");
    Thread t1 = new Thread(() -> {
        log.debug("开始");
        try {
            Thread.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.debug("结束");
        r = 10;
    }, "t1");
    t1.start();
    // t1.join();
    log.debug("结果为:{}", r);
    log.debug("结束");
}
```

示意图如下：

![](D:\Java\笔记\图片\1-06【并发】\1-1.png)

上面是单个线程的join方法调用，下面我们来看一下多个线程的join方法调用：

```java
// jdk1.5特性，静态导入
import static com.linxuan.util.Sleeper.sleep;

@Slf4j
public class Demo01 {
    static int r1 = 0;
    static int r2 = 0;

    public static void main(String[] args) throws InterruptedException {
        test2();
    }

    private static void test2() throws InterruptedException {
        Thread t1 = new Thread(() -> {
            sleep(1);
            r1 = 10;
        });
        Thread t2 = new Thread(() -> {
            sleep(2);
            r2 = 20;
        });
        long start = System.currentTimeMillis();
        t1.start();
        t2.start();
        log.debug("join开始了");
        t1.join();
        log.debug("t1.join结束");
        t2.join();
        log.debug("t2.join结束");
        long end = System.currentTimeMillis();
        log.debug("r1: {} r2: {} cost: {}", r1, r2, end - start);
    }
}
```

来分析一下，主线程共需要等待多少时间：

- 第一个 join：等待 t1 时, t2 并没有停止, 而在运行。也就是等待t1线程1s，这时候t2线程也运行了1s。
- 第二个 join：t2在之前运行了1s，因此也只需再等待 1s。
- 也就是一共需要等待2秒。

```properties
08:34:07.002 [main] DEBUG com.linxuan.demo01.Demo01 - join开始了
08:34:08.013 [main] DEBUG com.linxuan.demo01.Demo01 - t1.join结束
08:34:09.014 [main] DEBUG com.linxuan.demo01.Demo01 - t2.join结束
08:34:09.015 [main] DEBUG com.linxuan.demo01.Demo01 - r1: 10 r2: 20 cost: 2016
```

那么问题来了？假如我们调整一下`t1.join();`和`t2.join();`的执行顺序后，主线程还需要等待多少时间呢？答案就是仍然2秒，不会有任何变化。

![](D:\Java\笔记\图片\1-06【并发】\1-2.png)

### 3.3.4 interrupt

* `void interrupt()`：打断线程。如果被打断线程在`sleep、wait和join`状态则会导致被打断的线程抛出`InterruptedException`异常，并清除打断标记 ；如果打断的是正在运行的线程，则会设置打断标记 ；park的线程被打断，也会设置打断标记
* `boolean isInterrupted()`：判断线程是否被打断，不会清除 `"打断标记"`。
* `static boolean interrupted()`：判断当前线程是否被打断，会清除打断标记。

先了解一些interrupt()方法的相关知识：[博客地址](https://www.cnblogs.com/noteless/p/10372826.html#0)

**打断阻塞状态线程**

sleep，wait，join 的线程，这几个方法都会让线程进入阻塞状态，而interrupt方法会打断阻塞线程。下面以sleep方法实例：

```java
@Slf4j
public class Demo02 {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            log.debug("t1线程睡眠");
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "t1");

        t1.start();
        Thread.sleep(1000);
        log.debug("interrupted");
        t1.interrupt();
        // 看一下打断标记 true为打断了 false为非打断
        // 但是sleep join wait方法会重置打断标记 所以最后结果为false.
        log.debug("打断标记结果为：" + t1.isInterrupted());
    }
}
```

```apl
09:01:23.994 [t1] DEBUG com.linxuan.demo01.Demo02 - t1线程睡眠
09:01:24.996 [main] DEBUG com.linxuan.demo01.Demo02 - interrupted
09:01:24.997 [main] DEBUG com.linxuan.demo01.Demo02 - 打断标记结果为：false
java.lang.InterruptedException: sleep interrupted
        at java.lang.Thread.sleep(Native Method)
        at com.linxuan.demo01.Demo02.lambda$0(Demo02.java:11)
        at java.lang.Thread.run(Thread.java:748)
```

**打断正常运行的线程**

打断正常运行的线程, 不会清空打断状态，也不会停止线程，因此我们需要自己来根据打断标记手动停止线程。

```java
public static void main(String[] args) throws InterruptedException {
    Thread t1 = new Thread(() -> {
        while(true) {
            if (Thread.currentThread().isInterrupted()) {
                log.debug("线程被打断了");
                break;
            }
        }
    }, "t1");
    t1.start();
    Thread.sleep(1000);
    log.debug("interrupt");
    t1.interrupt();
}
```

**打断 park 线程**

打断 park 线程, 不会清空打断状态

```java
@Slf4j
public class Demo02 {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            log.debug("park...");
            LockSupport.park();
            log.debug("unpark...");
            log.debug("打断状态：{}", Thread.currentThread().isInterrupted());
        }, "t1");
        t1.start();
        
        sleep(0.5);
        t1.interrupt();
    }
}
```

```apl
17:40:12.308 [t1] DEBUG com.linxuan.demo01.Demo02 - park...
17:40:12.817 [t1] DEBUG com.linxuan.demo01.Demo02 - unpark...
17:40:12.817 [t1] DEBUG com.linxuan.demo01.Demo02 - 打断状态：true
```

如果打断标记已经是 true, 则 park 会失效

```java
@Slf4j
public class Demo02 {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                log.debug("park...");
                LockSupport.park();
                log.debug("打断状态：{}", Thread.currentThread().isInterrupted());
            }
        });
        t1.start();
        sleep(1);
        t1.interrupt();

    }
}
```

```apl
17:41:16.022 [Thread-0] DEBUG com.linxuan.demo01.Demo02 - park...
17:41:17.030 [Thread-0] DEBUG com.linxuan.demo01.Demo02 - 打断状态：true
17:41:17.034 [Thread-0] DEBUG com.linxuan.demo01.Demo02 - park...
17:41:17.035 [Thread-0] DEBUG com.linxuan.demo01.Demo02 - 打断状态：true
17:41:17.036 [Thread-0] DEBUG com.linxuan.demo01.Demo02 - park...
17:41:17.037 [Thread-0] DEBUG com.linxuan.demo01.Demo02 - 打断状态：true
17:41:17.038 [Thread-0] DEBUG com.linxuan.demo01.Demo02 - park...
17:41:17.039 [Thread-0] DEBUG com.linxuan.demo01.Demo02 - 打断状态：true
17:41:17.040 [Thread-0] DEBUG com.linxuan.demo01.Demo02 - park...
17:41:17.041 [Thread-0] DEBUG com.linxuan.demo01.Demo02 - 打断状态：true
```

可以使用 `Thread.interrupted()` 清除打断状态。

### 3.3.5 方法总结

关于join的原理和这几个方法的对比：[看这里](https://blog.csdn.net/dataiyangu/article/details/104956755)

1. sleep，join，yield，interrupted是Thread类中的方法
2. wait/notify是object中的方法

sleep 不释放锁、释放cpu。join 释放锁、抢占cpu。yiled 不释放锁、释放cpu。wait 释放锁、释放cpu。

## 2.4 两阶段终止模式

终止模式之两阶段终止模式Two Phase Termination，就是考虑在一个线程T1中如何优雅地终止另一个线程T2。这里的优雅指的是给T2一个料理后事的机会（如释放锁）。

先来看一下两种错误的思路：

- 使用线程对象的 `stop()` 方法停止线程。`stop` 方法会真正杀死线程。但是如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁。
- 使用 `System.exit(int)` 方法停止线程。我们目的仅是停止一个线程，但这种做法会让整个程序都停止。

正确思路如下：线程的`isInterrupted()`方法可以取得线程的打断标记，如果线程在睡眠`sleep`期间被打断，打断标记虽然被重置为`false`，但是`sleep`期间被打断会抛出异常，我们据此手动设置打断标记为`true`；如果是在程序正常运行期间被打断的，那么打断标记就被自动设置为`true`。

<img src="D:\Java\笔记\图片\1-06【并发】\1-3.png"/>

代码实现如下：

```java
@Slf4j
public class Demo02 {
    public static void main(String[] args) throws InterruptedException {
        TwoParseTermination tpt = new TwoParseTermination();
        tpt.start();
        Thread.sleep(3500);
        tpt.stop();        
    }
}
```

```java
@Slf4j
public class TwoParseTermination {
    Thread thread;

    // 启动监控线程
    public void start() {
        thread = new Thread(() -> {
            while (true) {
                Thread currentThread = Thread.currentThread();
                if (currentThread.isInterrupted()) {
                    log.debug("料理后事");
                    break;
                }
                try {
                    // 让线程睡眠 如果有异常那么捕获抛出打印
                    Thread.sleep(1000);
                    // 线程没有异常 执行监控记录
                    log.debug("执行监控记录");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    // 因为打断标记会被重置 所以这里我们重新打断一下 设置为true
                    currentThread.interrupt();
                }
            }
        });
        thread.start();
    }

    // 停止监控线程
    public void stop() {
        thread.interrupt();
    }
}
```

```apl
17:11:01.652 [t1] DEBUG com.linxuan.demo01.TwoParseTermination - 执行监控记录
17:11:02.666 [t1] DEBUG com.linxuan.demo01.TwoParseTermination - 执行监控记录
17:11:03.668 [t1] DEBUG com.linxuan.demo01.TwoParseTermination - 执行监控记录
java.lang.InterruptedException: sleep interrupted
        at java.lang.Thread.sleep(Native Method)
        at com.linxuan.demo01.TwoParseTermination.lambda$0(Demo02.java:30)
        at java.lang.Thread.run(Thread.java:748)
17:11:04.146 [t1] DEBUG com.linxuan.demo01.TwoParseTermination - 料理后事
```

## 2.5 不推荐的方法

还有一些不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁。这些方法已经用注解标记上了`@Deprecated`。

| 方法名    | static | 功能说明             |
| --------- | ------ | -------------------- |
| stop()    |        | 停止线程运行         |
| suspend() |        | 挂起（暂停）线程运行 |
| resume()  |        | 恢复线程运行         |

## 2.6 守护线程

默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。

有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。

```java
@Slf4j
public class Demo02 {
    public static void main(String[] args) {
        log.debug("开始运行...");

        Thread t1 = new Thread(() -> {
            log.debug("开始运行...");
            sleep(2);
            log.debug("运行结束...");
        }, "daemon");
        // 设置该线程为守护线程
        t1.setDaemon(true);
        t1.start();

        sleep(1);
        log.debug("运行结束...");
    }
}
```

```apl
18:02:44.128 [main] DEBUG com.linxuan.demo01.Demo02 - 开始运行...
18:02:44.202 [daemon] DEBUG com.linxuan.demo01.Demo02 - 开始运行...
18:02:45.205 [main] DEBUG com.linxuan.demo01.Demo02 - 运行结束...
```

- 垃圾回收器线程就是一种守护线程。
- Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等 待它们处理完当前请求

## 2.7 线程状态

众说纷纭，所以直接两种都讲一下。

### 2.7.1 线程五种状态

五种状态的划分主要是从操作系统的层面进行划分的

![](D:\Java\笔记\图片\1-06【并发】\1-4线程5种状态.png)

1. 初始状态，仅仅是在语言层面上创建了线程对象`Thead thread = new Thead();`还未与操作系统线程关联。
2. 可运行状态，也称就绪状态。指该线程已经被创建，与操作系统相关联，等待cpu给它分配时间片就可运行。
3. 运行状态，指线程获取了CPU时间片，正在运行
   
   当CPU时间片用完，线程会转换至【可运行状态】，等待 CPU再次分配时间片，会导致我们前面讲到的上下文切换
4. 阻塞状态
   
   如果调用了阻塞API，如BIO读写文件，那么线程实际上不会用到CPU，不会分配CPU时间片，会导致上下文切换，进入【阻塞状态】
   
   等待BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】
   
   与【可运行状态】的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，CPU就一直不会分配时间片
5. 终止状态，表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态

### 2.7.2 线程六种状态

这是从 Java API 层面来描述的，我们主要研究的就是这种。根据 `Thread.State` 枚举，分为六种状态。状态转换详情图：[地址](https://www.jianshu.com/p/ec94ed32895f) 

![](D:\Java\笔记\图片\1-06【并发】\1-5线程6种状态.png)

1. NEW 跟五种状态里的初始状态是一个意思
2. RUNNABLE 是当调用了 `start()` 方法之后的状态，注意，Java API 层面的 `RUNNABLE` 状态涵盖了操作系统层面的【可运行状态】、【运行状态】和【io阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）
3. `BLOCKED` ， `WAITING` ，`TIMED_WAITING` 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节详述。
4. `TERMINATED` 当线程代码运行结束

下面来演示一下：

```java
/**
 * 演示线程6种状态：
 *      NEW、RUNNABLE、TERMINATED、TIMED_WAITING、WAITING、BLOCKED。
 */
@Slf4j
public class Demo01 {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            log.debug("t1线程创建但是不运行 NEW状态");
        }, "t1");

        // t2线程创建且运行 一直循环并没有关闭 所以RUNNABLE状态
        Thread t2 = new Thread(() -> {
            while (true) {

            }
        }, "t2");
        t2.start();

        Thread t3 = new Thread(() -> {
            log.debug("创建且运行完毕 所以TERMINATED");
        }, "t3");
        t3.start();

        // 加一个锁后面有用 这里是有时间的睡眠 所以状态是TIMED_WAITING
        Thread t4 = new Thread(() -> {
            synchronized(Demo01.class) {
                try {
                    Thread.sleep(100000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "t4");
        t4.start();

        // join方法 等待t2线程运行完毕后 t5线程才会运行 但是t2是while循环 所以状态为WAITING
        Thread t5 = new Thread(() -> {
            try {
                t2.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "t5");
        t5.start();

        // 因为上面拿到了锁 所以这里无法拿到 处于锁阻塞BLOCKED状态
        Thread t6 = new Thread(() -> {
            synchronized(Demo01.class) {
                try {
                    Thread.sleep(100000000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "t6");
        t6.start();

        log.debug("t1 state: {}", t1.getState());
        log.debug("t2 state: {}", t2.getState());
        log.debug("t3 state: {}", t3.getState());
        log.debug("t4 state: {}", t4.getState());
        log.debug("t5 state: {}", t5.getState());
        log.debug("t6 state: {}", t6.getState());
    }
}
```

```apl
08:07:24.113 [main] DEBUG com.linxuan.demo01.Demo01 - t1 state: NEW
08:07:24.113 [t3] DEBUG com.linxuan.demo01.Demo01 - 创建且运行完毕 所以TERMINATED
08:07:24.119 [main] DEBUG com.linxuan.demo01.Demo01 - t2 state: RUNNABLE
08:07:24.119 [main] DEBUG com.linxuan.demo01.Demo01 - t3 state: TERMINATED
08:07:24.119 [main] DEBUG com.linxuan.demo01.Demo01 - t4 state: TIMED_WAITING
08:07:24.119 [main] DEBUG com.linxuan.demo01.Demo01 - t5 state: WAITING
08:07:24.120 [main] DEBUG com.linxuan.demo01.Demo01 - t6 state: BLOCKED
```

## 2.8 线程状态转换详解

![](D:\Java\笔记\图片\1-06【并发】\1-5线程6种状态.png)

假设有线程 `Thread t`

**情况 1：`NEW --> RUNNABLE`**

* 当调用 `t.start()` 方法时，由 `NEW --> RUNNABLE`。

**情况 2：`RUNNABLE <--> WAITING`**

* t 线程用 `synchronized(obj)` 获取了对象锁后

  调用 `obj.wait()` 方法时，t 线程从 `RUNNABLE --> WAITING`

  调用 `obj.notify()` ， `obj.notifyAll()` ， `t.interrupt()` 时

  * 竞争锁成功，t 线程从 `WAITING --> RUNNABLE`
  * 竞争锁失败，t 线程从 `WAITING --> BLOCKED`

  ```java
  public class TestWaitNotify {
      final static Object obj = new Object();
      public static void main(String[] args) {
          new Thread(() -> {
              synchronized (obj) {
                  log.debug("执行....");
                  try {
                      obj.wait();
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
                  log.debug("其它代码...."); // 断点
              }
          },"t1").start();
          new Thread(() -> {
              synchronized (obj) {
                  log.debug("执行....");
                  try {
                      obj.wait();
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
                  log.debug("其它代码...."); // 断点
              }
          },"t2").start();
  
          sleep(0.5);
          log.debug("唤醒 obj 上其它线程");
          synchronized (obj) {
              obj.notifyAll(); // 唤醒obj上所有等待线程 断点
          }
      }
  }
  ```

**情况 3：`RUNNABLE <--> WAITING`**

* 当前线程调用 `t.join()` 方法时，当前线程从 `RUNNABLE --> WAITING`。注意是当前线程在`t` 线程对象的监视器上等待，因为join方法就是等待线程运行结束，所以当前线程等待t线程运行结束，当前线程变为`WATING`状态。
* t 线程运行结束，或调用了当前线程的 `interrupt()` 时，当前线程从 `WAITING --> RUNNABLE`。

**情况 4：`RUNNABLE <--> WAITING`**

* 当前线程调用 `LockSupport.park()` 方法会让当前线程从 `RUNNABLE --> WAITING`

* 调用 `LockSupport.unpark(目标线程)` 或调用了线程的 `interrupt()` ，会让目标线程从 `WAITING --> RUNNABLE`。

**情况 5：`RUNNABLE <--> TIMED_WAITING`**

* t 线程用 `synchronized(obj)` 获取了对象锁后

  调用 `obj.wait(long n)` 方法时，t 线程从 `RUNNABLE --> TIMED_WAITING`

  t 线程等待时间超过了 n 毫秒，或调用 `obj.notify()` ， `obj.notifyAll()` ， `t.interrupt()` 时

  * 竞争锁成功，t 线程从 `TIMED_WAITING --> RUNNABLE`
  * 竞争锁失败，t 线程从 `TIMED_WAITING --> BLOCKED`

**情况 6：`RUNNABLE <--> TIMED_WAITING`**

* 当前线程调用 `t.join(long n)` 方法时，当前线程从 `RUNNABLE --> TIMED_WAITING`注意是当前线程在t 线程对象的监视器上等待。
* 当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 `interrupt()` 时，当前线程从`TIMED_WAITING --> RUNNABLE`

**情况 7：`RUNNABLE <--> TIMED_WAITING`**

- 当前线程调用 `Thread.sleep(long n)` ，当前线程从 `RUNNABLE --> TIMED_WAITING`
- 当前线程等待时间超过了 n 毫秒，当前线程从 `TIMED_WAITING --> RUNNABLE`

**情况 8：`RUNNABLE <--> TIMED_WAITING`**

- 当前线程调用 `LockSupport.parkNanos(long nanos)` 或 `LockSupport.parkUntil(long millis)` 时，当前线
  程从 `RUNNABLE --> TIMED_WAITING`
- 调用 `LockSupport.unpark(目标线程)` 或调用了线程的 `interrupt()` ，或是等待超时，会让目标线程从
  `TIMED_WAITING--> RUNNABLE`

**情况 9：`RUNNABLE <--> BLOCKED`**

- t 线程用 `synchronized(obj)` 获取了对象锁时如果竞争失败，从 `RUNNABLE --> BLOCKED`
- 持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争
  成功，从 `BLOCKED --> RUNNABLE` ，其它失败的线程仍然 BLOCKED

**情况 10：`RUNNABLE <--> TERMINATED`**

* 当前线程所有代码运行完毕，进入 `TERMINATED`
