学习路线如下：

![](D:\Java\笔记\图片\1-06【并发】\0-00000005.png)

本系列代码在JDK8下实现：

```xml
<properties>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
</properties>
<dependencies>
    <!--导入Lombok，简化JavaBean的编写-->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>1.18.10</version>
    </dependency>
    <!--使用Logback日志来实现-->
    <dependency>
        <groupId>ch.qos.logback</groupId>
        <artifactId>logback-classic</artifactId>
        <version>1.2.3</version>
    </dependency>
</dependencies>
```

```xml
<!--logback.xml配置文件-->
<?xml version="1.0" encoding="UTF-8"?>
<configuration
               xmlns="http://ch.qos.logback/xml/ns/logback"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xsi:schemaLocation="http://ch.qos.logback/xml/ns/logback logback.xsd">
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%date{HH:mm:ss} [%t] %logger - %m%n</pattern>
        </encoder>
    </appender>
    <logger name="c" level="debug" additivity="false">
        <appender-ref ref="STDOUT"/>
    </logger>
    <root level="ERROR">
        <appender-ref ref="STDOUT"/>
    </root>
</configuration>
```

# 第一章 基础概念

## 1.1 进程与线程

进程是资源分配的最小单位，线程是CPU调度的最小单位。

* **进程**

  程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。
  进程就是用来加载指令、管理内存、管理 IO 的。当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）。

* **线程**

  一个进程之内可以分为一到多个线程。一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 。
  Java 中，进程是资源分配的最小单位，线程是CPU调度的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器。

**进程和线程对比**

- 进程基本上相互独立的，而线程存在于进程内，是进程的一个子集
- 进程拥有共享的资源，如内存空间等，供其内部的线程共享
- 进程间通信较为复杂
  - 同一台计算机的进程通信称为 `IPC`（`Inter-process communication`）
  - 不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP
- 线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量。
- 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低。进程切换涉及内存空间的切换而线程不会。因为每个进程都有自己的内存空间，而线程是共享所在进程的内存空间的，因此同一个进程中的线程进行线程切换时不涉及内存空间的转换。所以线程上下文切换成本低。

## 1.2 并发与并行

* **并发**

  在单核 cpu 下，线程实际还是串行执行的。
  操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows 下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感觉是同时运行的 。一般会将这种线程轮流使用 CPU 的做法称为并发（concurrent）。

* **并行**

  多核 cpu下，每个核（core） 都可以调度运行线程，这时候线程可以是并行的，不同的线程同时使用不同的cpu在执行。

引用 Rob Pike 的一段描述：并发是同一时间应对（dealing with）多件事情的能力，并行（parallel）是同一时间动手做（doing）多件事情的能力。

举个例子：

- 家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发。
- 雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是并行。
- 家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一 个人用锅时，另一个人就得等待）。

## 1.3 多线程应用

**异步调用**

首先来看一下同步和异步的概念：

- 需要等待结果返回，才能继续运行就是同步
- 不需要等待结果返回，就能继续运行就是异步

多线程可以使方法的执行变成异步的，比如说读取磁盘文件时，假设读取操作花费了5秒，如果没有线程的调度机制，这么cpu只能等5秒，啥都不能做。

**提高效率**

这里用的式JMH测试，但是我不会使用。就凉了。之后学一下JMH。直接说结论：

1. 单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，让不同线程轮流使用cpu ，不至于一个线程总占用 cpu，别的线程没法干活
2. 多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的
  * 有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任
    务都能拆分。
  * 也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义
3. IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化。

# 第二章 java线程

## 2.1 创建线程三种方法

### 2.1.1 Thread

```java
// 构造方法的参数是给线程指定名字，推荐给线程起个名字
Thread t1 = new Thread("t1") {
    @Override
    // run 方法内实现了要执行的任务
    public void run() {
        log.debug("hello");
    }
};
t1.start();
```

### 2.1.2 Runnable配合Thread

把【线程】和【任务】（要执行的代码）分开，Thread 代表线程，Runnable 可运行的任务（线程要执行的代码）

```java
// 创建任务对象
Runnable task2 = new Runnable() {
    @Override
    public void run() {
        log.debug("hello");
    }
};
// 参数1 是任务对象; 参数2 是线程名字，推荐给线程起个名字
Thread t2 = new Thread(task2, "t2");
t2.start();
```

方法1 是把线程和任务合并在了一起，方法2是把线程和任务分开了，用 Runnable 更容易与线程池等高级 API 配合，用 Runnable 让任务类脱离了 Thread 继承体系，更灵活。设计模式里面提到组合优先于继承。

通过查看源码可以发现，方法二其实到底还是通过方法一执行的！

### 2.1.3 FutureTask配合Thread

这种就是函数式接口的应用。

FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况。

```java
@Slf4j
public class Demo01 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // 实现多线程的第三种方法可以返回数据
        FutureTask<Integer> futureTask = new FutureTask<>(new Callable<Integer>() {
            @Override
            public Integer call() throws Exception {
                log.debug("多线程任务");
                Thread.sleep(100);
                return 100;
            }
        });
        // 主线程阻塞，同步等待 task 执行完毕的结果
        new Thread(futureTask,"linxuan").start();
        log.debug("主线程");
        log.debug("{}",futureTask.get());
    }
}
```

Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。

追踪一下源码：

```java
public class FutureTask<V> implements RunnableFuture<V> {
    // 省略类中内容
}
```

```java
public interface RunnableFuture<V> extends Runnable, Future<V> {
    void run();
}
```

```java
public interface Future<V> {
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException;
    V get(long timeout, TimeUnit unit) 
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

Future提供了三种功能：

1. 判断任务是否完成；
2. 能够中断任务；
3. 能够获取任务执行结果。

可以看一下这篇文章：[FutureTask是Future和Runable的实现](https://mp.weixin.qq.com/s/RX5rVuGr6Ab0SmKigmZEag)

## 2.2 查看进程的方法

**windows**

- 任务管理器可以查看进程和线程数，也可以用来杀死进程

- tasklist 查看进程

- taskkill 杀死进程

  ```java
  D:\Java\vscode-java\JUC>tasklist | findstr java
  java.exe                      5284 Console                    3    368,928 K
  java.exe                      8964 Console                    3     17,428 K
  java.exe                      2860 Console                    3    238,616 K
  java.exe                      9032 Console                    3     21,252 K
  
  D:\Java\vscode-java\JUC>jps // jps命令是Java中的命令
  5284 org.eclipse.equinox.launcher_1.6.400.v20210924-0641.jar
  8964 XMLServerLauncher
  9032 Demo02
  2860 BootLanguageServerBootApp
  4076 Jps
  
  D:\Java\vscode-java\JUC>taskkill /F /PID 9032
  成功: 已终止 PID 为 9032 的进程。
  ```

**linux**

- ps -ef 查看所有进程
- ps -fT -p 查看某个进程（PID）的所有线程
- kill 杀死进程
- top 按大写 H 切换是否显示线程
- top -H -p 查看某个进程（PID）的所有线程

**Java**

- ps 命令查看所有 Java 进程

- jstack 查看某个 Java 进程（PID）的所有线程状态

- jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）

  下面来看一下Jconsole远程连接：

  ```apl
  # 使用下面的方式运行Java类 ''需要删除掉
  java -Djava.rmi.server.hostname=`ip地址` -Dcom.sun.management.jmxremote -
  Dcom.sun.management.jmxremote.port=`连接端口` -Dcom.sun.management.jmxremote.ssl=是否安全连接 -
  Dcom.sun.management.jmxremote.authenticate=是否认证 java类
  ```


## 2.2 线程运行原理

**虚拟机栈与栈帧**

Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。

每个线程运行需要的内存空间，称为虚拟机栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用，是线程私有的。

每个栈由多个栈帧组成，对应着每次调用方法时所占用的内存。每个线程只能有一个活动栈帧，对应着当前正在执行的方法。

- 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存
- 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法

**线程上下文切换**

线程上下文切换（Thread Context Switch）：因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码

- 线程的 cpu 时间片用完(每个线程轮流执行，看前面并行的概念)
- 垃圾回收
- 有更高优先级的线程需要运行
- 线程自己调用了 `sleep`、`yield`、`wait`、`join`、`park`、`synchronized`、`lock` 等方法

当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的。

操作系统需要保存的状态信息包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等。Context Switch 频繁发生会影响性能

## 2.3 Thread的常见方法

非静态方法：

| 方法名           | 功能说明                                                     |
| ---------------- | ------------------------------------------------------------ |
| start()          | 启动一个新线程，运行线程内的run方法<br />该方法只是让线程进入就绪，代码不一定运行，比如CUP的时间片还没有分配给该线程。每个线程对象的start方法只能调用一次，如果调用多次会出现`IllegalThreadStateException` |
| run()            | 新线程启用后会调用的方法<br />如果在构造Thread对象时传递了Runnable参数，则线程启动后调用Runnable中的run方法，否则默认不执行任何操作。但可以创建Thread的子类对象，来覆盖默认行为 |
| join()           | 等待线程运行结束                                             |
| join(long n)     | 等待线程运行结束，最多等待n毫秒                              |
| getId()          | 获取线程长整型的id，id唯一                                   |
| getName()        | 获取线程名                                                   |
| setName(String)  | 修改线程名                                                   |
| getPriority()    | 获取线程优先级                                               |
| getPriority(int) | 修改线程优先级<br />java中规定优先级是1~10的整数，比较大优先级能提高该线程被CPU调用的几率 |
| getState()       | 获取线程状态<br />Java 中线程状态是用 6 个 enum 表示，分别为： `NEW`, `RUNNABLE`, `BLOCKED`, `WAITING`, `TIMED_WAITING`, `TERMINATED` |
| isAlive()        | 判断线程是否存活 ，是否运行完毕                              |
| interrupt()      | 打断线程<br />如果被打断线程在 `sleep`、`wait`、`join`则会导致被打断的线程抛出`InterruptedException`异常，并清除打断标记 ；<br />如果打断的是正在运行的线程，则会设置打断标 记 ；<br />park的线程被打断，也会设置打断标记 |
| isInterrupted()  | 判断线程是否被打断，不会清除 `"打断标记"`                    |

 四个静态方法如下：

| 方法名          | static | 功能说明                                                | 注意               |
| --------------- | ------ | ------------------------------------------------------- | ------------------ |
| interrupted()   | static | 判断当前线程是否被打断                                  | 会清除打断标记     |
| currentThread() | static | 获取当前正在执行的线程                                  |                    |
| sleep(long n)   | static | 当前执行的线程休眠n毫秒 休眠时让出cpu的时间片给其它线程 |                    |
| yield()         | static | 提示线程调度器 让出当前线程对 CPU的使用                 | 主要为了测试和调试 |

### 2.3.1 start 与 run

**start方法**

调用start方法，能不能运行任务调度器说了算。

```java
public static void main(String[] args) throws InterruptedException {
    Thread thread = new Thread(){
        @Override
        public void run(){
            log.debug("我是一个新建的线程正在运行中");
        }
    };
    thread.setName("新建线程");
    thread.start();
    Thread.sleep(1000);
    log.debug("主线程");
}
```

输出信息如下：	

```properties
09:12:24.559 [新建线程] DEBUG com.linxuan.demo01.Demo01 - 我是一个新建的线程正在运行中
09:12:25.563 [main] DEBUG com.linxuan.demo01.Demo01 - 主线程
```

**调用run**

将上面代码的`thread.start();`改为 `thread.run();`。输出结果如下：

```properties
09:17:07.175 [main] DEBUG com.linxuan.demo01.Demo01 - 我是一个新建的线程正在运行中
09:17:08.185 [main] DEBUG com.linxuan.demo01.Demo01 - 主线程
```

程序仍在 main 线程运行， `run()`方法里面内容的调用还是同步的

**小结**

直接调用 `run()` 是在主线程中执行了 `run()`，没有启动新的线程。使用 `start()` 是启动新的线程，通过新的线程间接执行 `run()`方法 中的代码

当调用start方法，线程状态会由“`NEW`”变为“`RUNABLE`”，此时再次调用start方法会报错`IllegalThreadStateException`非法的状态异常。

### 2.3.2 sleep 与 yield

**sleep**

sleep方法是静态的，所以调用的时候直接`Thread.sleep(long n);单位是毫秒`就可以了，sleep方法在哪个线程使用那么就是哪个线程睡眠阻塞。

1. 调用 sleep 会让当前线程从 `Running` 进入 `Timed Waiting` 状态（阻塞）

2. 可以使用`interrupt`方法打断正在睡眠的线程，那么被打断的线程这时就会抛出 `InterruptedException`异常【注意：这里打断的是正在休眠的线程，而不是其它状态的线程】

3. 睡眠结束后的线程未必会立刻得到执行(需要分配到cpu时间片)

4. 建议用 TimeUnit 的 `sleep()` 代替 Thread 的 `sleep()`来获得更好的可读性。TimeUnit有时间单位，例如：`TimeUnit.SECONDS.sleep(1);`。当然二者效果一样。

5. 可以使用sleep方法来限制程序的CPU的使用
   在没有利用 cpu 来计算时，不要让 while(true) 空转浪费 cpu，这时可以使用 yield 或 sleep 来让出 cpu 的使用权 给其他程序

   ```java
   while(true) {
       try {
           Thread.sleep(50);
       } catch (InterruptedException e) {
           e.printStackTrace();
       }
   }
   // 加上sleep方法后CPU占用为4%，不加sleep方法CPU占用为100%
   ```

   可以用 wait 或 条件变量达到类似的效果，不同的是，后两种都需要加锁，并且需要相应的唤醒操作，一般适用于要进行同步的场景。sleep 适用于无需锁同步的场景。

这里我们封装一个sleep方法自己使用，以后再次使用sleep的时候导包就可以了：

```java
package com.linxuan.util;
import java.util.concurrent.TimeUnit;

public class Sleeper {
    public static void sleep(int i) {
        try {
            TimeUnit.SECONDS.sleep(i);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static void sleep(double i) {
        try {
            TimeUnit.MILLISECONDS.sleep((int) (i * 1000));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

**yield**

1. 调用 yield 会让当前线程从 `Running` 进入 `Runnable` 就绪状态，然后调度执行其它线程。`Runnable` 就绪状态不同于 `Timed Waiting` 阻塞状态，`Runnable`就绪状态有可能分配时间片，而`Timed Waiting`阻塞状态在阻塞期间内不会分配时间片。
2. 具体的实现依赖于操作系统的任务调度器，就是可能没有其它的线程正在执行，虽然调用了`yield`方法，但是没有任何卵用，依然执行该线程。

**线程优先级**

* 线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它

* 如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用

  ```java
  public static void main(String[] args) throws InterruptedException {
      
      Runnable task1 = () -> {
          int count = 0;
          for (;;) {
              System.out.println("---->1 " + count++);
          }
      };
      Runnable task2 = () -> {
          int count = 0;
          for (;;) {
              // 设置线程2让出时间片 从Running状态进入Runnable状态
              // Thread.yield();
              System.out.println("    ---->2 " + count++);
          }
      };
      Thread t1 = new Thread(task1, "t1");
      Thread t2 = new Thread(task2, "t2");
      // 设置线程优先级 线程1优先级为最低1级 线程2优先级为最高2级
      // t1.setPriority(Thread.MIN_PRIORITY);
      // t2.setPriority(Thread.MAX_PRIORITY);
      t1.start();
      t2.start();
  }
  ```

### 2.3.3 join

`join()` ：等待线程运行结束，非静态方法，哪个线程调用join方法就会等待哪个线程运行结束。

`join(long n)` ：等待线程运行结束，最多等待n毫秒。

下面代码不加上join方法那么结果为0，加上join方法结果为10。在主线程中调用t1.join，则主线程会等待t1线程执行完之后再继续执行。

```java
static int r = 0;

public static void main(String[] args) throws InterruptedException {
    log.debug("开始");
    Thread t1 = new Thread(() -> {
        log.debug("开始");
        try {
            Thread.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.debug("结束");
        r = 10;
    }, "t1");
    t1.start();
    // t1.join();
    log.debug("结果为:{}", r);
    log.debug("结束");
}
```

示意图如下：

![](D:\Java\笔记\图片\1-06【并发】\1-1.png)

上面是单个线程的join方法调用，下面我们来看一下多个线程的join方法调用：

```java
// jdk1.5特性，静态导入
import static com.linxuan.util.Sleeper.sleep;

@Slf4j
public class Demo01 {
    static int r1 = 0;
    static int r2 = 0;

    public static void main(String[] args) throws InterruptedException {
        test2();
    }

    private static void test2() throws InterruptedException {
        Thread t1 = new Thread(() -> {
            sleep(1);
            r1 = 10;
        });
        Thread t2 = new Thread(() -> {
            sleep(2);
            r2 = 20;
        });
        long start = System.currentTimeMillis();
        t1.start();
        t2.start();
        log.debug("join开始了");
        t1.join();
        log.debug("t1.join结束");
        t2.join();
        log.debug("t2.join结束");
        long end = System.currentTimeMillis();
        log.debug("r1: {} r2: {} cost: {}", r1, r2, end - start);
    }
}
```

来分析一下，主线程共需要等待多少时间：

- 第一个 join：等待 t1 时, t2 并没有停止, 而在运行。也就是等待t1线程1s，这时候t2线程也运行了1s。
- 第二个 join：t2在之前运行了1s，因此也只需再等待 1s。
- 也就是一共需要等待2秒。

```properties
08:34:07.002 [main] DEBUG com.linxuan.demo01.Demo01 - join开始了
08:34:08.013 [main] DEBUG com.linxuan.demo01.Demo01 - t1.join结束
08:34:09.014 [main] DEBUG com.linxuan.demo01.Demo01 - t2.join结束
08:34:09.015 [main] DEBUG com.linxuan.demo01.Demo01 - r1: 10 r2: 20 cost: 2016
```

那么问题来了？假如我们调整一下`t1.join();`和`t2.join();`的执行顺序后，主线程还需要等待多少时间呢？答案就是仍然2秒，不会有任何变化。

![](D:\Java\笔记\图片\1-06【并发】\1-2.png)

### 3.3.4 interrupt

* `void interrupt()`：打断线程。如果被打断线程在`sleep、wait和join`状态则会导致被打断的线程抛出`InterruptedException`异常，并清除打断标记 ；如果打断的是正在运行的线程，则会设置打断标记 ；park的线程被打断，也会设置打断标记
* `boolean isInterrupted()`：判断线程是否被打断，不会清除 `"打断标记"`。
* `static boolean interrupted()`：判断当前线程是否被打断，会清除打断标记。

先了解一些interrupt()方法的相关知识：[博客地址](https://www.cnblogs.com/noteless/p/10372826.html#0)

**打断阻塞状态线程**

sleep，wait，join 的线程，这几个方法都会让线程进入阻塞状态，而interrupt方法会打断阻塞线程。下面以sleep方法实例：

```java
@Slf4j
public class Demo02 {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            log.debug("t1线程睡眠");
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "t1");

        t1.start();
        Thread.sleep(1000);
        log.debug("interrupted");
        t1.interrupt();
        // 看一下打断标记 true为打断了 false为非打断
        // 但是sleep join wait方法会重置打断标记 所以最后结果为false.
        log.debug("打断标记结果为：" + t1.isInterrupted());
    }
}
```

```apl
09:01:23.994 [t1] DEBUG com.linxuan.demo01.Demo02 - t1线程睡眠
09:01:24.996 [main] DEBUG com.linxuan.demo01.Demo02 - interrupted
09:01:24.997 [main] DEBUG com.linxuan.demo01.Demo02 - 打断标记结果为：false
java.lang.InterruptedException: sleep interrupted
        at java.lang.Thread.sleep(Native Method)
        at com.linxuan.demo01.Demo02.lambda$0(Demo02.java:11)
        at java.lang.Thread.run(Thread.java:748)
```

**打断正常运行的线程**

打断正常运行的线程, 不会清空打断状态，也不会停止线程，因此我们需要自己来根据打断标记手动停止线程。

```java
public static void main(String[] args) throws InterruptedException {
    Thread t1 = new Thread(() -> {
        while(true) {
            if (Thread.currentThread().isInterrupted()) {
                log.debug("线程被打断了");
                break;
            }
        }
    }, "t1");
    t1.start();
    Thread.sleep(1000);
    log.debug("interrupt");
    t1.interrupt();
}
```

**打断 park 线程**

打断 park 线程, 不会清空打断状态

```java
@Slf4j
public class Demo02 {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            log.debug("park...");
            LockSupport.park();
            log.debug("unpark...");
            log.debug("打断状态：{}", Thread.currentThread().isInterrupted());
        }, "t1");
        t1.start();
        
        sleep(0.5);
        t1.interrupt();
    }
}
```

```apl
17:40:12.308 [t1] DEBUG com.linxuan.demo01.Demo02 - park...
17:40:12.817 [t1] DEBUG com.linxuan.demo01.Demo02 - unpark...
17:40:12.817 [t1] DEBUG com.linxuan.demo01.Demo02 - 打断状态：true
```

如果打断标记已经是 true, 则 park 会失效

```java
@Slf4j
public class Demo02 {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                log.debug("park...");
                LockSupport.park();
                log.debug("打断状态：{}", Thread.currentThread().isInterrupted());
            }
        });
        t1.start();
        sleep(1);
        t1.interrupt();

    }
}
```

```apl
17:41:16.022 [Thread-0] DEBUG com.linxuan.demo01.Demo02 - park...
17:41:17.030 [Thread-0] DEBUG com.linxuan.demo01.Demo02 - 打断状态：true
17:41:17.034 [Thread-0] DEBUG com.linxuan.demo01.Demo02 - park...
17:41:17.035 [Thread-0] DEBUG com.linxuan.demo01.Demo02 - 打断状态：true
17:41:17.036 [Thread-0] DEBUG com.linxuan.demo01.Demo02 - park...
17:41:17.037 [Thread-0] DEBUG com.linxuan.demo01.Demo02 - 打断状态：true
17:41:17.038 [Thread-0] DEBUG com.linxuan.demo01.Demo02 - park...
17:41:17.039 [Thread-0] DEBUG com.linxuan.demo01.Demo02 - 打断状态：true
17:41:17.040 [Thread-0] DEBUG com.linxuan.demo01.Demo02 - park...
17:41:17.041 [Thread-0] DEBUG com.linxuan.demo01.Demo02 - 打断状态：true
```

可以使用 `Thread.interrupted()` 清除打断状态。

### 3.3.5 方法总结

关于join的原理和这几个方法的对比：[看这里](https://blog.csdn.net/dataiyangu/article/details/104956755)

1. sleep，join，yield，interrupted是Thread类中的方法
2. wait/notify是object中的方法

sleep 不释放锁、释放cpu。join 释放锁、抢占cpu。yiled 不释放锁、释放cpu。wait 释放锁、释放cpu。

## 2.4 两阶段终止模式

终止模式之两阶段终止模式Two Phase Termination，就是考虑在一个线程T1中如何优雅地终止另一个线程T2。这里的优雅指的是给T2一个料理后事的机会（如释放锁）。

先来看一下两种错误的思路：

- 使用线程对象的 `stop()` 方法停止线程。`stop` 方法会真正杀死线程。但是如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁。
- 使用 `System.exit(int)` 方法停止线程。我们目的仅是停止一个线程，但这种做法会让整个程序都停止。

正确思路如下：线程的`isInterrupted()`方法可以取得线程的打断标记，如果线程在睡眠`sleep`期间被打断，打断标记虽然被重置为`false`，但是`sleep`期间被打断会抛出异常，我们据此手动设置打断标记为`true`；如果是在程序正常运行期间被打断的，那么打断标记就被自动设置为`true`。

<img src="D:\Java\笔记\图片\1-06【并发】\1-3.png"/>

代码实现如下：

```java
@Slf4j
public class Demo02 {
    public static void main(String[] args) throws InterruptedException {
        TwoParseTermination tpt = new TwoParseTermination();
        tpt.start();
        Thread.sleep(3500);
        tpt.stop();        
    }
}
```

```java
@Slf4j
public class TwoParseTermination {
    Thread thread;

    // 启动监控线程
    public void start() {
        thread = new Thread(() -> {
            while (true) {
                Thread currentThread = Thread.currentThread();
                if (currentThread.isInterrupted()) {
                    log.debug("料理后事");
                    break;
                }
                try {
                    // 让线程睡眠 如果有异常那么捕获抛出打印
                    Thread.sleep(1000);
                    // 线程没有异常 执行监控记录
                    log.debug("执行监控记录");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    // 因为打断标记会被重置 所以这里我们重新打断一下 设置为true
                    currentThread.interrupt();
                }
            }
        });
        thread.start();
    }

    // 停止监控线程
    public void stop() {
        thread.interrupt();
    }
}
```

```apl
17:11:01.652 [t1] DEBUG com.linxuan.demo01.TwoParseTermination - 执行监控记录
17:11:02.666 [t1] DEBUG com.linxuan.demo01.TwoParseTermination - 执行监控记录
17:11:03.668 [t1] DEBUG com.linxuan.demo01.TwoParseTermination - 执行监控记录
java.lang.InterruptedException: sleep interrupted
        at java.lang.Thread.sleep(Native Method)
        at com.linxuan.demo01.TwoParseTermination.lambda$0(Demo02.java:30)
        at java.lang.Thread.run(Thread.java:748)
17:11:04.146 [t1] DEBUG com.linxuan.demo01.TwoParseTermination - 料理后事
```

## 2.5 不推荐的方法

还有一些不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁。这些方法已经用注解标记上了`@Deprecated`。

| 方法名    | static | 功能说明             |
| --------- | ------ | -------------------- |
| stop()    |        | 停止线程运行         |
| suspend() |        | 挂起（暂停）线程运行 |
| resume()  |        | 恢复线程运行         |

## 2.6 守护线程

默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。

有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。

```java
@Slf4j
public class Demo02 {
    public static void main(String[] args) {
        log.debug("开始运行...");

        Thread t1 = new Thread(() -> {
            log.debug("开始运行...");
            sleep(2);
            log.debug("运行结束...");
        }, "daemon");
        // 设置该线程为守护线程
        t1.setDaemon(true);
        t1.start();

        sleep(1);
        log.debug("运行结束...");
    }
}
```

```apl
18:02:44.128 [main] DEBUG com.linxuan.demo01.Demo02 - 开始运行...
18:02:44.202 [daemon] DEBUG com.linxuan.demo01.Demo02 - 开始运行...
18:02:45.205 [main] DEBUG com.linxuan.demo01.Demo02 - 运行结束...
```

- 垃圾回收器线程就是一种守护线程。
- Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等 待它们处理完当前请求

## 2.7 线程状态

众说纷纭，所以直接两种都讲一下。

### 2.7.1 线程五种状态

五种状态的划分主要是从操作系统的层面进行划分的

![](D:\Java\笔记\图片\1-06【并发】\1-4线程5种状态.png)

1. 初始状态，仅仅是在语言层面上创建了线程对象`Thead thread = new Thead();`还未与操作系统线程关联。
2. 可运行状态，也称就绪状态。指该线程已经被创建，与操作系统相关联，等待cpu给它分配时间片就可运行。
3. 运行状态，指线程获取了CPU时间片，正在运行
   
   当CPU时间片用完，线程会转换至【可运行状态】，等待 CPU再次分配时间片，会导致我们前面讲到的上下文切换
4. 阻塞状态
   
   如果调用了阻塞API，如BIO读写文件，那么线程实际上不会用到CPU，不会分配CPU时间片，会导致上下文切换，进入【阻塞状态】
   
   等待BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】
   
   与【可运行状态】的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，CPU就一直不会分配时间片
5. 终止状态，表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态

### 2.7.2 线程六种状态

这是从 Java API 层面来描述的，我们主要研究的就是这种。根据 `Thread.State` 枚举，分为六种状态。状态转换详情图：[地址](https://www.jianshu.com/p/ec94ed32895f) 

![](D:\Java\笔记\图片\1-06【并发】\1-5线程6种状态.png)

| 线程状态                | 导致线程状态发生的条件                                       |
| ----------------------- | ------------------------------------------------------------ |
| NEW(新建)               | 线程刚被创建，但是没有启动。没有调用start方法。              |
| Runnable(可运行)        | 线程可以在java虚拟机中运行的状态，可能正在运行自己的代码，也可能没有，这取决于操作系统处理器 |
| Blocked(锁阻塞)         | 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。 |
| Waiting(无线等待)       | 一个线程在等待另一个线程执行一个(唤醒)动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。 |
| Timed Waiting(计时等待) | 同Waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接受到唤醒通知。带有超时参数的常用方法有Thread.sleep、Object.wait。 |
| Terminated(死亡状态)    | 已退出的线程处于这种状态                                     |

1. NEW 跟五种状态里的初始状态是一个意思
2. RUNNABLE 是当调用了 `start()` 方法之后的状态，注意，Java API 层面的 `RUNNABLE` 状态涵盖了操作系统层面的【可运行状态】、【运行状态】和【io阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）
3. `BLOCKED` ， `WAITING` ，`TIMED_WAITING` 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节详述。
4. `TERMINATED` 当线程代码运行结束

下面来演示一下：

```java
/**
 * 演示线程6种状态：
 *      NEW、RUNNABLE、TERMINATED、TIMED_WAITING、WAITING、BLOCKED。
 */
@Slf4j
public class Demo01 {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            log.debug("t1线程创建但是不运行 NEW状态");
        }, "t1");

        // t2线程创建且运行 一直循环并没有关闭 所以RUNNABLE状态
        Thread t2 = new Thread(() -> {
            while (true) {

            }
        }, "t2");
        t2.start();

        Thread t3 = new Thread(() -> {
            log.debug("创建且运行完毕 所以TERMINATED");
        }, "t3");
        t3.start();

        // 加一个锁后面有用 这里是有时间的睡眠 所以状态是TIMED_WAITING
        Thread t4 = new Thread(() -> {
            synchronized(Demo01.class) {
                try {
                    Thread.sleep(100000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "t4");
        t4.start();

        // join方法 等待t2线程运行完毕后 t5线程才会运行 但是t2是while循环 所以状态为WAITING
        Thread t5 = new Thread(() -> {
            try {
                t2.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "t5");
        t5.start();

        // 因为上面拿到了锁 所以这里无法拿到 处于锁阻塞BLOCKED状态
        Thread t6 = new Thread(() -> {
            synchronized(Demo01.class) {
                try {
                    Thread.sleep(100000000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "t6");
        t6.start();

        log.debug("t1 state: {}", t1.getState());
        log.debug("t2 state: {}", t2.getState());
        log.debug("t3 state: {}", t3.getState());
        log.debug("t4 state: {}", t4.getState());
        log.debug("t5 state: {}", t5.getState());
        log.debug("t6 state: {}", t6.getState());
    }
}
```

```apl
08:07:24.113 [main] DEBUG com.linxuan.demo01.Demo01 - t1 state: NEW
08:07:24.113 [t3] DEBUG com.linxuan.demo01.Demo01 - 创建且运行完毕 所以TERMINATED
08:07:24.119 [main] DEBUG com.linxuan.demo01.Demo01 - t2 state: RUNNABLE
08:07:24.119 [main] DEBUG com.linxuan.demo01.Demo01 - t3 state: TERMINATED
08:07:24.119 [main] DEBUG com.linxuan.demo01.Demo01 - t4 state: TIMED_WAITING
08:07:24.119 [main] DEBUG com.linxuan.demo01.Demo01 - t5 state: WAITING
08:07:24.120 [main] DEBUG com.linxuan.demo01.Demo01 - t6 state: BLOCKED
```

## 2.8 线程状态转换详解

![](D:\Java\笔记\图片\1-06【并发】\1-5线程6种状态.png)

假设有线程 `Thread t`

**情况 1：`NEW --> RUNNABLE`**

* 当调用 `t.start()` 方法时，由 `NEW --> RUNNABLE`。

**情况 2：`RUNNABLE <--> WAITING`**

* t 线程用 `synchronized(obj)` 获取了对象锁后

  调用 `obj.wait()` 方法时，t 线程从 `RUNNABLE --> WAITING`

  调用 `obj.notify()` ， `obj.notifyAll()` ， `t.interrupt()` 时

  * 竞争锁成功，t 线程从 `WAITING --> RUNNABLE`
  * 竞争锁失败，t 线程从 `WAITING --> BLOCKED`

  ```java
  public class TestWaitNotify {
      final static Object obj = new Object();
      public static void main(String[] args) {
          new Thread(() -> {
              synchronized (obj) {
                  log.debug("执行....");
                  try {
                      obj.wait();
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
                  log.debug("其它代码...."); // 断点
              }
          },"t1").start();
          new Thread(() -> {
              synchronized (obj) {
                  log.debug("执行....");
                  try {
                      obj.wait();
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
                  log.debug("其它代码...."); // 断点
              }
          },"t2").start();
  
          sleep(0.5);
          log.debug("唤醒 obj 上其它线程");
          synchronized (obj) {
              obj.notifyAll(); // 唤醒obj上所有等待线程 断点
          }
      }
  }
  ```

**情况 3：`RUNNABLE <--> WAITING`**

* 当前线程调用 `t.join()` 方法时，当前线程从 `RUNNABLE --> WAITING`。注意是当前线程在`t` 线程对象的监视器上等待，因为join方法就是等待线程运行结束，所以当前线程等待t线程运行结束，当前线程变为`WATING`状态。
* t 线程运行结束，或调用了当前线程的 `interrupt()` 时，当前线程从 `WAITING --> RUNNABLE`。

**情况 4：`RUNNABLE <--> WAITING`**

* 当前线程调用 `LockSupport.park()` 方法会让当前线程从 `RUNNABLE --> WAITING`

* 调用 `LockSupport.unpark(目标线程)` 或调用了线程的 `interrupt()` ，会让目标线程从 `WAITING --> RUNNABLE`。

**情况 5：`RUNNABLE <--> TIMED_WAITING`**

* t 线程用 `synchronized(obj)` 获取了对象锁后

  调用 `obj.wait(long n)` 方法时，t 线程从 `RUNNABLE --> TIMED_WAITING`

  t 线程等待时间超过了 n 毫秒，或调用 `obj.notify()` ， `obj.notifyAll()` ， `t.interrupt()` 时

  * 竞争锁成功，t 线程从 `TIMED_WAITING --> RUNNABLE`
  * 竞争锁失败，t 线程从 `TIMED_WAITING --> BLOCKED`

**情况 6：`RUNNABLE <--> TIMED_WAITING`**

* 当前线程调用 `t.join(long n)` 方法时，当前线程从 `RUNNABLE --> TIMED_WAITING`注意是当前线程在t 线程对象的监视器上等待。
* 当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 `interrupt()` 时，当前线程从`TIMED_WAITING --> RUNNABLE`

**情况 7：`RUNNABLE <--> TIMED_WAITING`**

- 当前线程调用 `Thread.sleep(long n)` ，当前线程从 `RUNNABLE --> TIMED_WAITING`
- 当前线程等待时间超过了 n 毫秒，当前线程从 `TIMED_WAITING --> RUNNABLE`

**情况 8：`RUNNABLE <--> TIMED_WAITING`**

- 当前线程调用 `LockSupport.parkNanos(long nanos)` 或 `LockSupport.parkUntil(long millis)` 时，当前线
  程从 `RUNNABLE --> TIMED_WAITING`
- 调用 `LockSupport.unpark(目标线程)` 或调用了线程的 `interrupt()` ，或是等待超时，会让目标线程从
  `TIMED_WAITING--> RUNNABLE`

**情况 9：`RUNNABLE <--> BLOCKED`**

- t 线程用 `synchronized(obj)` 获取了对象锁时如果竞争失败，从 `RUNNABLE --> BLOCKED`
- 持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争
  成功，从 `BLOCKED --> RUNNABLE` ，其它失败的线程仍然 BLOCKED

**情况 10：`RUNNABLE <--> TERMINATED`**

* 当前线程所有代码运行完毕，进入 `TERMINATED`

# 第三章 共享模型之管程

- 一个程序运行多线程本身是没有问题的

- 问题出现在多个线程共享资源的时候。多个线程同时对共享资源进行读操作本身也没有问题，但是多个线程对共享资源同时进行读写操作时就有问题了


**临界区**：一段代码内如果存在对共享资源的多线程读写操作，那么称这段代码为临界区。

```java
static int counter = 0;

static void increment()
// 临界区
{
    counter++;
}
static void decrement()
// 临界区
{
    counter--;
}
```

**竞态条件**：多个线程在临界区执行，那么由于代码指令的执行不确定而导致的结果问题，称为竞态条件。

## 3.1 线程安全问题

线程出现问题的根本原因是因为线程上下文切换，导致线程里的指令没有执行完就切换执行其它线程了，下面举一个例子：

```java
public class Demo01 {
    static int count = 0;
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                count++;
            }
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                count--;
            }
        });

        t1.start();
        t2.start();
        // 等待t1和t2线程运行完之后再打印count结果值
        t1.join();
        t2.join();
        System.out.println("count: " + count);
    }
}
```

两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？以上的结果可能是正数、负数、零。为什么呢？因为 Java 中对静态变量的自增，自减并不是原子操作。

例如对于 `i++` 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令：

```java
getstatic i 				// 获取静态变量i的值
iconst_1 					// 准备常量1
iadd 						// 加法
putstatic i 				// 将修改后的值存入静态变量i
```

而对应 `i--` 也是类似：

```java
getstatic i 				// 获取静态变量i的值
iconst_1 					// 准备常量1
isub					 	// 减法
putstatic i 				// 将修改后的值存入静态变量i
```

而 Java 的内存模型如下，完成静态变量的自增，自减需要在主存和线程内存中进行数据交换：

![](D:\Java\笔记\图片\1-06【并发】\1-6-3.png)

如果是单线程以上 8 行代码是顺序执行（不会交错）没有问题：

```java
// 假设i的初始值为0
getstatic i 		// 线程1-获取静态变量i的值 线程内i=0
iconst_1 			// 线程1-准备常量1
iadd 				// 线程1-自增 线程内i=1
putstatic i 		// 线程1-将修改后的值存入静态变量i 静态变量i=1
getstatic i 		// 线程1-获取静态变量i的值 线程内i=1
iconst_1 			// 线程1-准备常量1
isub 				// 线程1-自减 线程内i=0
putstatic i 		// 线程1-将修改后的值存入静态变量i 静态变量i=0
```

![](D:\Java\笔记\图片\1-06【并发】\1-6.png)

但多线程下这 8 行代码可能交错运行：

出现负数的情况：

```java
// 假设i的初始值为0
getstatic i 		// 线程2-获取静态变量i的值 线程内i=0
iconst_1 			// 线程2-准备常量1
isub 				// 线程2-自减 线程内i=-1
getstatic i 		// 线程1-获取静态变量i的值 线程内i=0
iconst_1 			// 线程1-准备常量1
iadd 				// 线程1-自增 线程内i=1
putstatic i 		// 线程1-将修改后的值存入静态变量i 静态变量i=1
putstatic i 		// 线程2-将修改后的值存入静态变量i 静态变量i=-1
```

![](D:\Java\笔记\图片\1-06【并发】\1-6-1.png)

出现正数的情况：

```java
// 假设i的初始值为0
getstatic i 			// 线程1-获取静态变量i的值 线程内i=0
iconst_1 				// 线程1-准备常量1
iadd 					// 线程1-自增 线程内i=1
getstatic i 			// 线程2-获取静态变量i的值 线程内i=0
iconst_1 				// 线程2-准备常量1
isub 					// 线程2-自减 线程内i=-1
putstatic i 			// 线程2-将修改后的值存入静态变量i 静态变量i=-1
putstatic i 			// 线程1-将修改后的值存入静态变量i 静态变量i=1
```

![](D:\Java\笔记\图片\1-06【并发】\1-6-2.png)

## 3.2 synchronized

为了避免临界区中的竞态条件发生，有多种手段可以达到

- 阻塞式解决方案：synchronized ，Lock
- 非阻塞式解决方案：原子变量

现在讨论使用synchronized来进行解决，即俗称的对象锁，它采用互斥的方式让同一时刻至多只有一个线程持有对象锁，其他线程如果想获取这个锁就会阻塞住，这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。

虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：

- 互斥是保证临界区的竞态条件避免发生，同一时刻只能有一个线程执行临界区的代码。
- 同步是由于线程执行的先后，顺序不同但是需要一个线程等待其它线程运行到某个点。

synchronized语法如下：

```java
synchronized(对象) // 线程1获得锁， 那么线程2的状态是(blocked)
{
 临界区
}
```

### 3.2.1 synchronized语法

将之前的程序使用synchronized后计算的结果就没毛病了，当然因为加了锁，所以肯定会对性能有一定的影响。

```java
public class Demo01 {
    static int count = 0;
    static Object room = new Object();
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                synchronized(room) {
                    count++;
                }    
            }
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                synchronized(room) {
                    count--;
                }
            }
        });

        t1.start();
        t2.start();
        // 等待t1和t2线程运行完之后再打印count结果值
        t1.join();
        t2.join();
        System.out.println("count: " + count);
    }
}
```

我们可以做这样的类比：

- `synchronized(对象)` 中的对象，可以想象为一个房间（room），有唯一入口（门）房间只能一次进入一人进行计算，线程 t1，t2 想象成两个人。
- 当线程 t1 执行到 `synchronized(room)` 时就好比 t1 进入了这个房间，并锁住了门拿走了钥匙，在门内执行`count++` 代码。
- 这时候如果 t2 也运行到了 `synchronized(room)` 时，它发现门被锁住了，只能在门外等待。这就是发生了上下文切换，阻塞住了。
- 这中间即使 t1 的 cpu 时间片不幸用完，被踢出了门外（不要错误理解为锁住了对象就能一直执行下去哦），这时门还是锁住的，t1 仍拿着钥匙，t2 线程还在阻塞状态进不来，只有下次轮到 t1 自己再次获得时间片时才能开门进入。
- 当 t1 执行完 `synchronized{}` 块内的代码，这时候才会从 obj 房间出来并解开门上的锁，唤醒 t2 线程把钥匙给他。t2 线程这时才可以进入 obj 房间，锁住了门拿上钥匙，执行它的 `count--` 代码。

synchronized实际上利用对象保证了临界区代码的原子性，临界区内的代码在外界看来是不可分割的，不会被线程切换所打断。

来思考下面的问题

- 如果把 `synchronized(obj)` 放在 for 循环的外面，如何理解？
  原子性，一条count++或者count--对应的字节码是4条，5000此循环绑定在一起，那么就是这2万条指令都被加上了锁。
- 如果 t1 `synchronized(obj1)` 而 t2 `synchronized(obj2)` 会怎样运作？
  锁对象，他们两个分别为不同的对象加了锁，也就相当于进入了不同的房间。根本不会有任何作用。
- 如果 t1 `synchronized(obj)` 而 t2 没有加会怎么样？如何理解？
  锁对象，并没有任何作用。

### 3.2.2 面向对象优化

```java
class Room{
    public int count = 0;

    public void increment() {
        synchronized(this) {
            count++;
        }
    }

    public void decrement() {
        synchronized(this) {
            count--;
        }
    }

    public int getCount() {
        return count;
    }
}
```

```java
@Slf4j
public class Demo01 {

    static Room room = new Room();

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                room.increment();
            }
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                room.decrement();
            }
        });

        t1.start();
        t2.start();
        // 等待t1和t2线程运行完之后再打印count结果值
        t1.join();
        t2.join();
        System.out.println("count: " + room.getCount());
    }
}
```

### 3.2.3 方法上的synchronized

> 方法被哪个对象调用，方法中的this就代表那个对象。即谁在调用，this就代表谁。

可以加在两种方法上面，一种是静态方法，另一种是普通方法。

* 加在普通方法上面。这种方法锁住的对象是this对象，this对象就是谁调用我就是谁。

  ```java
  class Test{
      public synchronized void test() {
  
      }
  }
  //等价于
  class Test{
      public void test() {
          synchronized(this) {
  
          }
      }
  }
  ```

* 加在静态方法上面。这种方法锁住的是Class对象。

  ```java
  class Test{
      public synchronized static void test() {
      }
  }
  // 等价于
  class Test{
      public static void test() {
          synchronized(Test.class) {
  
          }
      }
  }
  ```

 不加 synchronzied 的方法就好比不遵守规则的人，不去老实排队（好比翻窗户进去的）

### 3.2.4 线程八锁练习题

其实就是考察 `synchronized` 锁住的是哪个对象

* 情况1，出现的情况为`12 或 21`。

  ```java
  public class Demo02 {
      public static void main(String[] args) {
          Number n1 = new Number();
          new Thread(() -> {
              n1.a();
          }).start();
          new Thread(() -> {
              n1.b();
          }).start();
      }
  }
  ```

  ```java
  @Slf4j
  class Number {
      public synchronized void a() {
          log.debug("1");
      }
  
      public synchronized void b() {
          log.debug("2");
      }
  }
  ```

* 情况2，出现的情况为`1s后12，或 2 1s后 1`

  ```java
  public class Demo02 {
      public static void main(String[] args) {
          Number n1 = new Number();
          new Thread(() -> {
              n1.a();
          }).start();
          new Thread(() -> {
              n1.b();
          }).start();
      }
  }
  ```

  ```java
  @Slf4j
  class Number {
      public synchronized void a() {
          try {
              Thread.sleep(1000);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          log.debug("1");
      }
  
      public synchronized void b() {
          log.debug("2");
      }
  }
  ```

* 情况3，出现的情况为`3 1s后 12 或 23 1s后 1 或 32 1s后 1`。没有加上synchronized代表不会出现互斥请款，所以任何时候都可以执行。

  ```java
  public class Demo02 {
      public static void main(String[] args) {
          Number n1 = new Number();
          new Thread(() -> {
              n1.a();
          }).start();
          new Thread(() -> {
              n1.b();
          }).start();
          new Thread(() -> {
              n1.c();
          }).start();
      }
  }
  ```

  ```java
  @Slf4j
  class Number {
      public synchronized void a() {
          try {
              Thread.sleep(1000);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          log.debug("1");
      }
  
      public synchronized void b() {
          log.debug("2");
      }
  
      public void c() {
          log.debug("3");
      }
  }
  ```

* 情况4，出现的情况为：`2 1s后 1`。因为加的锁对象都不一样，所以这两个方法不存在互斥。

  ```java
  public class Demo02 {
      public static void main(String[] args) {
          Number n1 = new Number();
          Number n2 = new Number();
          new Thread(() -> {
              n1.a();
          }).start();
          new Thread(() -> {
              n2.b();
          }).start();
      }
  }
  ```

  ```java
  @Slf4j
  class Number {
      public synchronized void a() {
          try {
              Thread.sleep(1000);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          log.debug("1");
      }
  
      public synchronized void b() {
          log.debug("2");
      }
  }
  ```

* 情况5，出现的情况为：`2 1s后 1`。静态方法锁住的是Class类对象，普通方法锁住的是方法调用的对象，锁住对象不一样，所以不会出现互斥。

  ```java
  public static void main(String[] args) {
      Number n1 = new Number();
      new Thread(()->{ n1.a(); }).start();
      new Thread(()->{ n1.b(); }).start();
  }
  ```

  ```java
  @Slf4j(topic = "c.Number")
  class Number{
      public static synchronized void a() {
          try {
              Thread.sleep(1000);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          log.debug("1");
      }
      public synchronized void b() {
          log.debug("2");
      }
  }
  ```

* 情况6，出现的情况为：`1s后12 或 2 1s后 1`。二者都是静态方法，所以锁住的随想都是Class类对象，互斥。

  ```java
  public static void main(String[] args) {
      Number n1 = new Number();
      new Thread(()->{ n1.a(); }).start();
      new Thread(()->{ n1.b(); }).start();
  }
  ```

  ```java
  @Slf4j(topic = "c.Number")
  class Number{
      public static synchronized void a() {
          try {
              Thread.sleep(1000);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          log.debug("1");
      }
      public static synchronized void b() {
          log.debug("2");
      }
  }
  ```

* 情况7，出现的情况为`2 1s后 1`。n1.a()方法锁住的对象是Class类对象，b方法锁住的对象为n2对象，所以二者不会互斥。

  ```java
  public static void main(String[] args) {
      Number n1 = new Number();
      Number n2 = new Number();
      new Thread(()->{ n1.a(); }).start();
      new Thread(()->{ n2.b(); }).start();
  }
  ```

  ```java
  @Slf4j(topic = "c.Number")
  class Number{
      public static synchronized void a() {
          try {
              Thread.sleep(1000);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          log.debug("1");
      }
      public synchronized void b() {
          log.debug("2");
      }
  }
  ```

* 情况8，出现的情况为`1s后 12， 或 2 1s后 1`。二者都是静态方法，锁住的都是同一个对象，所以会出现互斥。

  ```java
  public static void main(String[] args) {
      Number n1 = new Number();
      Number n2 = new Number();
      new Thread(()->{ n1.a(); }).start();
      new Thread(()->{ n2.b(); }).start();
  }
  ```

  ```java
  @Slf4j(topic = "c.Number")
  class Number{
      public static synchronized void a() {
          try {
              Thread.sleep(1000);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          log.debug("1");
      }
      public static synchronized void b() {
          log.debug("2");
      }
  }
  ```

## 3.3 变量的线程安全分析

对于成员变量和静态变量而言：如果没有变量没有在线程间共享，那么变量是安全的。如果变量在线程间共享，且只有读操作则线程安全；如果有读写操作，则这段代码是临界区，需要考虑线程安全。

### 3.3.1 局部变量线程安全分析

对于局部变量而言：

- 局部变量【局部变量被初始化为基本数据类型】是安全的
- 局部变量引用的对象未必是安全的
  - 如果局部变量引用的对象没有引用线程共享的对象，那么是线程安全的
  - 如果局部变量引用的对象引用了一个线程共享的对象，那么要考虑线程安全的

局部变量【局部变量被初始化为基本数据类型】是安全的，示例如下：

```java
public static void test1() {
     int i = 10;
     i++;
}
```

每个线程调用 `test1()` 方法时，会在每个线程创建一份栈帧，每个线程的栈帧内存中创建局部变量i，因此不存在共享。

![](D:\Java\笔记\图片\1-06【并发】\1-7.png)

局部变量的引用则有一些不同：

- 如果局部变量引用的对象没有引用线程共享的对象，那么是线程安全的
- 如果局部变量引用的对象引用了一个线程共享的对象，那么要考虑线程安全的

首先来看一个成员变量的例子：

```java
class ThreadUnsafe {
    ArrayList<String> list = new ArrayList<>();
    public void method1(int loopNumber) {
        for (int i = 0; i < loopNumber; i++) {
            // { 临界区, 会产生竞态条件
            method2();
            method3();
            // } 临界区
        }
    }
    private void method2() {
        list.add("1");
    }
    private void method3() {
        list.remove(0);
    }
}
```

```java
static final int THREAD_NUMBER = 2;
static final int LOOP_NUMBER = 200;
public static void main(String[] args) {
    ThreadUnsafe test = new ThreadUnsafe();
    for (int i = 0; i < THREAD_NUMBER; i++) {
        new Thread(() -> {
            test.method1(LOOP_NUMBER);
        }, "Thread" + i).start();
    }
}
```

其中一种情况是，如果线程2 还未 add，线程1 remove 就会报错：

```apl
Exception in thread "Thread1" java.lang.IndexOutOfBoundsException: Index: 0, Size: 0 
     at java.util.ArrayList.rangeCheck(ArrayList.java:657) 
     at java.util.ArrayList.remove(ArrayList.java:496) 
     at cn.itcast.n6.ThreadUnsafe.method3(TestThreadSafe.java:35) 
     at cn.itcast.n6.ThreadUnsafe.method1(TestThreadSafe.java:26) 
     at cn.itcast.n6.TestThreadSafe.lambda$main$0(TestThreadSafe.java:14) 
     at java.lang.Thread.run(Thread.java:748) 
```

分析的原因如下：无论哪个线程中的 method2 引用的都是同一个对象中的 list 成员变量，method3 与 method2 分析相同。

![](D:\Java\笔记\图片\1-06【并发】\1-8.png)

可以将list修改成局部变量，那么就不会有上述问题了

```java
class ThreadSafe {
    public final void method1(int loopNumber) {
        ArrayList<String> list = new ArrayList<>();
        for (int i = 0; i < loopNumber; i++) {
            method2(list);
            method3(list);
        }
    }
    private void method2(ArrayList<String> list) {
        list.add("1");
    }
    private void method3(ArrayList<String> list) {
        list.remove(0);
    }
}
```

分析如下：list 是局部变量，每个线程调用时会创建其不同实例，没有共享。而 method2和method3的参数是从 method1 中传递过来的，与 method1 中引用同一个对象。

![](D:\Java\笔记\图片\1-06【并发】\1-9.png)

接下来来思考一下访问修饰符修改后的影响：如果把 method2 和 method3 的方法修改为 public 会不会导致线程安全问题？

- 情况1：有其它线程调用 method2 和 method3；这种情况没有什么问题，不同的线程创建不同的List对象调用方法，不会出现线程安全问题。
- 情况2：在情况1 的基础上，为 ThreadSafe 类添加子类，子类覆盖 method2 或 method3 方法。这种情况下就会出现线程安全问题。即如下所示：

```java
class ThreadSafe {
    public final void method1(int loopNumber) {
        ArrayList<String> list = new ArrayList<>();
        for (int i = 0; i < loopNumber; i++) {
            method2(list);
            method3(list);
        }
    }
    private void method2(ArrayList<String> list) {
        list.add("1");
    }
    private void method3(ArrayList<String> list) {
        list.remove(0);
    }
}
class ThreadSafeSubClass extends ThreadSafe{
    @Override
    public void method3(ArrayList<String> list) {
        new Thread(() -> {
            list.remove(0);
        }).start();
    }
}
```

 从这个例子可以看出 private 或 final 提供【安全（线程安全）】的意义所在，请体会开闭原则中的【闭】。

### 3.3.2 常见线程安全类

1. String
2. Integer
3. StringBuffer
4. Random
5. Vector
6. Hashtable
7. java.util.concurrent 包下的类

这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。也可以理解为它们的每个方法是原子的。查看源码就可以发现，他们的方法都加了synchronized。

**线程安全类方法的组合**

虽然每个方法都是线程安全的，每个方法是原子的，但注意它们多个方法的组合不是原子的，见下面分析：

```java
Hashtable table = new Hashtable();
// 线程1，线程2
if( table.get("key") == null) {
    table.put("key", value);
}
```

```mermaid
sequenceDiagram
participant t1 as 线程1
participant t2 as 线程2
participant table
t1->>table:get("key")==null
t2->>table:get("key")==null
t2->>table:put("key",v2)
t1->>table:put("key",v1)
```

**不可变类的线程安全**

`String`和`Integer`类都是不可变的类，因为其类内部状态（属性）是不可改变的，因此它们的方法都是线程安全的。有同学或许有疑问，`String` 有 `replace`，`substring` 等方法【可以】改变值啊，其实调用这些方法返回的已经是一个新创建的对象了！

```java
public class Immutable{
    private int value = 0;
    public Immutable(int value){
        this.value = value;
    }
    public int getValue(){
        return this.value;
    }
    public Immutable add(int v){
        return new Immutable(this.value + v);
    }
}
```

### 3.3.3 示例分析

分析线程是否安全，先对类的成员变量，类变量，局部变量进行考虑，如果变量会在各个线程之间共享，那么就得考虑线程安全问题了，如果变量A引用的是线程安全类的实例，并且只调用该线程安全类的一个方法，那么该变量A是线程安全的的。

示例一：

```java
// Servlet运行在Tomcat中，只有一个运行实例，会被多个线程使用，因此存在共享问题。接下来我们具体分析一下：
public class MyServlet extends HttpServlet {
    // 是否安全？ 否，线程安全的是Hashtable，HashMap不是线程安全的。
    Map<String,Object> map = new HashMap<>();
    // 是否安全？ 是，字符串不可变，线程安全的。
    String S1 = "...";
    // 是否安全？ 是，final字符串，线程安全。
    final String S2 = "...";
    // 是否安全？ 否，日期类Date不是线程安全的，该方法被多个线程共享。
    Date D1 = new Date();
    // 是否安全？ 否，日期类可变，里面有属性可以被修改，不是线程安全的。
    final Date D2 = new Date();

    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        // 使用上述变量
    }
}
```

实例二：

```java
public class MyServlet extends HttpServlet {
    // 是否安全？ 否，不是线程安全的，servelt只有一份实例对象，userService是成员变量，所以也是只有一份。所以会存在多线程共享使用，所以会出现线程安全问题。
    private UserService userService = new UserServiceImpl();

    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        userService.update(...);
    }
}
public class UserServiceImpl implements UserService {
    // 记录调用次数
    private int count = 0;

    public void update() {
        // ...
        count++;
    }
}
```

实例三：

此类不是线程安全的，`MyAspect`切面类只有一个实例，成员变量`start` 会被多个线程同时进行读写操作

```java
@Aspect
@Component
public class MyAspect {
    // 是否安全？ 否，该类是单例的，所以成员变量也是单例的，所以会被多个线程进行操作。
    private long start = 0L;

    @Before("execution(* *(..))")
    public void before() {
        start = System.nanoTime();
    }

    @After("execution(* *(..))")
    public void after() {
        long end = System.nanoTime();
        System.out.println("cost time:" + (end-start));
    }
}
```

示例四：

此例是典型的三层模型调用，`MyServlet` `UserServiceImpl` `UserDaoImpl`类都只有一个实例。我们从下向上一层一层的看：

* `UserDaoImpl`类中没有成员变量，因此不存在被修改操作，不会被修改属性（也就是状态），因此即使多线程也不会存在线程安全问题。而对于Connection它是属于方法内的局部变量，每次线程访问都会独自创建一个对象，所以不会存在线程安全问题。
* `UserServiceImpl`类中只有一个线程安全的`UserDaoImpl`类的实例，虽然该实例是成员变量，但是它里面没有什么可以被修改的，所以是线程安全的。
* 同理 `MyServlet`也是线程安全的。

```java
public class MyServlet extends HttpServlet {
    // 是否安全
    private UserService userService = new UserServiceImpl();

    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        userService.update(...);
    }
}
public class UserServiceImpl implements UserService {
    // 是否安全
    private UserDao userDao = new UserDaoImpl();
    public void update() {
        userDao.update();
    }
}
public class UserDaoImpl implements UserDao {
    public void update() {
        String sql = "update user set password = ? where username = ?";
        // 是否安全
        try (Connection conn = DriverManager.getConnection("","","")){
            // ...
        } catch (Exception e) {
            // ...
        }
    }
}
```

实例五：

跟示例四大体相似，`UserDaoImpl`类中有成员变量，那么多个线程可以对成员变量`conn` 同时进行操作，故是不安全的。三个都是线程不安全。

```java
public class MyServlet extends HttpServlet {
    // 是否安全
    private UserService userService = new UserServiceImpl();

    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        userService.update(...);
    }
}
public class UserServiceImpl implements UserService {
    // 是否安全
    private UserDao userDao = new UserDaoImpl();
    public void update() {
        userDao.update();
    }
}
public class UserDaoImpl implements UserDao {
    // 是否安全
    private Connection conn = null;
    public void update() throws SQLException {
        String sql = "update user set password = ? where username = ?";
        conn = DriverManager.getConnection("","","");
        // ...
        conn.close();
    }
}
```

示例六：

跟示例五大体相似，`UserServiceImpl`类的update方法中 UserDao是作为局部变量存在的，所以每个线程访问的时候都会新建有一个`UserDao`对象，新建的对象是线程独有的，所以是线程安全的。

就这个例子而言，可以这么写，但是不推荐，这样有隐患。

```java
public class MyServlet extends HttpServlet {
    // 是否安全
    private UserService userService = new UserServiceImpl();
    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        userService.update(...);
    }
}
public class UserServiceImpl implements UserService {
    // 是否安全 是，线程安全。
    public void update() {
        UserDao userDao = new UserDaoImpl();
        userDao.update();
    }
}
public class UserDaoImpl implements UserDao {
    // 是否安全
    private Connection = null;
    public void update() throws SQLException {
        String sql = "update user set password = ? where username = ?";
        conn = DriverManager.getConnection("","","");
        // ...
        conn.close();
    }
}
```

示例七：

```java
public abstract class Test {
    public void bar() {
        // 是否安全 否，虽然是局部变量，但是暴露给了foo方法，就有可能暴露给其他线程。
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        foo(sdf);
    }
    public abstract foo(SimpleDateFormat sdf);
    public static void main(String[] args) {
        new Test().bar();
    }
}
```

其中 foo 的行为是不确定的，可能导致不安全的发生，被称之为**外星方法**，因为foo方法可以被重写，导致线程不安全。在String类中就考虑到了这一点，String类是`finally`的，子类不能重写它的方法。

```java
public void foo(SimpleDateFormat sdf) {
    String dateStr = "1999-10-11 00:00:00";
    for (int i = 0; i < 20; i++) {
        new Thread(() -> {
            try {
                sdf.parse(dateStr);
            } catch (ParseException e) {
                e.printStackTrace();
            }
        }).start();
    }
}
```

## 3.4 练习

### 3.4.1 卖票练习

```java
/*
 * 买票窗口
 */
class TicketWindow {
    private int count;

    public TicketWindow(int count) {
        this.count = count;
    }

    public int getCount() {
        return count;
    }

    public int sell(int amount) {
        if (this.count >= amount) {
            this.count -= amount;
            return amount;
        } else {
            return 0;
        }
    }
}
```

```java
@Slf4j
public class ExerciseSell {
    public static void main(String[] args) {
        TicketWindow ticketWindow = new TicketWindow(2000);
        List<Thread> list = new ArrayList<>();
        // 用来存储买出去多少张票
        List<Integer> sellCount = new Vector<>();
        for (int i = 0; i < 2000; i++) {
            Thread t = new Thread(() -> {
                // 分析这里的竞态条件 这里是临界区
                int count = ticketWindow.sell(randomAmount());
                // 这里是add方法，对变量进行修改，但是因为是Vector，它是线程安全的，所以不用考虑。
                sellCount.add(count);
            });
            list.add(t);
            t.start();
        }
        list.forEach((t) -> {
            try {
                t.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        // 买出去的票求和
        log.debug("selled count:{}", sellCount.stream().mapToInt(c -> c).sum());
        // 剩余票数
        log.debug("remainder count:{}", ticketWindow.getCount());
    }

    // Random 为线程安全
    static Random random = new Random();

    // 随机 1~5
    public static int randomAmount() {
        return random.nextInt(5) + 1;
    }
}
```

通过cmd命令窗口（必须cmd，powershell和其他不行）执行如下指令：

```sh
D:\Java\vscode-java\JUC\target\classes>for /L %n in (1, 1, 10) do java -cp ".;E:\Maven\apache-maven-3.6.0\mvn_repository\ch\qos\logback\logback-classic\1.2.3\logback-classic-1.2.3.jar;E:\Maven\apache-maven-3.6.0\mvn_repository\ch\qos\logback\logback-core\1.2.3\logback-core-1.2.3.jar;E:\Maven\apache-maven-3.6.0\mvn_repository\org\slf4j\slf4j-api\1.7.25\slf4j-api-1.7.25.jar" com.linxuan.demo01.ExerciseSell
```

* `for /L %n in (1, 1, 10) do java -cp` ：十次运行该程序
* `E:\Maven\apache-maven-3.6.0\mvn_repository\ch\qos\logback\logback-classic\1.2.3\logback-classic-1.2.3.jar`：slf4j依赖jar包，该程序需要依赖一些jar包。
* `com.linxuan.demo01.ExerciseSell`：字节码程序

通过运行程序可以发现有的数据不正确

```java
D:\Java\vscode-java\JUC\target\classes>java -cp ".;E:\Maven\apache-maven-3.6.0\mvn_repository\ch\qos\logback\logback-classic\1.2.3\logback-classic-1.2.3.jar;E:\Maven\apache-maven-3.6.0\mvn_repository\ch\qos\logback\logback-core\1.2.3\logback-core-1.2.3.jar;E:\Maven\apache-maven-3.6.0\mvn_repository\org\slf4j\slf4j-api\1.7.25\slf4j-api-1.7.25.jar" com.linxuan.demo01.ExerciseSell
18:53:31.347 [main] DEBUG com.linxuan.demo01.ExerciseSell - selled count:2003
18:53:31.356 [main] DEBUG com.linxuan.demo01.ExerciseSell - remainder count:0
```

线程不安全。

### 3.4.2 转账练习

测试下面代码是否存在线程安全问题，并尝试改正

```java
class Account {
    private int money;

    public Account(int money) {
        this.money = money;
    }

    public int getMoney() {
        return money;
    }

    public void setMoney(int money) {
        this.money = money;
    }

    public void transfer(Account target, int amount) {
        if (this.money > amount) {
            this.setMoney(this.getMoney() - amount);
            target.setMoney(target.getMoney() + amount);
        }
    }
}
```

```java
@Slf4j
public class ExerciseTransfer {
    public static void main(String[] args) throws InterruptedException {
        Account a = new Account(1000);
        Account b = new Account(1000);
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                a.transfer(b, randomAmount());
            }
        }, "t1");
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                b.transfer(a, randomAmount());
            }
        }, "t2");
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        // 查看转账2000次后的总金额
        log.debug("total:{}", (a.getMoney() + b.getMoney()));
    }

    // Random 为线程安全
    static Random random = new Random();

    // 随机 1~100
    public static int randomAmount() {
        return random.nextInt(100) + 1;
    }
}
```

上面是存在线程安全的：

```java
PS D:\Java\vscode-java\JUC>  & 'E:\JAVA\jdk1.8.0_144\bin\java.exe' '-cp' 'C:\Users\林轩\AppData\Local\Temp\cp_c3wr1lug2z26l3uv7l9vaj7yg.jar' 'com.linxuan.demo01.ExerciseTransfer'
19:10:55.822 [main] DEBUG com.linxuan.demo01.ExerciseTransfer - total:15404
```

如果根据下面的这种方式修改肯定是不可以的，因为`synchronized`关键字在普通方法上等于给`this`加上锁。这段临界区的代码有两个地方存在线程安全问题`this.setMoney`和`target.setMoney`，肯定是不能给this加锁，这样没有任何作用。

```java
public synchronized void transfer(Account target, int amount) {
    if (this.money > amount) {
        this.setMoney(this.getMoney() - amount);
        target.setMoney(target.getMoney() + amount);
    }
}
```

所以我们要给Class对象加锁

```java
public void transfer(Account target, int amount) {
    synchronized(Account.class) {
        if (this.money > amount) {
            this.setMoney(this.getMoney() - amount);
            target.setMoney(target.getMoney() + amount);
        }
    }
}
```
