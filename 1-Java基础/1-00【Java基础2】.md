# 第一章 常见的关键字

## 1.1 Static

关于 `static` 关键字的使用，它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属
于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。

被`static`修饰的成员可以并且建议通过类名直接访问。虽然也可以通过对象名访问静态成员，原因即多个对象均属 于一个类，共享使用同一个静态成员，但是不建议，会出现警告信息。

static 修饰的内容：

- 是随着类的加载而加载的，且只加载一次。
- 存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。
- 它优先于对象存在，所以，可以被所有对象共享。

![](D:\Java\笔记\图片\1-00【Java基础】\9静态原理.png)

### 1.1.1 类变量

类变量：使用 static关键字修饰的成员变量。定义格式为：`static 数据类型 变量名;`

当 `static` 修饰成员变量时，该变量称为类变量。该类的每个对象都共享同一个类变量的值。任何对象都可以更改 该类变量的值，但也可以在不创建该类的对象的情况下对类变量进行操作。

### 1.1.2 静态方法

类方法：使用 static关键字修饰的成员方法，习惯称为静态方法。

当 `static` 修饰成员方法时，该方法称为类方法 。静态方法在声明中有 `static` ，建议使用类名来调用，而不需要创建类的对象。调用方式非常简单。

```java
修饰符 static 返回值类型 方法名 (参数列表){
    // 执行语句
}
```

静态方法调用的注意事项：

- 静态方法可以直接访问类变量和静态方法。
- 静态方法不能直接访问普通成员变量或成员方法。反之，成员方法可以直接访问类变量或静态方法。
- 静态方法中，不能使用this关键字。

> 静态方法只能访问静态成员。

### 1.1.3 静态代码块

静态代码块：定义在成员位置，使用`static`修饰的代码块`{ }`。

- 位置：类中方法外。
- 执行：随着类的加载而执行且执行一次，优先于main方法和构造方法的执行。

```java
public class ClassName{
    static {
        // 执行语句
    }
}
```

作用：给类变量进行初始化赋值。用法演示，代码如下：

```java
public class Game {
    public static int number;
    public static ArrayList<String> list;
    static {
        // 给类变量赋值
        number = 2;
        list = new ArrayList<String>();
        // 添加元素到集合中
        list.add("张三");
        list.add("李四");
    }
}
```

> static 关键字，可以修饰变量、方法和代码块。在使用的过程中，其主要目的还是想在不创建对象的情况 下，去调用方法。下面将介绍两个工具类，来体现static 方法的便利。

## 1.2 瞬态关键字

transient关键字：瞬态关键字。被transient 修饰的成员变量不能被序列化的，但是它却没有static的作用，只是能够避免序列化

一个对象要想要序列化，必须要满足两个条件：

* 该类必须实现`java.io.Serializable`接口，`Serializable`是一个标记接口，不实现此接口的类将不会使任何状态序列化或者反序列化，会抛出`NotSerializableException`。

* 该类的所有竖向必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用`transient`关键字修饰。

  static关键字：静态关键字。静态关键优先于非静态加载到内存中（静态优先于对象进入到内存中），	被static 修饰的成员变量不能被序列化的，序列化的都是对象。

  transient关键字：瞬态关键字。被transient 修饰的成员变量不能被序列化的，但是它却没有static的作用，只是能够避免序列化

```java
public class Demo01ObjectOutputStream {
    public static void main(String[] args) throws IOException {
        // 1.创建ObjcetOutputStream对象，构造方法中传递字节输出流
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("10_IO\\oos.txt"));
        // 2.使用ObjectOutputStream对象中的方法writeObject，把对象写入到文件中
        oos.writeObject(new Person("小仙女", 19));
        // 3.释放资源
        oos.close();
    }
}
```

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Person implements Serializable {
    private String name;
    private int age;
}
```

## 1.3 abstract

父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了。我们把没有方法主体的方法称为抽象方法。Java语法规定，包含抽象方法的类就是抽象类。

- 抽象方法 ： 没有方法体的方法。

  使用 abstract 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。抽象方法修饰符不能是`private final static`

  ```java
  修饰符 abstract 返回值类型 方法名 (参数列表)；
  ```

- 抽象类：包含抽象方法的类。

  如果一个类包含抽象方法，那么该类必须是抽象类。

  ```java
  abstract class 类名字 {
  }
  ```

继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。

```java
public class Cat extends Animal {
    public void run (){
        System.out.println("小猫在墙头走~~~")；
    }
}
public class CatTest {
    public static void main(String[] args) {
        // 创建子类对象
        Cat c = new Cat();
        // 调用run方法
        c.run();
    }
}
输出结果：
    小猫在墙头走~~~
```

此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做实现方法。

抽象类的特点：

1. 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。
2. 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。抽象类的构造方法不能定义成私有（子类构造方法会调用父类构造方法）
3. 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
4. 抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。
5. 抽象类不能使用final修饰，final修饰的类不能被继承

## 1.4 interface

接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是封装了方法，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法（JDK 9）。

接口的定义，它与定义类方式相似，但是使用 `interface` 关键字。它也会被编译成`.class`文件，但一定要明确它并不是类，而是另外一种引用数据类型。

> 引用数据类型：数组，类，接口。

接口的使用，它不能创建对象，但是可以被实现（ `implements` ，类似于被继承）。一个实现接口的类（可以看做是接口的子类），需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象类。

```java
public interface 接口名称 {
    // 抽象方法
    // 默认方法
    // 静态方法
    // 私有方法
}
```

* **抽象方法**
  使用 `abstract` 关键字修饰，可以省略，没有方法体。该方法供子类实现使用。

  ```java
  public interface InterFaceName {
      public abstract void method();
  }
  ```

* **默认方法**
  使用 `default` 修饰，不可省略，供子类调用或者子类重写。

  ```java
  public interface InterFaceName {
      public default void method() {
          // 执行语句
      }
  }
  ```

* **静态方法**
  使用 `static` 修饰，供接口直接调用。

  ```java
  public interface InterFaceName {
      public static void method2() {
          // 执行语句
      }
  }
  ```

* **私有方法**
  使用 `private` 修饰，供接口中的默认方法或者静态方法调用。

  ```java
  public interface InterFaceName {
      private void method() {
          // 执行语句
      }
  }
  ```

### 1.4.1 基本的实现

类与接口的关系为实现关系，即类实现接口，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 `implements` 关键字。

非抽象子类实现接口：
1. 必须重写接口中所有抽象方法。
2. 继承了接口的默认方法，即可以直接调用，也可以重写。

```java
class 类名 implements 接口名 {
    // 重写接口中抽象方法【必须】
    // 重写接口中默认方法【可选】
}
```

**抽象方法使用**

必须全部实现，代码如下：

```java
public interface LiveAble {
    // 定义抽象方法
    public abstract void eat();
    public abstract void sleep();
}
```

```java
public class Animal implements LiveAble {
    @Override
    public void eat() {
        System.out.println("吃东西");
    }
    @Override
    public void sleep() {
        System.out.println("晚上睡");
    }
}
```

**默认方法的使用**

可以继承，可以重写，二选一，但是只能通过实现类的对象来调用。

1. 继承默认方法，代码如下：

   ```java
   public interface LiveAble {
       public default void fly(){
           System.out.println("天上飞");
       }
   }
   ```

   ```java
   public class Animal implements LiveAble {
       // 继承，什么都不用写，直接调用
   }
   ```

2. 重写默认方法，代码如下：

   ```java
   public interface LiveAble {
       public default void fly(){
           System.out.println("天上飞");
       }
   }
   ```

   ```java
   public class Animal implements LiveAble {
       @Override
       public void fly() {
           System.out.println("自由自在的飞");
       }
   }
   ```

**静态方法的使用**

静态与`.class` 文件相关，只能使用接口名调用，不可以通过实现类的类名或者实现类的对象调用，代码如下：

```java
public interface LiveAble {
    public static void run(){
        System.out.println("跑起来~~~");
    }
}
```

```java
public class Animal implements LiveAble {
    // 无法重写静态方法
}
```

```java
public class InterfaceDemo {
    public static void main(String[] args) {
        // Animal.run(); // 【错误】无法继承方法,也无法调用
        LiveAble.run(); //
    }
}
```

**私有方法的使用**

- 私有方法：只有默认方法可以调用。
- 私有静态方法：默认方法和静态方法可以调用。

如果一个接口中有多个默认方法，并且方法中有重复的内容，那么可以抽取出来，封装到私有方法中，供默认方法去调用。从设计的角度讲，私有的方法是对默认方法和静态方法的辅助。

```java
public interface LiveAble {
    default void func(){
        func1();
        func2();
    }
    private void func1(){
        System.out.println("跑起来~~~");
    }
    private void func2(){
        System.out.println("跑起来~~~");
    }
}
```

### 1.4.2 接口的多实现

之前学过，在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的多实现。并且，一个类能继承一个父类，同时实现多个接口。

```java
class 类名 [extends 父类名] implements 接口名1,接口名2,接口名3... {
    // 重写接口中抽象方法【必须】
    // 重写接口中默认方法【不重名时可选】
}
```

**抽象方法**

接口中，有多个抽象方法时，实现类必须重写所有抽象方法。如果抽象方法有重名的，只需要重写一次。代码如下：

```java
interface A {
    public abstract void showA();
    public abstract void show();
}
interface B {
    public abstract void showB();
    public abstract void show();
}

```

```java
public class C implements A,B{
    @Override
    public void showA() {
        System.out.println("showA");
    }
    @Override
    public void showB() {
        System.out.println("showB");
    }
    @Override
    public void show() {
        System.out.println("show");
    }
}
```

**默认方法**

接口中，有多个默认方法时，实现类都可继承使用。如果默认方法有重名的，必须重写一次。代码如下：

```java
interface A {
    public default void methodA(){}
    public default void method(){}
}
interface B {
    public default void methodB(){}
    public default void method(){}
}
```

```java
public class C implements A,B{
    @Override
    public void method() {
        System.out.println("method");
    }
}
```

**静态方法**

接口中，存在同名的静态方法并不会冲突，原因是只能通过各自接口名访问静态方法。

### 1.4.3 接口多实现优先级

当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。代码如下：

```java
interface A {
    public default void methodA(){
        System.out.println("AAAAAAAAAAAA");
    }
}
```

```java
class D {
    public void methodA(){
        System.out.println("DDDDDDDDDDDD");
    }
}
```

```java
class C extends D implements A {
    // 未重写methodA方法
}
```

```java
public class Test {
    public static void main(String[] args) {
        C c = new C();
        c.methodA();
    }
}
```

### 1.4.4 接口多继承

一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。接口的继承使用 `extends` 关键字，子接口继承父接口的方法。如果父接口中的默认方法有重名的，那么子接口需要重写一次。代码如下：

```java
interface A {
    public default void method(){
        System.out.println("AAAAAAAAAAAAAAAAAAA");
    }
}
interface B {
    public default void method(){
        System.out.println("BBBBBBBBBBBBBBBBBBB");
    }
}
```

```java
interface D extends A,B{
    @Override
    public default void method() {
        System.out.println("DDDDDDDDDDDDDD");
    }
}
```

- 子接口重写默认方法时，default关键字可以保留。
- 子类重写默认方法时，default关键字不可以保留。

### 1.4.5 接口特点

- 接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用public static final修饰。
- 接口中，没有构造方法，不能创建对象。
- 接口中，没有静态代码块。
- 接口中没有构造器，不能被实例化
- 接口只能继承接口，不能继承类，接口支持多继承
- 接口中的定义的成员变量，默认是`public static final`修饰的静态常量
- 接口中定义的方法，默认是`public abstract`修饰的抽象方法
- 接口中定义的内部类，默认是`public static`修饰的静态内部类

### 1.4.6 抽象类和接口的区别

相同点：

1. 抽象类和接口都不能被实例化
2. 抽象类和接口都可以定义抽象方法，子类/实现类必须覆写这些抽象方法

不同点：

1. 抽象类有构造方法，接口没有构造方法
2. 抽象类可以包含普通方法，接口中只能是`public abstract`修饰抽象方法（Java8之后可以）
3. 抽象类只能单继承，接口可以多继承
4. 抽象类可以定义各种类型的成员变量，接口中只能是`public static final`修饰的静态常量

## 1.5 final

子类可以在父类的基础上改写父类内容，比如，方法重写。那么我们能不能随意的继承API中提供的类，改写其内容呢？显然这是不合适的。为了避免这种随意改写的情况，Java提供了 `final` 关键字，用于修饰不可改变内容。

final： 不可改变。可以用于修饰类、方法和变量。

- 类：被修饰的类，不能被继承。
- 方法：被修饰的方法，不能被重写。
- 变量：被修饰的变量，不能被重新赋值。

### 1.5.1 修饰类

```java
final class 类名 {
}
```

查询API发现像 `public final class String` 、 `public final class Math` 、 `public final class Scanner`等，很多我们学习过的类，都是被final修饰的，目的就是供我们使用，而不让我们所以改变其内容。

### 1.5.2 修饰方法

```java
修饰符 final 返回值类型 方法名(参数列表){
    //方法体
}
```

重写被 `final` 修饰的方法，编译时就会报错。

### 1.5.3 修饰变量

* **局部变脸——基本类型**
  基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改。代码如下：

  ```java
  public class FinalDemo1 {
      public static void main(String[] args) {
          // 声明变量，使用final修饰
          final int a;
          // 第一次赋值
          a = 10;
          // 第二次赋值
          a = 20; // 报错,不可重新赋值
          // 声明变量，直接赋值，使用final修饰
          final int b = 10;
          // 第二次赋值
          b = 20; // 报错,不可重新赋值
      }
  }
  ```

  看一下下面两个代码：
  
  ```java
  // 代码1
  final int c = 0;
  for (int i = 0; i < 10; i++) {
      c = i;
      System.out.println(c);
  }
  ```
  
  ```java
  // 代码2
  for (int i = 0; i < 10; i++) {
      final int c = i;
      System.out.println(c);
  }
  ```
  
  根据 `final` 的定义，代码1报错！代码2没有问题，为什么通过编译呢？因为每次循环，都是一次新的变量c。这也是大家需要注意的地方。
  
* **局部变量——引用类型**
  引用类型的局部变量，被final修饰后，只能指向一个对象，地址不能再更改。但是不影响对象内部的成员变量值的修改，代码如下：

  ```java
  public class FinalDemo2 {
      public static void main(String[] args) {
          // 创建 User 对象
          final User u = new User();
          // 创建 另一个 User对象
          u = new User(); // 报错，指向了新的对象，地址值改变。
          // 调用setName方法
          u.setName("张三"); // 可以修改
      }
  }
  ```

* **成员变量**
  成员变量涉及到初始化的问题，初始化方式有两种，只能二选一：

  ```java
  // 显示初始化
  public class User {
      final String USERNAME = "张三";
      private int age;
  }
  ```

  ```java
  // 构造方法初始化
  public class User {
      final String USERNAME ;
      private int age;
      public User(String username, int age) {
          this.USERNAME = username;
          this.age = age;
      }
  }
  ```

> 被final修饰的常量名称，一般都有书写规范，所有字母都大写。

## 1.6 权限修饰符

在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限，

- public：公共的。
- protected：受保护的
- default：默认的
- private：私有的

|                        | public | protected | default（空的） | private |
| ---------------------- | ------ | --------- | --------------- | ------- |
| 同一类中               | √      | √         | √               | √       |
| 同一包中(子类与无关类) | √      | √         | √               |         |
| 不同包的子类           | √      | √         |                 |         |
| 不同包中的无关类       | √      |           |                 |         |

可见，public具有最大权限。private则是最小权限。

编写代码时，如果没有特殊的考虑，建议这样使用权限：

- 成员变量使用 private ，隐藏细节。
- 构造方法使用 public ，方便创建对象。
- 成员方法使用 public ，方便调用方法。

> 不加权限修饰符，其访问能力与default修饰符相同

# 第二章 内部类

将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类。

## 2.1 成员内部类

成员内部类 ：定义在类中方法外的类。

```java
class 外部类 {
    class 内部类{
    }
}
```

在描述事物时，若一个事物内部还包含其他事物，就可以使用内部类这种结构。比如，汽车类 Car 中包含发动机类 Engine ，这时， Engine 就可以使用内部类来描述，定义在成员位置。

```java
class Car { //外部类
    class Engine { //内部类
    }
}
```

特点如下：

- 内部类可以直接访问外部类的成员，包括私有成员。
- 外部类要访问内部类的成员，必须要建立内部类的对象。

创建内部类格式：`外部类名.内部类名 对象名 = new 外部类型().new 内部类型()；`

```java
public class Person {
    private boolean live = true;
    class Heart {
        public void jump() {
            // 直接访问外部类成员
            if (live) {
                System.out.println("心脏在跳动");
            } else {
                System.out.println("心脏不跳了");
            }
        }
    }
    public boolean isLive() {
        return live;
    }
    public void setLive(boolean live) {
        this.live = live;
    }
}
```

```java
public class InnerDemo {
    public static void main(String[] args) {
        // 创建外部类对象
        Person p = new Person();
        // 创建内部类对象
        Heart heart = p.new Heart();
        // 调用内部类方法
        heart.jump();
        // 调用外部类方法
        p.setLive(false);
        // 调用内部类方法
        heart.jump();
    }
}
输出结果:
	心脏在跳动
    心脏不跳了
```

> 内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名 和$符号 。 比如，Person$Heart.class

## 2.2 匿名内部类

匿名内部类 ：是内部类的简化写法。它的本质是一个带具体实现的父类或者父接口的匿名的子类对象。

开发中，最常用到的内部类就是匿名内部类了。以接口举例，当你使用一个接口时，似乎得做如下几步操作，

1. 定义子类
2. 重写接口中的方法
3. 创建子类对象
4. 调用重写后的方法

我们的目的，最终只是为了调用方法，那么能不能简化一下，把以上四步合成一步呢？匿名内部类就是做这样的快捷方式。

匿名内部类必须继承一个父类或者实现一个父接口。

```java
new 父类名或者接口名(){
    // 方法重写
    @Override
    public void method() {
        // 执行语句
    }
};
```

使用方法如下：

```java
public abstract class FlyAble{
    public abstract void fly();
}
```

```java
public class InnerDemo {
    public static void main(String[] args) {
        /*
        1.等号右边:是匿名内部类，定义并创建该接口的子类对象
        2.等号左边:是多态赋值,接口类型引用指向子类对象
        */
        FlyAble f = new FlyAble(){
            public void fly() {
                System.out.println("我飞了~~~");
            }
        };
        //调用 fly方法,执行重写后的方法
        f.fly();
    }
}

```

通常在方法的形式参数是接口或者抽象类时，也可以将匿名内部类作为参数传递。代码如下：

```java
public class InnerDemo2 {
    public static void main(String[] args) {
        /*
        1.等号右边:定义并创建该接口的子类对象
        2.等号左边:是多态,接口类型引用指向子类对象
        */
        FlyAble f = new FlyAble(){
            public void fly() {
                System.out.println("我飞了~~~");
            }
        };
        // 将f传递给showFly方法中
        showFly(f);
    }
    public static void showFly(FlyAble f) {
        f.fly();
    }
}
```

以上两步，也可以简化为一步，代码如下：

```java
public class InnerDemo3 {
    public static void main(String[] args) {
        /*
        创建匿名内部类,直接传递给showFly(FlyAble f)
        */
        showFly( new FlyAble(){
            public void fly() {
                System.out.println("我飞了~~~");
            }
        });
    }
    public static void showFly(FlyAble f) {
        f.fly();
    }
}
```

# 第三章 引用类型用法

实际的开发中，引用类型的使用非常重要，也是非常普遍的。我们可以在理解基本类型的使用方式基础上，进一步
去掌握引用类型的使用方式。基本类型可以作为成员变量、作为方法的参数、作为方法的返回值，那么当然引用类
型也是可以的。

## 3.1 类作为成员变量

在定义一个类Role（游戏角色）时，代码如下：

```java
class Role {
    int id; // 角色id
    int blood; // 生命值
    String name; // 角色名称
}
```

使用 int 类型表示 角色id和生命值，使用 String 类型表示姓名。此时， String 本身就是引用类型，由于使用的方式类似常量，所以往往忽略了它是引用类型的存在。如果我们继续丰富这个类的定义，给 Role 增加武器，穿戴装备等属性，我们将如何编写呢？

定义武器类，将增加攻击能力：

```java
class Weapon {
    String name； // 武器名称
    int hurt； // 伤害值
}
```

定义穿戴盔甲类，将增加防御能力，也就是提升生命值：

```java
class Armour {
    String name；// 装备名称
    int protect；// 防御值
}
```

定义角色类：

```java
class Role {
    int id;
    int blood;
    String name;
    // 添加武器属性
    Weapon wp;
    // 添加盔甲属性
    Armour ar;
    // 提供get/set方法
    public Weapon getWp() {
        return wp;
    }
    public void setWeapon(Weapon wp) {
        this.wp = wp;
    }
    public Armour getArmour() {
        return ar;
    }
    public void setArmour(Armour ar) {
        this.ar = ar;
    }
    // 攻击方法
    public void attack(){
        System.out.println("使用"+ wp.getName() +", 造成"+wp.getHurt()+"点伤害");
    }
    // 穿戴盔甲
    public void wear(){
        // 增加防御,就是增加blood值
        this.blood += ar.getProtect();
        System.out.println("穿上"+ar.getName()+", 生命值增加"+ar.getProtect());
    }
}
```

测试类：

```java
public class Test {
    public static void main(String[] args) {
        // 创建Weapon 对象
        Weapon wp = new Weapon("屠龙刀" , 999999);
        // 创建Armour 对象
        Armour ar = new Armour("麒麟甲",10000);
        // 创建Role 对象
        Role r = new Role();
        // 设置武器属性
        r.setWeapon(wp);
        // 设置盔甲属性
        r.setArmour(ar);
        // 攻击
        r.attack();
        // 穿戴盔甲
        r.wear();
    }
}
输出结果:
	使用屠龙刀,造成999999点伤害
    穿上麒麟甲 ,生命值增加10000
```

> 类作为成员变量时，对它进行赋值的操作，实际上，是赋给它该类的一个对象。

## 3.2 接口作为成员变量

接口是对方法的封装，对应游戏当中，可以看作是扩展游戏角色的技能。所以，如果想扩展更强大技能，我们在Role 中，可以增加接口作为成员变量，来设置不同的技能。

```java
// 法术攻击
public interface FaShuSkill {
    public abstract void faShuAttack();
}
```

```java
public class Role {
    FaShuSkill fs;
    public void setFaShuSkill(FaShuSkill fs) {
        this.fs = fs;
    }
    // 法术攻击
    public void faShuSkillAttack(){
        System.out.print("发动法术攻击:");
        fs.faShuAttack();
        System.out.println("攻击完毕");
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        // 创建游戏角色
        Role role = new Role();
        // 设置角色法术技能
        role.setFaShuSkill(new FaShuSkill() {
            @Override
            public void faShuAttack() {
                System.out.println("纵横天下");
            }
        });
        // 发动法术攻击
        role.faShuSkillAttack();
        // 更换技能
        role.setFaShuSkill(new FaShuSkill() {
            @Override
            public void faShuAttack() {
                System.out.println("逆转乾坤");
            }
        });
        // 发动法术攻击
        role.faShuSkillAttack();
    }
}
输出结果:
	发动法术攻击:纵横天下
    攻击完毕
    发动法术攻击:逆转乾坤
    攻击完毕
```

> 我们使用一个接口，作为成员变量，以便随时更换技能，这样的设计更为灵活，增强了程序的扩展性。 接口作为成员变量时，对它进行赋值的操作，实际上，是赋给它该接口的一个子类对象。

## 3.3 接口作为方法参数和返回值

当接口作为方法的参数时,需要传递什么呢？当接口作为方法的返回值类型时，需要返回什么呢？对，其实都是它的子类对象。 ArrayList 类我们并不陌生，查看API我们发现，实际上，它是 java.util.List 接口的实现类。所以，当我们看见 List 接口作为参数或者返回值类型时，当然可以将 ArrayList 的对象进行传递或返回。

请观察如下方法：获取某集合中所有的偶数。

```java
public static List<Integer> getEvenNum(List<Integer> list) {
    // 创建保存偶数的集合
    ArrayList<Integer> evenList = new ArrayList<>();
    // 遍历集合list,判断元素为偶数,就添加到evenList中
    for (int i = 0; i < list.size(); i++) {
        Integer integer = list.get(i);
        if (integer % 2 == 0) {
            evenList.add(integer);
        }
    }
    /*
        返回偶数集合
        因为getEvenNum方法的返回值类型是List,而ArrayList是List的子类,
        所以evenList可以返回
    */
    return evenList;
}
```

```java
public class Test {
    public static void main(String[] args) {
        // 创建ArrayList集合,并添加数字
        ArrayList<Integer> srcList = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            srcList.add(i);
        }
        /*
            获取偶数集合
            因为getEvenNum方法的参数是List,而ArrayList是List的子类,
            所以srcList可以传递
        */
        List list = getEvenNum(srcList);
        System.out.println(list);
    }
}
```

> 接口作为参数时，传递它的子类对象。 接口作为返回值类型时，返回它的子类对象。

# 第四章 包装类

**为了让基本类型也具有对象的特征，就出现了包装类型**

Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：

| 基本类型和所占用字节数 | 对应的包装类（位于java.lang包中） |
| :--------------------: | :-------------------------------: |
|     byte【1字节】      |               Byte                |
|     short【2字节】     |               Short               |
|      int【4字节】      |              Integer              |
|     long【8字节】      |               Long                |
|     float【4字节】     |               Float               |
|    double【8字节】     |              Double               |
|     char【2字节】      |             Character             |
|    boolean【1字节】    |              Boolean              |

## 4.1 装箱与拆箱

基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：

* **装箱**：从基本类型转换为对应的包装类对象。

* **拆箱**：从包装类对象转换为对应的基本类型。

用Integer与 int为例：

* 基本数值---->包装对象

  ```java
  Integer i = new Integer(4); // 使用构造函数函数
  Integer iii = Integer.valueOf(4); // 使用包装类中的valueOf方法
  ```

* 包装对象---->基本数值

  ```java
  int num = i.intValue();
  ```

## 4.2 自动装箱与自动拆箱

由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：

```java
Integer i = 4; // 自动装箱。相当于Integer i = Integer.valueOf(4);
i = i + 5; // 等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;
// 加法运算完成后，再次装箱，把基本数值转成对象。
```

看一下下面的题目：

```java
public class Main {
    public static void main(String[] args) {
         
        Integer i1 = 100;
        Integer i2 = 100;
        Integer i3 = 200;
        Integer i4 = 200;
         
        System.out.println(i1==i2);    //true
        System.out.println(i3==i4);    //false
    }
}
```

为什么会这样呢？看下`Integer`的`valueOf`方法的具体实现：

```java
public static Integer valueOf(int i) {
    final int offset = 128;
    if (i >= -128 && i <= 127) { // must cache 
        return IntegerCache.cache[i + offset];
    }
    return new Integer(i);
}
```

而其中`IntegerCache`类的实现为：

```java
// 省略了很多
private static class IntegerCache {
    private IntegerCache(){}
    static final Integer cache[] = new Integer[127 - (-128) + 1];

    static {
        for(int i = 0; i < cache.length; i++)
            cache[i] = new Integer(i - 128);
    }
}
```

由上可知，Integer包装类型如果数值在[-128,127]之间，便返回指向`IntegerCache.cache`中已经存在的对象的引用；否则创建一个新的Integer对象。

Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的，而Double、Float的valueOf方法的实现就和他们不一样了，这是因为他们都是浮点数，根部无法确定值。

对于Boolean类型比较一下就一目了然：

```java
public class Main {
    public static void main(String[] args) {

        Boolean i1 = false;
        Boolean i2 = false;
        Boolean i3 = true;
        Boolean i4 = true;

        System.out.println(i1==i2);    //true
        System.out.println(i3==i4);    //true
    }
}
```

源码：

```java
public static Boolean valueOf(boolean b) {
    return (b ? TRUE : FALSE);
}

public static final Boolean TRUE = new Boolean(true);
public static final Boolean FALSE = new Boolean(false);
```

另外还有一点需要注意：当 "=="运算符的两个操作数都是包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程），对基础数据类型进行运算。对于包装器类型，equals方法并不会进行类型转换。

```java
public class Main {
    public static void main(String[] args) {
         
        Integer a = 1;
        Integer b = 2;
        Integer c = 3;
        Integer d = 3;
        Integer e = 321;
        Integer f = 321;
        Long g = 3L;
        Long h = 2L;
         
        System.out.println(c==d);            //true
        System.out.println(e==f);            //false
        System.out.println(c==(a+b));        //true
        System.out.println(c.equals(a+b));   //true
        System.out.println(g==(a+b));        //true
        System.out.println(g.equals(a+b));   //false
        System.out.println(g.equals(a+h));   //true
    }
}
```

equals()方法源码

```java
//Integer类中
public boolean equals(Object obj) {
	if (obj instanceof Integer) {
	    return value == ((Integer)obj).intValue();
	}
	return false;
}
 
//Long类中
public boolean equals(Object obj) {
    if (obj instanceof Long) {
	return value == ((Long)obj).longValue();
    }
	return false;
}
```

指定equals比较的是内容本身，并且我们也可以看到equals的参数是一个Object对象，我们传入的是一个int类型，所以首先会进行装箱，然后比较，之所以返回true，是由于它比较的是对象里面的value值。当内容和类型都相同时才会返回true。

## 4.3 基本类型与字符串转换

基本类型转换String总共有三种方式，查看课后资料可以得知，这里只讲最简单的一种方式： 

~~~
基本类型直接与""相连接即可；如：34+""
~~~

String转换成对应的基本类型 

除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：

- `public static byte parseByte(String s)`：将字符串参数转换为对应的byte基本类型。
- `public static short parseShort(String s)`：将字符串参数转换为对应的short基本类型。
- `public static int parseInt(String s)`：将字符串参数转换为对应的int基本类型。
- `public static long parseLong(String s)`：将字符串参数转换为对应的long基本类型。
- `public static float parseFloat(String s)`：将字符串参数转换为对应的float基本类型。
- `public static double parseDouble(String s)`：将字符串参数转换为对应的double基本类型。
- `public static boolean parseBoolean(String s)`：将字符串参数转换为对应的boolean基本类型。

```java
public class Demo18WrapperParse {
    public static void main(String[] args) {
        int num = Integer.parseInt("100");
    }
}
```

> 注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出`java.lang.NumberFormatException`异常。

# 第五章 泛型

集合中可以存放任意对象，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。

~~~java
public class GenericDemo {
	public static void main(String[] args) {
		Collection coll = new ArrayList();
		coll.add("abc");
		coll.add("itcast");
		coll.add(5); // 由于集合没有做任何限定，任何类型都可以给其中存放
		Iterator it = coll.iterator();
		while(it.hasNext()){
			//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型
			String str = (String) it.next();
			System.out.println(str.length());
		}
	}
}
~~~

上述程序在运行时发生了问题**java.lang.ClassCastException**类强制转换异常。这是由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时`ClassCastException`。

```java
Exception in thread "main" java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String
        at com.linxuan.demo01.Demo02.main(Demo02.java:16)
```

Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了**泛型**(**Generic**)语法，在使用API时可以指定类或方法支持泛型，并得到了编译时期的语法检查。

**泛型**：可以在类或方法中预支地使用未知的类型。一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。

泛型的优点如下：

* 将运行时期的`ClassCastException`，转移到了编译时期变成了编译失败。
* 避免了类型强转的麻烦。

~~~java
public class GenericDemo2 {
	public static void main(String[] args) {
        Collection<String> list = new ArrayList<String>();
        list.add("abc");
        list.add("itcast");
        // list.add(5);//当集合明确类型后，存放类型不一致就会编译报错
        // 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型
        Iterator<String> it = list.iterator();
        while(it.hasNext()){
            String str = it.next();
            //当使用Iterator<String>控制元素类型后，就不需要强转了。获取到的元素直接就是String类型
            System.out.println(str.length());
        }
	}
}
~~~

## 5.3  泛型的定义与使用

泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。

定义格式为：`修饰符 class 类名<代表泛型的变量> {  }`

例如，API中的ArrayList集合：

~~~java
class ArrayList<E>{ 
    public boolean add(E e){ }

    public E get(int index){ }
   	....
}
~~~

使用泛型就是什么时候确定泛型，要求**在创建对象的时候确定泛型**。 例如，`ArrayList<String> list = new ArrayList<String>();`

###  含有泛型的方法

定义格式：

~~~
修饰符 <代表泛型的变量> 返回值类型 方法名(参数){  }
~~~

例如，

~~~java
public class MyGenericMethod {	  
    public <MVP> void show(MVP mvp) {
    	System.out.println(mvp.getClass());
    }
    
    public <MVP> MVP show2(MVP mvp) {	
    	return mvp;
    }
}
~~~

使用格式：**调用方法时，确定泛型的类型**

~~~java
public class GenericMethodDemo {
    public static void main(String[] args) {
        // 创建对象
        MyGenericMethod mm = new MyGenericMethod();
        // 演示看方法提示
        mm.show("aaa");
        mm.show(123);
        mm.show(12.45);
    }
}
~~~

### 含有泛型的接口

定义格式：

~~~
修饰符 interface接口名<代表泛型的变量> {  }
~~~

例如，

~~~java
public interface MyGenericInterface<E>{
	public abstract void add(E e);
	
	public abstract E getE();  
}
~~~

使用格式：

**1、定义类时确定泛型的类型**

例如

~~~java
public class MyImp1 implements MyGenericInterface<String> {
	@Override
    public void add(String e) {
        // 省略...
    }

	@Override
	public String getE() {
		return null;
	}
}
~~~

此时，泛型E的值就是String类型。

 **2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型**

 例如

~~~java
public class MyImp2<E> implements MyGenericInterface<E> {
	@Override
	public void add(E e) {
       	 // 省略...
	}

	@Override
	public E getE() {
		return null;
	}
}
~~~

确定泛型：

~~~java
/*
 * 使用
 */
public class GenericInterface {
    public static void main(String[] args) {
        MyImp2<String>  my = new MyImp2<String>();  
        my.add("aa");
    }
}
~~~

## 5.4  泛型通配符

当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符<?>表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。

#### 通配符基本使用

泛型的通配符:**不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。**

此时只能接受数据,不能往该集合中存储数据。

举个例子大家理解使用即可：

~~~java
public static void main(String[] args) {
    Collection<Intger> list1 = new ArrayList<Integer>();
    getElement(list1);
    Collection<String> list2 = new ArrayList<String>();
    getElement(list2);
}
public static void getElement(Collection<?> coll){}
//？代表可以接收任意类型
~~~

> tips:泛型不存在继承关系 Collection<Object> list = new ArrayList<String>();这种是错误的。

#### 通配符高级使用----受限泛型

之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的**上限**和**下限**。

**泛型的上限**：

* **格式**： `类型名称 <? extends 类 > 对象名称`
* **意义**： `只能接收该类型及其子类`

**泛型的下限**：

- **格式**： `类型名称 <? super 类 > 对象名称`
- **意义**： `只能接收该类型及其父类型`

比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类

~~~java
public static void main(String[] args) {
    Collection<Integer> list1 = new ArrayList<Integer>();
    Collection<String> list2 = new ArrayList<String>();
    Collection<Number> list3 = new ArrayList<Number>();
    Collection<Object> list4 = new ArrayList<Object>();
    
    getElement(list1);
    getElement(list2);//报错
    getElement(list3);
    getElement(list4);//报错
  
    getElement2(list1);//报错
    getElement2(list2);//报错
    getElement2(list3);
    getElement2(list4);
  
}
// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类
public static void getElement1(Collection<? extends Number> coll){}
// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类
public static void getElement2(Collection<? super Number> coll){}
~~~

# 

# 

# 

## 7. 泛型(Generic)

```java
List<String> l1 = new ArrayList<String>();
List<Integer> l2 = new ArrayList<Integer>();
		
System.out.println(l1.getClass() == l2.getClass());
```

正确答案是 true。

上面的代码中涉及到了泛型，而输出的结果缘由是**类型擦除**。先好好说说泛型。

泛型的英文是 generics，generic 的意思是通用,而翻译成中文，泛应该意为广泛，型是类型。所以泛型就是能广泛适用的类型。

**但泛型还有一种较为准确的说法就是为了参数化类型，或者说可以将类型当作参数传递给一个类或者是方法。**	

​	泛型，即“**参数化类型**”，一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。参数化类型就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式(可以称之为类型形参)，然后在使用或调用时传入具体的类型(类型实参)。

​		泛型的本质是为了参数化类型(在不创建新的类型情况下，通过泛型指定的不同类型来控制形参具体限制的类型)。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称之为泛型类、泛型接口、泛型方法。

泛型的好处：

* 将运行期间遇到的问题提前到编译期间
* 避免了向下转型
* 优化了程序设计，解决了黄色警告

实例1：

```java
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class GenericDemo01 {
	public static void main(String[] args) {
		List list = new ArrayList();
		list.add("hello");
		list.add("world");
		list.add("java");
		list.add(100);
		
        Iterator<String> iter = list.iterator();
        while(iter.hasNext()){
            String s = iter.next();
            System.out.println(s);
		}
	}
}
```

毫无疑问，程序的运行结果会以崩溃结束：

```java
java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String
	at se01.day05.GenericDemo01.main(GenericDemo01.java:18)
```

ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。

我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。

```java
List<String> list = new ArrayList<String>();
...
//list.add(100); 在编译阶段，编译器就会报错
```

 实例2：

```java
//泛型类
class ObjectDemo<E>{
	private E e;
	public void setE(E e){
		this.e = e;
	}
	public E getE(){
		return e;
	}
}

//不使用泛型
class ObjectDemo02{
	private Object obj;

	public Object getObj() {
		return obj;
	}
	 
	public void setObj(Object obj) {
		this.obj = obj;
	}

}
public class GenericDemo02 {
	public static void main(String[] args) {
		ObjectDemo<String> od = new ObjectDemo<String>();
		od.setE("张伟");
		System.out.println(od.getE());
		

		ObjectDemo<Integer> od2 = new ObjectDemo<Integer>();
		od2.setE(12);
		int i = od2.getE();
		System.out.println(i);
		
		ObjectDemo02 obj = new ObjectDemo02();
		obj.setObj("最低配");

//		Integer inter =  (Integer) obj.getObj();//.ClassCastException
//		System.out.println(inter);
		
	}

}
```

由上可知，在不使用时我们会用到Object作为数据类型，在使用时再根据具体的情况向下转型还可能出现`java.lang.ClassCastException`异常，使用泛型后就避免了这种情况。

### 泛型的使用

#### 泛型类：定义在类上面

格式：`public class 类名<泛型类型1,...>`

* 例如：

  ```java
  //此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
  //在实例化泛型类时，必须指定T的具体类型
  public class Generic<T,R>{     //一个类上可以定义多种泛型声明
      //key这个成员变量的类型为T,T的类型由外部指定  
      private T key;
  
      public Generic(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定
          this.key = key;
      }
       
      public T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定
          return key;
      }
      public R fun(T p){  //R是返回值类型，T为方法参数类型
          teturn null;    
      }
  
  }
  ```

* 测试：

  ```java
  public class GenericTest{
      public static void main(String[] args){
         //泛型的类型参数只能是类类型（包括自定义类），不能是简单类型
         //传入的实参类型需与泛型的类型参数类型相同，即为Integer.
         Generic<Integer,String> genericInteger = new Generic<Integer,String>(123456);
         //传入的实参类型需与泛型的类型参数类型相同，即为String.
         Generic<String,Integer> genericString = new Generic<String,Integer>("key_vlaue");
         System.out.println("泛型测试","key is " + genericInteger.getKey());
         System.out.println("泛型测试","key is " + genericString.getKey());
      }
  }
  ```

* 输出结果：

  ```html
  <!--
      泛型测试: key is 123456
      泛型测试: key is key_vlaue
  -->
  ```

**注意：泛型类的所有实例都具有相同的运行时类，而不管它们的实际类型参数如何。**

* 实例：

  ```java
  List<String> l1 = new ArrayList<String>();
  List<Integer> l2 = new ArrayList<Integer>();
  System.out.println(l1.getClass()== l2.getClass());    //true
  ```

> 注意：
>
> * 定义的泛型类，要么传入所有的泛型类型实参，要么不传入任何泛型类型实参。即:`Generic<Integer,String>...或Generic...`不能是`Generic<Integer>...`
> * 泛型的类型参数只能是类类型，不能是简单类型。
> * 不能对确切的泛型类型使用`instanceof`操作。如下操作是非法的，编译时会报错。`if(ex_num instanceof Generic<Number>){}`

#### 泛型接口：定义在接口上面

格式：`public interface 接口名<泛型类型1,...>`

任何情况下如果要使用接口，就必须定义相应的子类，而对于实现了泛型接口的子类而言，有以下两种实现方式：

1. 在子类继续设置泛型标记
2. 在子类不是设置泛型，而为接口明确定义一个泛型类型

* 示例：

  ```java
  //泛型接口
  interface Inter<T>{
  	void show(T t);
  }
  
  //实现类
  //1)知道实现什么泛型
  class InterImpl implements Inter<String>{
  	@Override
  	public void show(String s) {
  		System.out.println(s);
  	}
  }
  //2)不知道实现什么泛型
  class InterImpl02<T> implements Inter<T>{
  	@Override
  	public void show(T t) {
  		System.out.println(t);
  	}
  }
  
  public class GenericDemo03 {
  	public static void main(String[] args) {
  		//1)
  		InterImpl i = new InterImpl();
  		i.show("hello");           // hello
  		
  
  		//2)
  		InterImpl02<String> i2 = new InterImpl02<String>();
  		i2.show("world");          //world
  		InterImpl02<Integer> i3 = new InterImpl02<Integer>();
  		i3.show(13);               //13
  	}    
  
  }
  ```

> 注意：如果不声明泛型，如：`class InterImpl02 implements Inter<T>`，编译会报错`“Unknown class”`

#### 泛型方法：定义在方法上

格式：`修饰符 <泛型类型> 返回值类型 方法名(参数列表){}`

注意：

1. 泛型方法即在方法上设置泛型类型，参数中可以出现泛型类或类中未定义的泛型标识
2. 在方法上定义泛型时，这个方法不一定要在泛型类中定义
3. 泛型方法中可以出现任意多个泛型标识符
4. 静态的泛型方法需要额外的泛型声明，即使使用了泛型类声明过的泛型类型
5. 静态方法若有返回值其类型不能为泛型

* 示例：

  ```java
  //泛型方法
  class Generic<T>{//这个类是个泛型类，在上面已经介绍过
  	private T key;
  	
  
  	//这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。
  	public T getKey(){
  	    return key;
  	    }
  	/* 因为在类的声明中并未声明泛型K，所以在使用K做形参和返回值类型时，编译器会无法识别。
  	 * K cannot be resolved to a type
  	 * public K setKey(K key){	
  	    this.key = key;
  	}*/
  	//在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型
  	public <T> void show(T t){
  		System.out.println(t);
  	}
  	public <E> T fun(E e){
  		System.out.println(e);
  		return key;
  	}
  	//泛型的数量也可以为任意多个 
  	public <R,V> R showKeyName(R r,V v){
  		return null;
  	} 
  	/*
  	 * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）
  	 * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。
  	 * 如：public static void method(T t){...},此时编译器会提示错误信息：
  	 * Cannot make a static reference to the non-static type T
  	 */
  	public static <E> void method(E t){}
  
  }
  public class GenericTest {
  	public static void main(String[] args) {
  		Generic od = new Generic();
  		od.show("hello");    //hello
  		Generic<Integer> od2 = new Generic<Integer>();
  		od2.show(132);       //132
  	}
  }
  ```

### 通配符

除了用 `<T>`表示泛型外，还有 `<?>`这种形式。`？` 被称为通配符。

```java
class Base{}

class Sub extends Base{}

Sub sub = new Sub();
Base base = sub;			
```

```java
List<Sub> lsub = new ArrayList<>();
List<Base> lbase = lsub;
```

最后一行代码成立吗？编译会通过吗？答案是**否定**的。

编译器不会让它通过的。Sub 是 Base 的子类，不代表 List<Sub>和 List<Base>有继承关系。

但是，在现实编码中，确实有这样的需求，希望泛型能够处理某一范围内的数据类型，比如某个类和它的子类，对此 Java 引入了通配符这个概念。所以，**通配符的出现是为了指定泛型中的类型范围**。

* `?`：表示任意类型
* `？ extends 类`：上边界限定通配符；
* `? super 类`：下边界限定通配符；

实例：

```java
import java.util.ArrayList;
import java.util.Collection;

//通配符
class Animal{}
class Cat extends Animal{}
class Dog extends Animal{}
public class GenericDemo05 {
	public static void main(String[] args) {
		//？ 任意类型
		Collection<?> c1 = new ArrayList<Animal>();
		Collection<?> c2 = new ArrayList<Cat>();
		Collection<?> c3 = new ArrayList<Dog>();
		

		//? extends E (向下限定)
		Collection<? extends Animal> c4 = new ArrayList<Cat>();
		Collection<? extends Animal> c5 = new ArrayList<Dog>();
		Collection<? extends Animal> c6 = new ArrayList<Animal>();

//		Collection<? extends Animal> c4 = new ArrayList<Object>();
		

		//? super E (向上限定)
		Collection<? super Animal> c7 = new ArrayList<Animal>();
		Collection<? super Animal> c8 = new ArrayList<Object>();

//		Collection<? super Animal> c7 = new ArrayList<Cat>();	
	}
}
```

#### 无限定通配符

无限定通配符经常与容器类配合使用，它其中的 `?` 其实代表的是未知类型，所以涉及到 `?` 时的操作，一定与具体类型无关。

```
public void testWildCards(Collection<?> collection){
}
```

上面的代码中，方法内的参数是被无限定通配符修饰的 `Collection` 对象，它隐略地表达了一个意图或者可以说是限定，那就是 `testWidlCards()` 这个方法内部无需关注 `Collection` 中的真实类型，因为它是未知的。所以，你只能调用 `Collection` 中与类型无关的方法。

![这里写图片描述](D:\Java\笔记\图片\1-00【Java基础】\10泛型)

我们可以看到，当 `<?>`存在时，`Collection` 对象丧失了 `add()` 方法的功能，编译器不通过。
我们再看代码。

```java
List<?> wildlist = new ArrayList<String>();
wildlist.add(123);// 编译不通过
```

有人说，`<?>`提供了只读的功能，也就是它删减了增加具体类型元素的能力，只保留与具体类型无关的功能。它不管装载在这个容器内的元素是什么类型，它只关心元素的数量、容器是否为空？我想这种需求还是很常见的吧。

有同学可能会想，`<?>`既然作用这么渺小，那么为什么还要引用它呢？ 

个人认为，提高了代码的可读性，程序员看到这段代码时，就能够迅速对此建立极简洁的印象，能够快速推断源码作者的意图。

#### extends 上边界限定通配符

```java
public class GenericsAndCovariance {
    public static void main(String[] args) {
        // Wildcards allow covariance:
        List<? extends Fruit> flist = new ArrayList<Apple>();
        // Compile Error: can’t add any type of object:
        // flist.add(new Apple());
        // flist.add(new Fruit());
        // flist.add(new Object());
        flist.add(null); // Legal but uninteresting
        // We know that it returns at least Fruit:
        Fruit f = flist.get(0);
    }
}
```

上面的例子中， `flist` 的类型是 `List<? extends Fruit>`，我们可以把它读作：一个类型的 List， 这个类型可以是继承了 `Fruit` 的某种类型。注意，**这并不是说这个 List 可以持有** `Fruit` **的任意类型**。通配符代表了一种特定的类型，它表示 “某种特定的类型，但是 `flist` 没有指定”。这样不太好理解，具体针对这个例子解释就是，`flist` 引用可以指向某个类型的 List，只要这个类型继承自 `Fruit`，可以是 `Fruit` 或者 `Apple`，比如例子中的 `new ArrayList<Apple>`，但是为了向上转型给 `flist`，`flist` 并不关心这个具体类型是什么。

如上所述，通配符 `List<? extends Fruit>` 表示某种特定类型 ( `Fruit` 或者其子类 ) 的 List，但是并不关心这个实际的类型到底是什么，反正是 `Fruit` 的子类型，`Fruit` 是它的上边界。那么对这样的一个 List 我们能做什么呢？其实如果我们不知道这个 List 到底持有什么类型，怎么可能安全的添加一个对象呢？在上面的代码中，向 `flist` 中添加任何对象，无论是 `Apple` 还是 `Orange` 甚至是 `Fruit` 对象，编译器都不允许，唯一可以添加的是 `null`。所以如果做了泛型的向上转型 (`List<? extends Fruit> flist = new ArrayList<Apple>()`)，那么我们也就失去了向这个 List 添加任何对象的能力，即使是 `Object` 也不行。

另一方面，如果调用某个返回 `Fruit` 的方法，这是安全的。因为我们知道，在这个 List 中，不管它实际的类型到底是什么，但肯定能转型为 `Fruit`，所以编译器允许返回 `Fruit`。

了解了通配符的作用和限制后，好像任何接受参数的方法我们都不能调用了。其实倒也不是，看下面的例子：

```java
public class CompilerIntelligence {
    public static void main(String[] args) {
        List<? extends Fruit> flist =
        Arrays.asList(new Apple());
        Apple a = (Apple)flist.get(0); // No warning
        flist.contains(new Apple()); // Argument is ‘Object’
        flist.indexOf(new Apple()); // Argument is ‘Object’
        
        //flist.add(new Apple());   无法编译

    }
}
```

在上面的例子中，`flist` 的类型是 `List<? extends Fruit>`，泛型参数使用了受限制的通配符，所以我们失去了向其中加入任何类型对象的例子，最后一行代码无法编译。

但是 `flist` 却可以调用 `contains` 和 `indexOf` 方法，它们都接受了一个 `Apple` 对象做参数。如果查看 `ArrayList` 的源代码，可以发现 `add()` 接受一个泛型类型作为参数，但是 `contains` 和 `indexOf` 接受一个 `Object` 类型的参数，下面是它们的方法签名：

```java
public boolean add(E e)
public boolean contains(Object o)
public int indexOf(Object o)

```

所以如果我们指定泛型参数为 `<? extends Fruit>` 时，`add()` 方法的参数变为 `? extends Fruit`，编译器无法判断这个参数接受的到底是 `Fruit` 的哪种类型，所以它不会接受任何类型。

然而，`contains` 和 `indexOf` 的类型是 `Object`，并没有涉及到通配符，所以编译器允许调用这两个方法。这意味着一切取决于泛型类的编写者来决定那些调用是 “安全” 的，并且用 `Object` 作为这些安全方法的参数。如果某些方法不允许类型参数是通配符时的调用，这些方法的参数应该用类型参数，比如 `add(E e)`。

当我们自己编写泛型类时，上面介绍的就有用了。下面编写一个 `Holder` 类：

```java
public class Holder<T> {
    
    private T value;
    public Holder() {}
    public Holder(T val) { value = val; }
    public void set(T val) { value = val; }
    public T get() { return value; }
    public boolean equals(Object obj) {
    return value.equals(obj);
    }
    
    public static void main(String[] args) {
        
        Holder<Apple> Apple = new Holder<Apple>(new Apple());
        Apple d = Apple.get();
        Apple.set(d);
        
        // Holder<Fruit> Fruit = Apple; // Cannot upcast
        Holder<? extends Fruit> fruit = Apple; // OK
        Fruit p = fruit.get();
        d = (Apple)fruit.get(); // Returns ‘Object’
        
        try {
            Orange c = (Orange)fruit.get(); // No warning
        } catch(Exception e) { System.out.println(e); }
        // fruit.set(new Apple()); // Cannot call set()
        // fruit.set(new Fruit()); // Cannot call set()
        
        System.out.println(fruit.equals(d)); // OK
    }
} 
/* Output: (Sample)
java.lang.ClassCastException: Apple cannot be cast to Orange
true
*///:~

```

在 `Holer` 类中，`set()` 方法接受类型参数 `T` 的对象作为参数，`get()` 返回一个 `T` 类型，而 `equals()` 接受一个 `Object` 作为参数。`fruit` 的类型是 `Holder<? extends Fruit>`，所以`set()`方法不会接受任何对象的添加，但是 `equals()` 可以正常工作。

#### 下边界限定通配符

通配符的另一个方向是　“超类型的通配符“: `? super T`，`T` 是类型参数的下界。使用这种形式的通配符，我们就可以 ”传递对象” 了。还是用例子解释：

```java
public class SuperTypeWildcards {
    static void writeTo(List<? super Apple> apples) {
        apples.add(new Apple());
        apples.add(new Jonathan());
        // apples.add(new Fruit()); // Error
    }
}
```

`writeTo` 方法的参数 `apples` 的类型是 `List<? super Apple>`，它表示某种类型的 List，这个类型是 `Apple` 的基类型。也就是说，我们不知道实际类型是什么，但是这个类型肯定是 `Apple` 的父类型。因此，我们可以知道向这个 List 添加一个 `Apple` 或者其子类型的对象是安全的，这些对象都可以向上转型为 `Apple`。但是我们不知道加入 `Fruit` 对象是否安全，因为那样会使得这个 List 添加跟 `Apple` 无关的类型。

在了解了子类型边界和超类型边界之后，我们就可以知道如何向泛型类型中 “写入” ( 传递对象给方法参数) 以及如何从泛型类型中 “读取” ( 从方法中返回对象 )。下面是一个例子：

```java
public class Collections { 
  public static <T> void copy(List<? super T> dest, List<? extends T> src) 
  {
      for (int i=0; i<src.size(); i++) 
        dest.set(i,src.get(i)); 
  } 
}
```

`src` 是原始数据的 List，因为要从这里面读取数据，所以用了上边界限定通配符：`<? extends T>`，取出的元素转型为 `T`。`dest` 是要写入的目标 List，所以用了下边界限定通配符：`<? super T>`，可以写入的元素类型是 `T` 及其子类型。

### Java类型擦除机制

泛型是 Java 1.5 版本才引进的概念，在这之前是没有泛型的概念的，但显然，泛型代码能够很好地和之前版本的代码很好地兼容。

这是因为，**泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除。**

通俗地讲，泛型类和普通类在 java 虚拟机内是没有什么特别的地方。回顾文章开始时的那段代码

```java
List<String> l1 = new ArrayList<String>();
List<Integer> l2 = new ArrayList<Integer>();
		
System.out.println(l1.getClass() == l2.getClass());
```

打印的结果为 true 是因为 `List<String>`和 `List<Integer>`在 jvm 中的 Class 都是 List.class。

泛型信息被擦除了。

可能同学会问，那么类型 String 和 Integer 怎么办？答案是泛型转译。

```java
public class Erasure <T>{
	T object;

	public Erasure(T object) {
		this.object = object;
	}

}
```

Erasure 是一个泛型类，我们查看它在运行时的状态信息可以通过反射。

```java
Erasure<String> erasure = new Erasure<String>("hello");
Class eclz = erasure.getClass();
System.out.println("erasure class is:"+eclz.getName());
```

打印的结果是

```java
erasure class is:com.frank.test.Erasure
```

Class 的类型仍然是 Erasure 并不是 `Erasure<T>`这种形式，那我们再看看泛型类中 `T` 的类型在 `jvm` 中是什么具体类型。

```java
Field[] fs = eclz.getDeclaredFields();
for ( Field f:fs) {
	System.out.println("Field name "+f.getName()+" type:"+f.getType().getName());
}
```

打印结果是

```java
Field name object type:java.lang.Object
```

那我们可不可以说，泛型类被类型擦除后，相应的类型就被替换成 Object 类型呢？

这种说法，不完全正确。

我们更改一下代码。

```java
public class Erasure <T extends String>{
//	public class Erasure <T>{
	T object;

	public Erasure(T object) {
		this.object = object;
	}

}
```

现在再看测试结果：

```java
Field name object type:java.lang.String
```

我们现在可以下结论了，在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 `<T>`则会被转译成普通的 Object 类型，如果指定了上限如 `<T extends String>`则类型参数就被替换成类型上限。

所以，在反射中。

```java
public class Erasure <T>{
	T object;

	public Erasure(T object) {
		this.object = object;
	}
	
	public void add(T object){
		
	}
	
}
```

add() 这个方法对应的 Method 的签名应该是 Object.class。

```java
Erasure<String> erasure = new Erasure<String>("hello");
Class eclz = erasure.getClass();
System.out.println("erasure class is:"+eclz.getName());

Method[] methods = eclz.getDeclaredMethods();
for ( Method m:methods ){
	System.out.println(" method:"+m.toString());
}
```

打印结果是

```java
 method:public void com.frank.test.Erasure.add(java.lang.Object)
```

也就是说，如果你要在反射中找到 add 对应的 Method，你应该调用 `getDeclaredMethod("add",Object.class)`否则程序会报错，提示没有这么一个方法，原因就是类型擦除的时候，T 被替换成 Object 类型了。

#### 类型擦除带来的局限性

类型擦除，是泛型能够与之前的 java 版本代码兼容共存的原因。但也因为类型擦除，它会抹掉很多继承相关的特性，这是它带来的局限性。

理解类型擦除有利于我们绕过开发当中可能遇到的雷区，同样理解类型擦除也能让我们绕过泛型本身的一些限制。比如

![这里写图片描述](D:\Java\笔记\图片\1-00【Java基础】\10类型擦除局限性.png)

正常情况下，因为泛型的限制，编译器不让最后一行代码编译通过，因为类似不匹配，但是，基于对类型擦除的了解，利用反射，我们可以绕过这个限制。

```java
public interface List<E> extends Collection<E>{
	
	 boolean add(E e);
}
```

上面是 List 和其中的 add() 方法的源码定义。

因为 E 代表任意的类型，所以类型擦除时，add 方法其实等同于

```java
boolean add(Object obj);
```

那么，利用反射，我们绕过编译器去调用 add 方法。

```java
public class ToolTest {

	public static void main(String[] args) {
		List<Integer> ls = new ArrayList<>();
		ls.add(23);
//		ls.add("text");
		try {
			Method method = ls.getClass().getDeclaredMethod("add",Object.class);
			
			
			method.invoke(ls,"test");
			method.invoke(ls,42.9f);
		} catch (NoSuchMethodException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (SecurityException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IllegalArgumentException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (InvocationTargetException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		for ( Object o: ls){
			System.out.println(o);
		}
	}
}
```

打印结果是：

```html
<!--
    23
    test
    42.9
-->
```

可以看到，利用类型擦除的原理，用反射的手段就绕过了正常开发中编译器不允许的操作限制。

### 泛型与数组

关于泛型数组的理解真的有点令人恼火（annoying）下面内容看看就行。在The Java™ Tutorials: Generics中讲到了泛型数组，并说道：除非使用通配符，否则一个数组对象的元素不能是泛型。即：在java中是”不能创建一个确切的泛型类型的数组”的。也就是说下面的这个例子是不可以的：

```java
List<String>[] ls = new ArrayList<String>[10];//Cannot create a generic array of ArrayList<String>
```

 而使用通配符创建泛型数组是可以的，如下面这个例子：

```java
List<?>[] ls = new ArrayList<?>[10]; 
//这样也是可以的：
List<String>[] ls = new ArrayList[10];
```

这么做的原因，是为了防止下述代码产生的类型安全问题：

```java
// Not really allowed.
List<String>[] lsa = new List<String>[10];     //1
Object o = lsa;
Object[] oa = (Object[]) o;
List<Integer> li = new ArrayList<Integer>();
li.add(new Integer(3));
// Unsound, but passes run time store check
oa[1] = li;

// Run-time error: ClassCastException.
String s = lsa[1].get(0);                      //2
```

 如果允许泛型数组的存在（第1处代码编译通过），那么在第2处代码就会报出ClassCastException，因为lsa[1]是List<Integer>。Java设计者本着首要保证类型安全（type-safety）的原则，不允许泛型数组的存在，使得编译期就可以检查到这类错误。

解决方案

但是连Java的设计者也承认，这样在使用上很令人恼火（原文是annoying），所以提供了变向的解决方案：显式类型转换。

①通配符

The Java™ Tutorials: Generics给出的解决方案如下：

```java
// OK, array of unbounded wildcard type.
List<?>[] lsa = new List<?>[10];                //1
Object o = lsa;
Object[] oa = (Object[]) o;
List<Integer> li = new ArrayList<Integer>();
li.add(new Integer(3));
// Correct.
oa[1] = li;
// Run time error, but cast is explicit.
String s = (String) lsa[1].get(0);              //2
```

 在第1处，用?取代了确定的参数类型。根据通配符的定义以及Java类型擦除的保留上界原则，在2处lsa[1].get(0)取出的将会是Object，所以需要程序员做一次显式的类型转换。

②反射

使用java.util.reflect.Array，可以不使用通配符，而达到泛型数组的效果：

```java
List<String>[] lsa = (List<String>[])Array.newInstance(ArrayList.class, 4);     //1
Object o = lsa;
Object[] oa = (Object[]) o;
List<Integer> li = new ArrayList<Integer>();
li.add(new Integer(3));
// Correct.
oa[1] = li;
// Run time error, but cast is explicit.
String s = lsa[1].get(0);                                                      //2
```

 可以看到，我们利用了Array.newInstance()生成了泛型数组，这里没有使用任何通配符，在第2处也没有做显式的类型转换，但是在第1处，仍然存在显式类型转换。

类似地，尝试创建元素类型为类型变量的数组对象会导致编译时错误：

```java
//不能用泛型来建立数组的实例
private T[] arr= new T[10];    //Cannot create a generic array of T
//可以参数化数组本身类型
private T[] arr;

<T> T[] makeArray(T t) {
    return new T[100]; // Error.
}
```
