 **集合**：集合是java中提供的一种容器，可以用来存储多个数据。

集合和数组都是容器，他们的区别如下：

* 数组的长度是固定的。集合的长度是可变的。
* 数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。

由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：`Hashtable`一种线程安全的`Map`实现、`Vector`一种线程安全的`List`实现、`Stack`基于`Vector`实现的`LIFO（Last in First out）后进先出`的栈。

还有一小部分接口是遗留接口，也不应该继续使用：`Enumeration<E>`接口，该接口已被`Iterator<E>`取代。

集合按照其存储结构可以分为两大类，分别是单列集合`java.util.Collection`和双列集合`java.util.Map`。

# 第一章 Collection集合

**Collection**：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有三个重要的子接口，分别是`java.util.List`、`java.util.Queue`和`java.util.Set`。

`List`的特点是元素有序、元素可重复。`Set`的特点是元素无序，而且不可重复。`List`接口的主要实现类有`java.util.ArrayList`和`java.util.LinkedList`，`Set`接口的主要实现类有`java.util.HashSet`和`java.util.TreeSet`。

![](D:\Java\笔记\图片\1-02【集合】\1-1.png)

Collection是所有单列集合的父接口，因此在Collection中定义了单列集合通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：

| 方法                  | 作用                             |
| --------------------- | -------------------------------- |
| boolean add(E e)      | 把给定的对象添加到当前集合中     |
| void clear()          | 清空集合中所有的元素             |
| boolean remove(E e)   | 把给定的对象在当前集合中删除     |
| boolean contains(E e) | 判断当前集合中是否包含给定的对象 |
| boolean isEmpty()     | 判断当前集合是否为空             |
| int size()            | 返回集合中元素的个数             |
| Object[] toArray()    | 把集合中的元素，存储到数组中     |

## 1.1 List接口

`java.util.List`接口继承自`Collection`接口，是单列集合的一个重要分支，习惯性地会将实现了`List`接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。

List接口特点：

1. 它是一个元素存取有序的集合。存元素的顺序是`11、22、33`，那么集合中元素的存储就是`11、22、33`。
2. 它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素，与数组的索引相同。
3. 集合中可以有重复的元素，通过元素的`equals`方法，来比较是否为重复的元素。

List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法：

| 方法                           | 作用                                                     |
| ------------------------------ | -------------------------------------------------------- |
| void add(int index, E element) | 将指定的元素，添加到该集合中的指定位置上                 |
| E get(int index)               | 返回集合中指定位置的元素                                 |
| E remove(int index)            | 移除列表中指定位置的元素，返回的是被移除的元素           |
| E set(int index, E element)    | 用指定元素替换集合中指定位置的元素，返回值的更新前的元素 |

### 1.1.1 Vector

Vector 类实现了一个动态数组。和 ArrayList 很相似，但是两者是不同的。Vector 是同步访问的并且包含了许多传统的方法，这些方法不属于集合框架。

Vector 主要用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况。

```java
public class Vector<E>
    extends AbstractList<E>
    implements List<E>, RandomAccess, Cloneable, java.io.Serializable{}
```

> 前面说过Vector集合类是遗留类，不应该继续使用

### 1.1.2 ArrayList集合

我们想存储对象数据，选择的容器，只有对象数组。而数组的长度是固定的，无法适应数据变化的需求。为了解决这个问题，Java提供了另一个容器 `java.util.ArrayList` 集合类，让我们可以更便捷的存储和操作对象数据。

`java.util.ArrayList` 是大小可变的数组的实现，存储在内的数据称为元素。此类提供一些方法来操作内部存储的元素。 `ArrayList` 中可不断添加元素，其大小也自动增长。`ArrayList`对象不能存储基本类型，只能存储引用类型的数据。类似`<int>`不能写，但是存储基本数据类型对应的包装类型是可以的。

![](D:\Java\笔记\图片\1-02【集合】\2-2.png)

`ArrayList`集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以`ArrayList`是最常用的集合。

`ArrayList`是一个动态数组，查询效率快、而在增、删的过程中会涉及到数组的复制，所以效率低。`ArrayList`是线程不安全的，运行效率快，允许元素为`null`。

* 当修改、查询或者只在数组末尾增、删时，时间复杂度为`O(1)`；
* 对指定位置的元素进行增、删时，时间复杂度为`O(n)`。

ArrayList的底层是数组，数组的名称是`elementData`，类型是`Object[]`，所以`ArrayList`里面可以存放任意类型的元素。

```java
public class ArrayList<E> extends AbstractList<E>
    implements List<E>, RandomAccess, Cloneable, java.io.Serializable {
    
    // 定义elementData数组 对于transient修饰的成员变量，在类的实例对象的序列化处理过程中会被忽略。
    transient Object[] elementData; 
    // 定义长度
    private int size;
    // 空列表
    private static final Object[] EMPTY_ELEMENTDATA = {};
    // 空列表
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
    
    // 第一个构造函数：构造一个空列表，等要添加元素的时候就会将其初始容量变为10
    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }
    
    // 第二个构造函数：根据指定的初始容量构造
    public ArrayList(int initialCapacity) {
        if (initialCapacity > 0) {
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            throw new IllegalArgumentException("Illegal Capacity: "+
                                               initialCapacity);
        }
    }
    
    // 第三个构造函数：包含指定元素的列表集合
    public ArrayList(Collection<? extends E> c) {
        elementData = c.toArray();
        if ((size = elementData.length) != 0) {
            // 必须是Object数组
            if (elementData.getClass() != Object[].class)
                // 然后再copy一份到 elementData 并不是引用 所有改变不会影响到原先的Collection
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        } else {
            // 参数为空列表转为空数组的时候，赋值为 EMPTY_ELEMENTDATA
            this.elementData = EMPTY_ELEMENTDATA;
        }
    }
}
```

ArrayList底层数组的默认初始化容量是10。当超出这个大小时，每次扩容1.5倍。当向`ArrayList`中增加一个对象的时候，Java首先会判断`ArrayList`的底层数组`elementData`是否还有足够的空间来存储这个对象。如果有，就直接存，如果没有，就会基于原有的数组扩容出一个1.5倍的新数组，并将数据全部复制到新数组中。新建了一个数组，旧数组的对象被复制到了新的数组中，并且现有的数组引用指向新的数组。

当向ArrayList集合中添加元素时需要调用`add()`方法，执行流程如下：

```java
public boolean add(E e) {
    // 确保数组有足够的空间来存储对象e
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    // 将对象e存放到数组的末尾
    elementData[size++] = e;
    return true;
}
```

* 调用`add()`方法时，`add()`方法首先调用`ensureCapacityInternal()`来判断`elementData`数组容量是否足够空间来存储待添加的元素。

  ```java
  // 初始空列表
  private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
  // 默认容量为10
  private static final int DEFAULT_CAPACITY = 10;
  
  private void ensureCapacityInternal(int minCapacity) {
      if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
          // minCapacity是原数组增加元素后需要的数组长度
          minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
      }
  
      ensureExplicitCapacity(minCapacity);
  }
  ```

* `ensureCapacityInternal()`之所以能够判断，是因为它内部调用了`ensureExplicitCapacity()`方法，这个方法才是真正判断`elementData`数组容量是否够用的关键方法。

  ```java
  // ArrayList<E> extends AbstractList<E>.modCount属性是AbstractList里面的
  // 这个成员变量记录着集合的修改次数，也就每次add或者remove它的值都会加1
  protected transient int modCount = 0;
  
  private void ensureExplicitCapacity(int minCapacity) {
      modCount++;
  
      // overflow-conscious code
      if (minCapacity - elementData.length > 0)
          grow(minCapacity);
  }
  ```

* 如果容量足够，则直接将元素添加到`ArrayList`中；如果容量不够，则`ensureExplicityCapacity()`方法内部会调用`grow()`方法来对数组进行扩容。扩容成功之后，再将元素添加到`ArrayList`扩容之后的新数组中。

  ```java
  // 一些JVM在数组中会有保留字，尝试分配更大的数组可能会导致OutOfMemoryError，所以减去8
  private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
  
  private void grow(int minCapacity) {
      // overflow-conscious code
      int oldCapacity = elementData.length;
      // newCapacity是预计扩容后的数组长度。数组长度超过10之后，每次默认扩容1.5倍
      int newCapacity = oldCapacity + (oldCapacity >> 1); 
      if (newCapacity - minCapacity < 0)
          newCapacity = minCapacity;
      if (newCapacity - MAX_ARRAY_SIZE > 0)
          newCapacity = hugeCapacity(minCapacity);
      // 进行数组的复制扩容
      elementData = Arrays.copyOf(elementData, newCapacity);
  }
  ```

  ```java
  private static int hugeCapacity(int minCapacity) {
      if (minCapacity < 0) // overflow
          throw new OutOfMemoryError();
      return (minCapacity > MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;
  }
  ```

在调用ArrayList的`remove(int index)`方法时，首先判断`index`是否合理，如果合理的话，会调用`System.arraycopy()`方法把指定下标到数组末尾的元素向前移动一个单位，并且会把数组最后一个元素设为`null`。这样是为了方便GC回收。

```java
public E remove(int index) {
    // 判断index是否合理
    rangeCheck(index);

    // 这个成员变量记录着集合的修改次数，也就每次add或者remove它的值都会加1
    modCount++;
    E oldValue = elementData(index);

    int numMoved = size - index - 1;
    if (numMoved > 0)
        System.arraycopy(elementData, index+1, elementData, index, numMoved);
    // 把数组最后一个元素设为null。这样是为了方便GC回收
    elementData[--size] = null; // clear to let GC do its work

    return oldValue;
}

// 判断index是否合理
private void rangeCheck(int index) {
    if (index >= size)
        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
}
```

ArrayList在调用`get(int index)`方法查询的时候，首先判断`index`是否合理，然后调用`elementData()`方法，`elementData()`方法返回根据i`ndex`查到的具体的元素。这里的返回值都经过了向下转型（Object -> E）

```java
public E get(int index) {
    // 判断是否合理
    rangeCheck(index);

    // 返回
    return elementData(index);
}

@SuppressWarnings("unchecked")
E elementData(int index) {
    // 返回值经过了向下转型
    return (E) elementData[index];
}
```


### 1.1.3 ArrayList 和 LinkedList

首先来基本基本介绍一下：

* `ArrayList`的底层数据结构为数组，增删慢、查询快，线程不安全，效率高。当对数据的主要操作为索引或只在集合的末端增加、删除数据时，使用`ArrayList`效率比较高；

* `LinkedList`的底层数据结构为链表，增删快、查询慢，线程不安全，效率高。当对数据的操作主要为指定位置的插入或删除操作时，使用`LinkedList`效率比较高。

从底层实现角度来看：

- `ArrayList`：是基于动态数组的数据结构；名称是`elementData`，类型是`Object[]`，所以`ArrayList`里面可以存放任意类型的元素

- `LinkedList`：是基于双向循环链表的数据结构

从随机访问（索引）元素角度来看：

- `ArrayList`：数据存储是连续的，因此支持用下标来访问元素`get(int index)`，直接返回`index`位置上的元素，随机访问元素速度快 `O(1)`
- `LinkedList`：需要通过`for`循环进行查找，虽然`LinkedList`已经在查找方法上做了优化，比如`index < size / 2`，则从左边开始查找，反之从右边开始查找，但是还是比`ArrayList`要慢。 `O(N)`

从插入，删除元素角度来看：

- `ArrayList`：想要在指定位置插入或删除元素时，主要耗时的是`System.arraycopy`动作，会移动`index`后面所有的元素，从而会重新调整索引顺序,调整索引顺序会消耗一定的时间，所以速度上就会比`LinkedList`要慢许多；`O(N)`
- `LinkedList`：主耗时的是要先通过`for`循环找到`index`，再改变前后对象的引用，然后直接插入或删除，效率较高。`O(N)`

从初始容量和扩容来看：

- `ArrayList`：默认初始化容量是10，当存储元素大小超过初始容量时，需要动态扩容为原来的1.5倍。

  如果设置后的新容量还不够，则直接新容量设置为传入的参数（也就是所需的容量），而后用`Arrays.copyof()`方法将元素拷贝到新的数组。从中可以看出，当容量不够时，每次增加元素，都要将原来的元 素拷贝到一个新的数组中，非常之耗时。因此我们可以指定容量，避免扩容。

- `LinkedList`：使用了链表的结构，因此不需要维护容量的大小。

从实现栈和队列角度来看：

- `LinkedList`要优于`ArrayList`。因为`LinkedList`是个双向链表，它同样可以被当作栈、队列或双端队列来使用。例如`Queue queue=new LinkedList<>()`;

当对数据的主要操作为索引或者只在集合末端增加、删除元素时候，使用ArrayList效率比较高。当对数据的主要操作为指定位置的插入或者删除操作时，使用LinkedList效率比较高。

## 1.2 Queue接口

常用方法：

* 栈：`push pop peek`
* 队列：`offer poll peek`返回false、`add remove element`抛异常(最好不要使用)

队列`Queue`是一种经常使用的集合。`Queue`实际上是实现了一个先进先出`FIFO：First In First Out`的有序表。它和`List`的区别在于：`List`可以在任意位置添加和删除元素、`Queue`只能把元素添加到队列末尾或者从队列头部取出元素。

在Java的标准库中，队列接口`Queue`定义了以下几个方法：

| 方法                              | 作用                           |
| --------------------------------- | ------------------------------ |
| int size()                        | 获取队列长度                   |
| boolean add(E) / boolean offer(E) | 添加元素到队尾                 |
| E remove() / E poll()             | 获取队首元素并从队列中删除     |
| E element() / E peek()            | 获取队首元素但并不从队列中删除 |

对于具体的实现类，有的Queue有最大队列长度限制，有的Queue没有。注意到添加、删除和获取队列元素总是有两个方法，这是因为在添加或获取元素失败时，这两个方法的行为是不同的。我们用一个表格总结如下：

|                    | throw Exception | 返回false或null    |
| :----------------- | :-------------- | ------------------ |
| 添加元素到队尾     | add(E e)        | boolean offer(E e) |
| 取队首元素并删除   | E remove()      | E poll()           |
| 取队首元素但不删除 | E element()     | E peek()           |

> 注意：不要把`null`添加到队列中，否则`poll()`方法返回`null`时，很难确定是取到了`null`元素还是队列为空。

### 1.2.1 PriorityQueue

优先队列`PriorityQueue`。

`PriorityQueue`和`Queue`的区别在于，它的出队顺序与元素的优先级有关，对`PriorityQueue`调用`remove()`或`poll()`方法，返回的总是优先级最高的元素。要使用`PriorityQueue`，我们就必须给每个元素定义“优先级”。

我们以实际代码为例，先看看`PriorityQueue`的行为：

```java
public class Main {
    public static void main(String[] args) {
        Queue<String> q = new PriorityQueue<>();
        // 添加3个元素到队列:
        q.offer("apple");
        q.offer("pear");
        q.offer("banana");
        System.out.println(q.poll()); // apple
        System.out.println(q.poll()); // banana
        System.out.println(q.poll()); // pear
        System.out.println(q.poll()); // null,因为队列为空
    }
}
```

放入的顺序是`"apple"`、`"pear"`、`"banana"`，但是取出的顺序却是`"apple"`、`"banana"`、`"pear"`，这是因为从字符串的排序看，`"apple"`排在最前面，`"pear"`排在最后面。

因此，放入`PriorityQueue`的元素，必须实现`Comparable`接口，`PriorityQueue`会根据元素的排序顺序决定出队的优先级。如果我们要放入的元素并没有实现`Comparable`接口怎么办？`PriorityQueue`允许我们提供一个`Comparator`对象来判断两个元素的顺序。

我们以银行排队业务为例，实现一个`PriorityQueue`：

```java
public class Main {
    public static void main(String[] args) {
        Queue<User> q = new PriorityQueue<>(new UserComparator());
        // 添加3个元素到队列:
        q.offer(new User("Bob", "A1"));
        q.offer(new User("Alice", "A2"));
        q.offer(new User("Boss", "V1"));
        System.out.println(q.poll()); // Boss/V1
        System.out.println(q.poll()); // Bob/A1
        System.out.println(q.poll()); // Alice/A2
        System.out.println(q.poll()); // null,因为队列为空
    }
}
```

```java
class UserComparator implements Comparator<User> {
    public int compare(User u1, User u2) {
        if (u1.number.charAt(0) == u2.number.charAt(0)) {
            // 如果两人的号都是A开头或者都是V开头,比较号的大小:
            return u1.number.compareTo(u2.number);
        }
        if (u1.number.charAt(0) == 'V') {
            // u1的号码是V开头,优先级高:
            return -1;
        } else {
            return 1;
        }
    }
}
```

### 1.2.2 Deque接口

`Queue`是队列，只能一头进，另一头出。如果把条件放松一下，允许两头都进，两头都出，这种队列叫双端队列（Double Ended Queue），学名`Deque`。

Java集合提供了接口`Deque`来实现一个双端队列，它既可以添加到队尾，也可以添加到队首；既可以从队首获取，又可以从队尾获取。

我们来比较一下`Queue`和`Deque`出队和入队的方法：

|                    | Queue                  | Deque                           |
| :----------------- | :--------------------- | ------------------------------- |
| 添加元素到队尾     | add(E e) / offer(E e)  | addLast(E e) / offerLast(E e)   |
| 取队首元素并删除   | E remove() / E poll()  | E removeFirst() / E pollFirst() |
| 取队首元素但不删除 | E element() / E peek() | E getFirst() / E peekFirst()    |
| 添加元素到队首     | 无                     | addFirst(E e) / offerFirst(E e) |
| 取队尾元素并删除   | 无                     | E removeLast() / E pollLast()   |
| 取队尾元素但不删除 | 无                     | E getLast() / E peekLast()      |

注意到`Deque`接口实际上扩展自`Queue`：

```java
public interface Deque<E> extends Queue<E> {
    ...
}
```

因此，`Queue`提供的`add()/offer()`方法在`Deque`中也可以使用。但是，使用`Deque`最好不要调用`offer()`，而是调用`offerLast()`：

```java
public class Main {
    public static void main(String[] args) {
        Deque<String> deque = new LinkedList<>();
        deque.offerLast("A"); // A
        deque.offerLast("B"); // A <- B
        deque.offerFirst("C"); // C <- A <- B
        System.out.println(deque.pollFirst()); // C, 剩下A <- B
        System.out.println(deque.pollLast()); // B, 剩下A
        System.out.println(deque.pollFirst()); // A
        System.out.println(deque.pollFirst()); // null
    }
}
```

如果直接写`deque.offer()`，我们就需要思考这是添加对队尾还是对头。如果明确地写上`offerLast()`，不需要思考就能一眼看出这是添加到队尾。因此使用`Deque`，推荐总是明确地调用`offerLast()`/`offerFirst()`或者`pollFirst()`/`pollLast()`方法。

`Deque`是一个接口，它的实现类有`ArrayDeque`和`LinkedList`。

### 1.2.3 LinkedList

`LinkedList`集合数据存储的结构是链表结构。LinkedList是一个双向链表，方便元素添加和删除。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。

`LinkedList`是一个全能选手，它即是`List`，又是`Queue`，还是`Deque`。但是我们在使用的时候，总是用特定的接口来引用它，这是因为持有接口说明代码的抽象层次更高，而且接口本身定义的方法代表了特定的用途。

```java
// 不推荐的写法:
LinkedList<String> d1 = new LinkedList<>();
d1.offerLast("z");
// 推荐的写法：
Deque<String> d2 = new LinkedList<>();
d2.offerLast("z");
```

可见面向抽象编程的一个原则就是：尽量持有接口，而不是具体的实现类。

### 1.2.3 Stack

栈（Stack）是一种后进先出（LIFO：Last In First Out）的数据结构。

`Stack`只有压栈和弹栈的操作。在Java中，我们用`Deque`可以实现`Stack`的功能。为什么Java的集合类没有单独的`Stack`接口呢？因为有个遗留类名字就叫`Stack`，出于兼容性考虑，所以没办法创建`Stack`接口，只能用`Deque`接口来“模拟”一个`Stack`了。

| 方法    | 作用               |
| ------- | ------------------ |
| push(E) | 把元素压栈         |
| pop()   | 取栈顶元素并且弹出 |
| peek()  | 取栈顶元素但不弹出 |

当我们把`Deque`作为`Stack`使用时，注意只调用`push()`/`pop()`/`peek()`方法，不要调用`addFirst()`/`removeFirst()`/`peekFirst()`方法，这样代码更加清晰。

```java
public static void main(String[] args) {
    Deque<String> stack = new LinkedList<>();

    // 压栈
    stack.push("第一个元素");
    stack.push("第二个元素");
    // 出栈并且弹出
    System.out.println(stack.pop()); // 第二个元素
    // 出栈不弹出
    System.out.println(stack.peek()); // 第一个元素
}
```

## 1.3 Set接口

`Set`接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。`Set`集合有多个子类，这里我们介绍其中的`java.util.HashSet`、`java.util.LinkedHashSet`这两个集合。

Set集合取出元素的方式可以采用：迭代器、增强for循环。

### 1.3.1 HashSet集合

`java.util.HashSet`是`Set`接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。`java.util.HashSet`底层的实现其实是一个`java.util.HashMap`支持。

`HashSet`是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：`hashCode`与`equals`方法。给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一。

### 1.3.3 LinkedHashSet

我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？在HashSet下面有一个子类`java.util.LinkedHashSet`，它是链表和哈希表组合的一个数据存储结构。

~~~java
public class LinkedHashSetDemo {
    public static void main(String[] args) {
        Set<String> set = new LinkedHashSet<String>();
        set.add("bbb");
        set.add("aaa");
        set.add("abc");
        set.add("bbc");
        Iterator<String> it = set.iterator();
        while (it.hasNext()) {
            System.out.println(it.next());
        }
    }
}
结果：
  bbb
  aaa
  abc
  bbc
~~~

# 第二章 Map集合

现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即`java.util.Map`接口。

`Map`接口下的集合与`Collection`接口下的集合，它们存储数据的形式不同，如下：

* `Collection`中的集合称为单列集合，`Map`中的集合称为双列集合。
* `Collection`中集合的元素是孤立存在的，向集合中存储元素采用一个个元素的方式存储。
* `Map`中集合的元素是成对存在的。每个元素由键与值两部分组成，通过键可以找对所对应的值。
* `Map`中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。

Map接口中的集合都有两个泛型变量`<K,V>`。在使用时，要为两个泛型变量赋予数据类型，数据类型可以相同，也可以不同。

Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。

![](D:\Java\笔记\图片\1-02【集合】\6-1.png)

Map接口中定义了很多方法，常用的如下：

| 方法                    | 作用                                                         |
| ----------------------- | ------------------------------------------------------------ |
| V put(K key, V value)   | 把指定的键与指定的值添加到Map集合中                          |
| V remove(Object key)    | 把指定的键所对应的键值对元素在Map集合中删除，返回被删除元素的值 |
| V get(Object key)       | 获取指定的键对应的值                                         |
| containsKey(Object key) | 判断集合中是否包含指定的键                                   |

`Map`中存放的是两种对象，一种称为key(键)，一种称为value(值)，它们在`Map`中是一一对应关系，这一对对象又称做`Map`中的一个`Entry(项)`。`Entry`将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历`Map`集合时，就可以从每一个键值对（`Entry`）对象中获取对应的键与对应的值。

| 方法                           | 作用                                           |
| ------------------------------ | ---------------------------------------------- |
| Set<K> keySet()                | 获取Map集合中所有的键，存储到Set集合中         |
| Set<Map.Entry<K,V>> entrySet() | 获取到Map集合中所有的键值对对象的集合(Set集合) |
| K getKey()                     | 获取Entry对象中的键                            |
| V getValue()                   | 获取Entry对象中的值                            |

## 2.1 HashMap

HashMap基于哈希表的Map接口实现，是以key-value存储形式存在，即主要用来存放键值对。HashMap的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。特点如下：

- 存取无序的

- 线程不安全

- 键和值位置都可以是null，但是键位置只能是一个null

- 键位置是唯一的，底层的数据结构控制键的

- jdk1.8前数据结构是链表 + 数组，jdk1.8之后是链表 + 数组  + 红黑树。

- 阈值(边界值) > 8 并且数组长度大于64，才将链表转换为红黑树，变为红黑树的目的是为了高效的查询。

```java
public class HashMap<K,V> extends AbstractMap<K,V>
    implements Map<K,V>, Cloneable, Serializable {

    // 加载因子
    final float loadFactor;
    
    // 默认加载因子
    static final float DEFAULT_LOAD_FACTOR = 0.75f;

    // 第一种构造方法：使用默认初始化容量（16）和默认加载因子（0.75）来构造一个空的HashMap
    public HashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
    }

    // 第二种构造方法：调用了指定初始容量和加载因子的构造函数并将加载因子指定为默认值（0.75）
    public HashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }
    
    // 第三种构造方法：
    public HashMap(int initialCapacity, float loadFactor) {
        // 对初始容量进行判断
        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal initial capacity: " +
                                               initialCapacity);
        if (initialCapacity > MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor <= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal load factor: " +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    }
}

```

在JDK1.8之前，HashMap底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。

而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度大于阈值（或者红黑树的边界值，默认为8）并且当前数组的长度大于64时，此时此索引位置上的所有数据改为使用红黑树存储，这样大大减少了查找时间。如下图所示。

![](D:\Java\笔记\图片\1-02【集合】\4-0哈希表.png)

将链表转换成红黑树前会判断，如果阈值大于8，但是数组长度小64，此时并不会将链表变为红黑树。而是选择进行数组扩容。这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡。同时数组长度小于64时，搜索时间相对快一些。所以综上所述为了提高性能和减少搜索时间，底层在阈值大于8并且数组长度大于64时，链表才转换为红黑树。

桶，可以理解为哈希表中的key，每一个key对应一个桶，桶中放着链表。哈希是空间换时间的。

![](D:\Java\笔记\图片\1-02【集合】\4-1哈希表.png)

### 2.1.1 哈希碰撞

哈希表底层采用key的hashCode方法的值结合数组长度进行无符号右移（>>>）、按位异或（^）、按位与（&）计算出索引的。

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

我们还可以采用：平方取中法，取余数，伪随机数法来计算哈希值。这三种效率都比较低。而无符号右移16位异或运算效率是最高的。

只要两个元素的key计算的哈希值相同的话就会发生哈希碰撞。如果两个键的hashcode相同，那么就会通过equals比较内容是否相同，相同的话新的value覆盖之前的value，不相同则将新的键值对添加到哈希表中。

jdk8前使用链表解决哈希碰撞。jdk8之后使用链表+红黑树解决哈希碰撞。

### 2.1.2 存储流程

```java
public V put(K key, V value) {
    // 对key做hash运算，然后调用putVal方法
    return putVal(hash(key), key, value, false, true);
}

static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}

final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
    Node<K,V>[] tab; 
    Node<K,V> p; 
    int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node<K,V> e; K k;
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            e = p;
        else if (p instanceof TreeNode)
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        else {
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    if (++size > threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
```

![](D:\Java\笔记\图片\1-02【集合】\8-1HashMapput方法.png)

```java
public V put(K key, V value) {
    //对key的hashCode()做hash，调用的是putVal方法
        return putVal(hash(key), key, value, false, true);
    }
 
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node<K,V>[] tab; Node<K,V> p; int n, i;
        /*
           1，tab为空则开始创建，
           2，(tab = table) == null 表示将空的table赋值给tab,然后判断tab是否等于null，第一次肯定是null
           3，(n = tab.length) == 0 表示没有为table分配内存
           4，tab为空，执行代码 n = (tab = resize()).length; 进行扩容。并将初始化好的数组长度赋值给n.
           5，执行完n = (tab = resize()).length，数组tab每个空间都是null
        */
       
        if ((tab = table) == null || (n = tab.length) == 0)
            //调用resize()方法进行扩容
            n = (tab = resize()).length;
         /*
        1，i = (n - 1) & hash 表示计算数组的索引赋值给i，即确定元素存放在哪个桶中
        2，p = tab[i = (n - 1) & hash]表示获取计算出的位置的数据赋值给节点p
        3，(p = tab[i = (n - 1) & hash]) == null 判断节点位置是否等于null，
         如果为null，则执行代码：tab[i] = newNode(hash, key, value, null);根据键值对创建新的节点放入该位置的桶中
        小结：如果当前桶没有哈希碰撞冲突，则直接把键值对插入空间位置
    */ 
        if ((p = tab[i = (n - 1) & hash]) == null)
            //节点位置为null，则直接进行插入操作
            tab[i] = newNode(hash, key, value, null);
        //节点位置不为null，表示这个位置已经有值了，于是需要进行比较hash值是否相等
        else {
            Node<K,V> e; K k;
             /*
          比较桶中第一个元素(数组中的结点)的hash值和key是否相等
               1，p.hash == hash 中的p.hash表示原来存在数据的hash值  hash表示后添加数据的hash值 比较两个hash值是否相等
               2，(k = p.key) == key ：p.key获取原来数据的key赋值给k  key表示后添加数据的key 比较两个key的地址值是否相等
               3，key != null && key.equals(k)：能够执行到这里说明两个key的地址值不相等，那么先判断后添加的key是否等于null，如果不等于null再调用equals方法判断两个key的内容是否相等
        */
            if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
                 /*
                 说明：两个元素哈希值相等（哈希碰撞），并且key的值也相等
                 将旧的元素整体对象赋值给e，用e来记录
                */ 
                e = p;
            // hash值不相等或者key不相等；判断p是否为红黑树结点
            else if (p instanceof TreeNode)
                // 是红黑树，调用树的插入方法
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            // 说明是链表节点，这时进行插入操作
            else {
                /*
                1，如果是链表的话需要遍历到最后节点然后插入
                2，采用循环遍历的方式，判断链表中是否有重复的key
                */
                for (int binCount = 0; ; ++binCount) {
                    /*
                 1)e = p.next 获取p的下一个元素赋值给e
                 2)(e = p.next) == null 判断p.next是否等于null，等于null，说明p没有下一个元     素，那么此时到达了链表的尾部，还没有找到重复的key,则说明HashMap没有包含该键
                 将该键值对插入链表中
                */
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        //插入后发现链表长度大于8，转换成红黑树结构
                        if (binCount >= TREEIFY_THRESHOLD - 1) 
                            //转换为红黑树
                            treeifyBin(tab, hash);
                        break;
                    }
                    //key值以及存在直接覆盖value
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e;
                }
            }
            //若结点为null，则不进行插入操作
            if (e != null) { 
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        //修改记录次数
        ++modCount;
        // 判断实际大小是否大于threshold阈值，如果超过则扩容
        if (++size > threshold)
            resize();
        // 插入后回调
        afterNodeInsertion(evict);
        return null;
    }
```

- 根据哈希表中元素个数确定是扩容还是树形化

- 如果是树形化遍历桶中的元素，创建相同个数的树形节点，复制内容，建立起联系

- 然后让桶中的第一个元素指向新创建的树根节点，替换桶的链表内容为树形化内容

### 2.1.3 扩容机制

当HashMap中的元素个数超过`数组长度 × loadFactor(负载因子)`时，就会进行数组扩容，`loadFactor`的默认值是`0.75`，这是一个折中的取值。

默认情况下，数组大小为16，那么当HashMap中的元素个数超过`16×0.75=12(这个值就是阈值)`的时候，就把数组的大小扩展为`2×16=32`，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常耗性能的操作。所以如果我们已经预知HashMap中元素的个数，那么预知元素的个数能够有效的提高HashMap的性能。

HashMap在进行扩容时使用 `resize()` 方法，计算 table 数组的新容量和 Node 在新数组中的新位置，将旧数组中的值复制到新数组中，从而实现自动扩容。因为每次扩容都是翻倍，与原来计算的 `(n-1)&hash`的结果相比，只是多了一个`bit`位，所以节点要么就在原来的位置，要么就被分配到"`原位置+旧容量`"这个位置。

因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来hash值新增的那个bit是1还是0就可以了，是0的话索引没变，是1的话索引变成“原索引+oldCap(原位置+旧容量)”。

可以看看下图为16扩充为32的resize示意图：

![](D:\Java\笔记\图片\1-02【集合】\8-1HashMap扩容.png)

### 2.1.4 FAQ

**HashMap数组长度为什么是2的次幂**

**为什么 HashMap中 String、Integer 这样的包装类适合作为 key键？**

![](D:\Java\笔记\图片\1-02【集合】\8-2FAQ.png)

**HashMap中的key如果是Object类型，则需实现哪些方法？**

![](D:\Java\笔记\图片\1-02【集合】\8-3FAQ.jpg)

## 2.4 LinkedHashMap

我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？

在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。

~~~java
public class LinkedHashMapDemo {
    public static void main(String[] args) {
        LinkedHashMap<String, String> map = new LinkedHashMap<String, String>();
        map.put("邓超", "孙俪");
        map.put("李晨", "范冰冰");
        map.put("刘德华", "朱丽倩");
        Set<Entry<String, String>> entrySet = map.entrySet();
        for (Entry<String, String> entry : entrySet) {
            System.out.println(entry.getKey() + "  " + entry.getValue());
        }
    }
}
~~~

结果:

~~~
邓超  孙俪
李晨  范冰冰
刘德华  朱丽倩
~~~

## 2.5 Hashtable

HashTable是较为远古的使用Hash算法的容器结构了，现在基本已被淘汰，单线程转为使用HashMap，多线程使用ConcurrentHashMap。

HashMap是线程不安全的类，多线程下会造成并发冲突，但单线程下运行效率较高；HashTable是线程安全的类，很多方法都是用synchronized修饰，但同时因为加锁导致并发效率低下，单线程环境效率也十分低；

## 2.6 ConcurrentHashMap

concurrentHashMap是一个支持高并发更新与查询的哈希表(基于HashMap)。在保证安全的前提下，进行检索不需要锁定。与hashtable不同，该类不依赖于synchronization去保证线程操作的安全。

## 2.7 Properties

<!--Properties 所有物; 财产; 财物; 不动产; 房地产; 房屋及院落; 庄园;-->

`java.util.Properties`继承于`Hashtable`，来表示一个持久的属性集。它使用键值结构存储数据，每个键与其对应值都是一个字符串。该类也被许多java类使用，比如获取系统属性时，`System.getProperties`方法就是返回一个`Properties`对象。

```java
public class Properties extends Hashtable<Object,Object> {}
```

```java
public class Hashtable<K,V>
    extends Dictionary<K,V>
    implements Map<K,V>, Cloneable, java.io.Serializable {}
```

`Properties`类表示了一个持久的属性集，`Properties`可保存在流中或从流中加载。

* `public Properties()`: 创建一个空的属性列表。
* `public Object setProperty(String key, String value)`: 保存一对属性，等于调用Hashtable的方法put。
* `public String getProperty(String key)`: 使用此属性列表中指定的键搜索属性值。通过key找到value值，此方法相当于Map集合中的get(key)方法。
* `public Set<String> stringPropertyNames()`: 所有键的名称的集合。返回此属性列表中的键集，其中该键及其对应值是字符串，此方法相当于Map集合中的keySet方法。

```java
public class Demo01Properties {
    public static void main(String[] args) {
        // 创建Properties集合对象
        Properties prop = new Properties();
        // 使用setProperty往集合中添加数据
        prop.setProperty("迪丽热巴", "168");
        prop.setProperty("古力娜扎", "165");
        prop.setProperty("稀里哗啦", "169");

        // 使用stringPropertyNames把Properties集合中的键取出，存储到一个set集合中
        Set<String> set = prop.stringPropertyNames();
        
        // 遍历Set集合，取出Properties集合中的每一个键
        for (String key : set) {
            // 使用getProperty方法通过key获取value
            String value = prop.getProperty(key);
            System.out.println(key + " = " + value);

        }
    }
}
```

`Properties`集合是一个唯一和IO流相结合的集合

* 可以使用`Properties`集合中的方法`store`，把集合中的临时数据，持久化写入到硬盘中存储。

  `void store(OutputStream out， String comments)` 字节输入流，不能使用中文
  `void store(Writer writer, String comments)` 字符输入流，可以使用中文。
  `String comments`：注释，用来解释说明保存的文件是做什么用的，在保存的文件中的第一行会显示。不能使用中文，会乱码，因为计算机默认的是Unicode编码。一般使用“ ”空字符串

  ```java
  public class Demo02Properties {
      public static void main(String[] args) throws IOException {
          // 1.创建Properties集合对象,添加数据
          Properties prop = new Properties();
          prop.setProperty("迪丽热巴", "168");
          prop.setProperty("古力娜扎", "165");
          prop.setProperty("稀里哗啦", "169");
  
          // 创建字节输出流对象，不用释放资源，因为匿名，所以直接会释放资源的
          // 因为是字节输出流，并且不能使用中文，可是之前有中文，所以会出现乱码
          prop.store(new FileOutputStream("09_IOAndProperties\\prop2.txt"), " ");
      }
  }
  ```

* 可以使用`Properties`集合中的方法`load`，把硬盘中保存的文件(键值对)，读取到集合中使用。

  `void load(InputStream inStream)` 字节输入流，不能读取含有中文键值对的文件
  `void load(Reader reader)` 字符输入流，可以读取含有中文键值对的文件

  ```properties
  # properties文件
  package=com.linxuan.demo01.Student
  method=out
  ```

  ```java
  public class Demo03Properties {
      public static void main(String[] args) throws IOException {
          // 创建Properties集合对象
          Properties prop = new Properties();
          // 使用Properties集合中的方法load读取保存键值对的文件
          prop.load(new FileReader("D:\\linxuan.properties"));
          // 遍历Properties集合
          Set<String> set = prop.stringPropertyNames();
          for (String key : set) {
              String value = prop.getProperty(key);
              System.out.println(key + "=" + value);
          }
      }
  }
  ```

  * 存储键值对的文件中，键与值默认的连接符号可以使用=，空格（其他符号）。
  * 存储键值对的文件中，可以使用#进行注释，被注释的键值对不会再被读取。
  * 存储键值对的文件中，键与值默认都是字符串，不用再加引号

# 第三章  Collections

`java.utils.Collections`是集合工具类，用来对集合进行操作。部分方法如下：

- `public static <T> boolean addAll(Collection<T> c, T... elements)  `:往集合中添加一些元素。
- `public static void shuffle(List<?> list) 打乱顺序`:打乱集合顺序。
- `public static <T> void sort(List<T> list)`:将集合中元素按照默认规则排序。
- `public static <T> void sort(List<T> list，Comparator<? super T> )`:将集合中元素按照指定规则排序。

代码演示：

```java
public class CollectionsDemo {
    public static void main(String[] args) {
        ArrayList<Integer> list = new ArrayList<Integer>();
        //原来写法
        //list.add(12);
        //list.add(14);
        //list.add(15);
        //list.add(1000);
        //采用工具类 完成 往集合中添加元素  
        Collections.addAll(list, 5, 222, 1, 2);
        System.out.println(list);
        //排序方法 
        Collections.sort(list);
        System.out.println(list);
    }
}
结果：
[5, 222, 1, 2]
[1, 2, 5, 222]
```

代码演示之后 ，发现我们的集合按照顺序进行了排列，可是这样的顺序是采用默认的顺序，如果想要指定顺序就需要使用这个方法了，`public static <T> void sort(List<T> list，Comparator<? super T> )`：将集合中元素按照指定规则排序。

说到排序，简单的说就是两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用`java.lang.Comparable`接口去实现，一种是灵活的当我需要做排序的时候在去选择的`java.util.Comparator`接口完成。

## 4.1 Comparable接口

我们采用的`public static <T> void sort(List<T> list)`这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上如下：

```java
public final class String implements java.io.Serializable, Comparable<String>, CharSequence {}
```

**Comparable**：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。

创建一个学生类，存储到ArrayList集合中完成指定排序操作。Student 初始类

~~~java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Student{
    private String name;
    private int age;

}
~~~

测试类：

~~~java
public class Demo {
    public static void main(String[] args) {
        // 创建四个学生对象 存储到集合中
        ArrayList<Student> list = new ArrayList<Student>();

        list.add(new Student("rose",18));
        list.add(new Student("jack",16));
        list.add(new Student("abc",16));
        list.add(new Student("ace",17));
        list.add(new Student("mark",16));

        /*
          让学生 按照年龄排序 升序
         */
//        Collections.sort(list);//要求 该list中元素类型  必须实现比较器Comparable接口


        for (Student student : list) {
            System.out.println(student);
        }

    }
}
~~~

发现，当我们调用Collections.sort()方法的时候 程序报错了。原因：如果想要集合中的元素完成排序，那么必须要实现比较器Comparable接口。

于是我们就需要完成Student类的一个实现，如下：

~~~java
public class Student implements Comparable<Student>{
    ....
    @Override
    public int compareTo(Student o) {
        return this.age-o.age;//升序
    }
}
~~~

再次测试，代码就OK 了。

String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码，这是不可能的了。

那么这个时候我们可以使用`public static <T> void sort(List<T> list，Comparator<? super T> )`方法灵活的完成，这个里面就涉及到了Comparator这个接口，位于位于java.util包下。

## 4.1 Comparator比较器

排序是comparator能实现的功能之一，该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是：

* ` public int compare(String o1, String o2)`：比较其两个参数的顺序。

  两个对象比较的结果有三种：大于，等于，小于。

  如果要按照升序排序，则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）
  如果要按照降序排序，则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数）

**Comparator**强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。

```java
public class CollectionsDemo3 {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<String>();
        list.add("cba");
        list.add("aba");
        list.add("sba");
        list.add("nba");
        //排序方法  按照第一个单词的降序
        Collections.sort(list, new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                return o2.charAt(0) - o1.charAt(0);
            }
        });
        System.out.println(list);
    }
}
[sba, nba, cba, aba]
```

在上面的案例中，如果在使用的时候，想要独立的定义规则去使用 可以采用`Collections.sort(List list,Comparetor<T> c)`方式，自己定义规则：

~~~java
Collections.sort(list, new Comparator<Student>() {
    @Override
    public int compare(Student o1, Student o2) {
        return o2.getAge()-o1.getAge();//以学生的年龄降序
    }
});
~~~

~~~java
Student{name='rose', age=18}
Student{name='ace', age=17}
Student{name='jack', age=16}
Student{name='abc', age=16}
Student{name='mark', age=16}
~~~

如果想要规则更多一些，可以参考下面代码：

~~~java
Collections.sort(list, new Comparator<Student>() {
    @Override
    public int compare(Student o1, Student o2) {
        // 年龄降序
        int result = o2.getAge()-o1.getAge();//年龄降序

        if(result==0){//第一个规则判断完了 下一个规则 姓名的首字母 升序
            result = o1.getName().charAt(0)-o2.getName().charAt(0);
        }

        return result;
    }
});
~~~

效果如下：

~~~java
Student{name='rose', age=18}
Student{name='ace', age=17}
Student{name='abc', age=16}
Student{name='jack', age=16}
Student{name='mark', age=16}
~~~

# 第四章 Iterator迭代器

在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口`java.util.Iterator`。`Iterator`接口也是Java集合中的一员，但它与`Collection`、`Map`接口有所不同，`Collection`接口与`Map`接口主要用于存储元素，而`Iterator`主要用于迭代访问（即遍历）`Collection`中的元素，因此`Iterator`对象也被称为迭代器。

想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：`public Iterator iterator()`: 获取集合对应的迭代器，用来遍历集合中的元素的。

**迭代**：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。

Iterator接口的常用方法如下：

* `public E next()`:返回迭代的下一个元素。
* `public boolean hasNext()`:如果仍有元素可以迭代，则返回 true。

~~~java
public class IteratorDemo {
  	public static void main(String[] args) {
        // 使用多态方式 创建对象
        Collection<String> coll = new ArrayList<String>();

        // 添加元素到集合
        coll.add("串串星人");
        coll.add("吐槽星人");
        coll.add("汪星人");
        //遍历
        //使用迭代器 遍历   每个集合对象都有自己的迭代器
        Iterator<String> it = coll.iterator();
        //  泛型指的是 迭代出 元素的数据类型
        while(it.hasNext()){ //判断是否有迭代元素
            String s = it.next();//获取迭代出的元素
            System.out.println(s);
        }
  	}
}
~~~

> 在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。

## 4.1 迭代器的实现原理

我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。

Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程：

![](D:\Java\笔记\图片\1-02【集合】\7-1迭代器.png)

在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。

## 4.2 增强for

增强for循环(也称for each循环)是**JDK1.5**以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。

格式：

~~~java
for(元素的数据类型  变量 : Collection集合or数组){ 
  	//写操作代码
}
~~~

它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。

# 第五章 扩展

## 5.2 JDK9对集合添加的优化

通常，我们在代码中创建一个集合（例如，List或者Set），并直接用一些元素填充它，实例化集合，几个add方法调用，是的代码重复。

**集合往里面添加元素，单列集合使用add；双列集合Map可以使用put方法。**

**代码如下：**

```java
import java.util.List;
import java.util.ArrayList;

public class Demo04 {

    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("abc");
        list.add("def");
        list.add("ghi");
        System.out.println(list);
    }
}
```

但是，如上代码所示，这种方法有点麻烦，一次只能添加一个元素。

Java 9，添加了几种集合工厂方法，更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可以更加方便的创建集合的不可变实例。

**特性：**

​	List接口， Set接口，Map接口，里面增加了一个静态的方法of，可以给集合一次性添加多个元素

**实例：**

​	static<E> List<E> of (E... elements)

**使用前提：**

​	当集合中存储的元素的个数已经确定了，不再改变时使用

**注意：**

1. of方法只适用于List接口，Set接口，Map接口，不适用于接口的实现类（ArrarList, HashSet, HashMap）。
2. of方法的返回值是一个不能改变的集合，集合不能再使用add，put方法添加元素，会抛出异常。
3. Set接口和Map接口在调用of方法的时候，不能有重复的元素，否则会抛出异常。
4. of方法前面没有new。

**代码如下：**

```java
import java.util.List;
import java.util.Map;
import java.util.Set;

public class Demo01JDK9 {

    public static void main(String[] args) {
        List<String> list = List.of("a", "b", "a", "c", "d");
        System.out.println(list);
        // list.add("w");// UnsupportedOperationException 不支持操作异常

        // Set<String> set =Set.of("a", "b", "a", "c", "d");// IllegalArgumentException 非法参数异常 有重复的元素
        Set<String> set =Set.of("a", "b", "c", "d");
        System.out.println(set);
        // set.add("w");// UnsupportedOperationException 不支持操作异常

        // Map<String, Integer> map = Map.of("张三", 18, "李四", 19, "王五", 20, "张三", 19);// IllegalArgumentException 非法参数异常 有重复的元素
        Map<String, Integer> map = Map.of("张三", 18, "李四", 19, "王五", 20);// IllegalArgumentException 非法参数异常 有重复的元素
        System.out.println(map);
        // map.put("赵四", 30);// UnsupportedOperationException 不支持操作异常
    }
}
```
