# 第一章 Python基础

![](D:\Java\笔记\图片\5-03【Python】\1.png)

## 1.1 基础语法

**数值类型**

Python中常用的有6种值（数据）的类型：

| 类型               | 描述                                                         | 说明                                                         |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 数字（Number）     | 整数（int）、浮点数（float）、<br />复数（complex）、布尔（bool） | 复数（complex），如：4+3j，以j结尾表示复数。<br />布尔（bool）True表示真，False表示假。<br />True本质上是一个数字记作1，False记作0 |
| 字符串（String）   | 描述文本的一种数据类型                                       | 字符串（string）由任意数量的字符组成。加上`“ ”`              |
| 列表（List）       | 有序的可变序列                                               | Python中使用最频繁的数据类型，可有序记录一堆数据             |
| 元组（Tuple）      | 有序的不可变序列                                             | 可有序记录一堆不可变的Python数据集合                         |
| 集合（Set）        | 无序不重复集合                                               | 可无序记录一堆不重复的Python数据集合                         |
| 字典（Dictionary） | 无序Key-Value集合                                            | 可无序记录一堆Key-Value型的Python数据集合                    |

------

**注释**

* 单行注释：以 `#`开头，`#`右边 的所有文字当作说明，而不是真正要执行的程序，起辅助说明作用
* 多行注释： 以 一对三个双引号引起来 `"""注释内容"""`来解释说明一段代码的作用使用方法

------

**变量**

在程序运行时，能储存计算结果或能表示值的抽象概念。简单的说，变量就是在程序运行时，记录数据用的。变量的定义格式：`变量名称 = 变量的值`。变量没有类型，字符串变量表示变量存储了字符串而不是表示变量就是字符串。

变量的命名规范：见名知意、下划线命名法、英文字母全小写。

变量的作用域是变量的作用范围（变量在哪里可用，在哪里不可用），主要分为两类：局部变量和全局变量

* 局部变量是定义在函数体内部的变量，即只在函数体内部生效。在函数体内部，临时保存数据，即当函数调用完成后，则销毁局部变量

* 全局变量是在函数体内、外都能生效的变量。使用 `global`关键字 可以在函数内部声明变量为全局变量。

  ```python
  num = 100
  
  def test1():
      print(num)
  
  def test2():
      num = 200
      print(num)
  
  test1()
  test2()
  print(f'全局变量num = {num}')
  """
  100
  200
  全局变量num = 100
  """
  ```

  ```python
  num = 100
  
  def test1():
      print(num)
  
  def test2():
      global num
      num = 200
      print(num)
  
  test1()
  test2()
  print(f'全局变量num = {num}')
  
  """
      100
      200
      全局变量num = 200
  """
  ```

------

**数据类型**

| 类型   | 描述             | 说明                              |
| ------ | ---------------- | --------------------------------- |
| string | 字符串类型       | 用引号引起来的数据都是字符串      |
| int    | 整型（有符号）   | 数字类型，存放整数 如 -1,10, 0 等 |
| float  | 浮点型（有符号） | 数字类型，存放小数 如 -3.14, 6.66 |

我们可以通过`type()`语句来得到数据的类型：`type(被查看类型的数据)`

------

类型转换

| 语句(函数) | **说明**             |
| ---------- | -------------------- |
| int(x)     | 将x转换为一个整数    |
| float(x)   | 将x转换为一个浮点数  |
| str(x)     | 将对象x 转换为字符串 |

同前面学习的`type()`语句一样，这三个语句，都是带有结果的（返回值）我们可以用`print`直接输出或用变量存储结果值。

类型转换不是万能的，毕竟强扭的瓜不会甜，我们需要注意：

1. 任何类型，都可以通过str()，转换成字符串
2. 字符串内必须真的是数字，才可以将字符串转换为数字

------

**标识符**

在Python程序中，我们可以给很多东西起名字，比如：变量的名字、方法的名字、类的名字,等等。这些名字，我们把它统一的称之为标识符，用来做内容的标识。

标识符：是用户在编程的时候所使用的一系列名字，用于给变量、类、方法等命名。

Python中，标识符命名的规则主要有3类：内容限定、大小写敏感、不可使用关键字。

* 内容限定：标识符命名中，只允许出现英文、中文、数字、下划线（_）这四类元素。其余任何内容都不被允许。
* 大小写敏感：以定义变量为例`Andy = “安迪1”`和 `andy = “安迪2”`字母a的大写和小写，是完全能够区分的。
* 不可使用关键字。False、True、None、and、asassert、 break 、class、continue、 def、del、elif else、 except、 finally 、for 、from、global、if、import、in、is 、lambda、 non、local、not、or、pass、raise、return、try、while 、with、 yield。

------

**运算符**

算术（数学）运算符

| 运算符 | 描述   | 实例 （a = 10, b = 20）                                     |
| ------ | ------ | ----------------------------------------------------------- |
| +      | 加     | 两个对象相加a + b 输出结果30                                |
| -      | 减     | 得到负数或是一个数减去另一个数a - b 输出结果 -10            |
| *      | 乘     | 两个数相乘或是返回一个被重复若干次的字符串a * b 输出结果200 |
| /      | 除     | b /a 输出结果 2                                             |
| //     | 取整除 | 返回商的整数部分9//2 输出结果4 , 9.0//2.0 输出结果4.0       |
| %      | 取余   | 返回除法的余数b % a 输出结果0                               |
| **     | 指数   | a**b为10的20次方，输出结果 100000000000000000000            |

赋值运算符

| **运算符** | **描述**   | **实例**                                                     |
| ---------- | ---------- | ------------------------------------------------------------ |
| =          | 赋值运算符 | 把 =号右边的结果 赋给 左边的变量，如 num= 1 + 2 * 3，结果num的值为7 |

复合赋值运算符

| **运算符** | **描述**         | **实例**                |
| ---------- | ---------------- | ----------------------- |
| +=         | 加法赋值运算符   | c+= a 等效于 c =c + a   |
| -=         | 减法赋值运算符   | c-= a 等效于 c =c - a   |
| *=         | 乘法赋值运算符   | c*= a 等效于 c =c * a   |
| /=         | 除法赋值运算符   | c/= a 等效于 c =c / a   |
| %=         | 取模赋值运算符   | c%= a 等效于 c =c % a   |
| **=        | 幂赋值运算符     | c**= a 等效于 c =c ** a |
| //=        | 取整除赋值运算符 | c//= a 等效于 c =c // a |

------

**字符串扩展**

字符串在Python中有多种定义形式：

- 单引号定义法：`name = 'linxuan'`
- 双引号定义法：`name = "linxuan"`
- 三引号定义法：`name = """linxuan"""`。三引号定义法，和多行注释的写法一样，同样支持换行操作。使用变量接收它，它就是字符串。不使用变量接收它，就可以作为多行注释使用。

单引号定义法，可以内含双引号；双引号定义法，可以内含单引号；可以使用转移字符（`\`）来将引号解除效用，变成普通字符串。

如果我们有两个字符串（文本）字面量，可以将其拼接成一个字符串，通过`+`号即可完成。另外记住无法和非字符串类型进行拼接。

我们可以`%s`完成字符串和变量的快速拼接，`%`表示我要占位，`s` 表示将变量变成字符串放入占位的地方。

```python
name = "linxuan"
message = "我是 %s " % name
print(message) # 我是 linxuan 
```

多个变量占位，变量要用括号括起来，并按照占位的顺序填入。数字类型可以使用`%s`占位，但是这样将数字转换成了字符串。

| 格式符号 | 转化                             |
| -------- | -------------------------------- |
| %s       | 将内容转换成字符串，放入占位位置 |
| %d       | 将内容转换成整数，放入占位位置   |
| %f       | 将内容转换成浮点型，放入占位位置 |

如果使用`%f`来占位需要注意一下数字的精度：

```python
message = "浮点数：%f" % 19.9
print(message) # 浮点数：19.900000
```

我们可以使用辅助符号"`m.n`"来控制数据的宽度和精度：`m`控制宽度，要求是数字（很少使用），设置的宽度小于数字自身，不生效；`.n`，控制小数点精度，要求是数字，会进行小数的四舍五入。1.可以通过

可以通过`f”{变量} {变量}”`的方式进行快速格式化。这种方式•不理会类型、不做精度控制、适合对精度没有要求的时候快速使用。

```python
name = "linxuan"
age = 19.0
print(f"我是{name}, 年龄为{age}") # 我是linxuan, 年龄为19.0
```

------

**数据输入**

我们前面学习过print语句（函数），可以完成将内容（字面量、变量等）输出到屏幕上。在Python中，与之对应的还有一个input语句，用来获取键盘输入。

- 数据输出：print：打印内容

- 数据输入：input：使`用input()`语句可以从键盘获取输入，使用一个变量接收（存储）input语句获取的键盘输入数据即可。`input()`语句也可以在要求使用者输入内容前，输出提示内容的。无论键盘输入何种类型的数据
  最终的结果都是字符串类型的数据。

  ```python
  name = input("你的名字是什么？")
  print("你的名字：%s" % name)
  # 控制台输出：
  # 你的名字是什么？韦一敏
  # 你的名字：韦一敏
  ```

## 1.2 判断语句

布尔类型的字面量：True表示真（是、肯定）、False 表示假 （否、否定）。

| **运算符** | **描述**                                                    | **示例**                    |
| ---------- | ----------------------------------------------------------- | --------------------------- |
| ==         | 判断内容是否相等，满足为True，不满足为False                 | 如a=3,b=3，则(a== b)为True  |
| !=         | 判断内容是否不相等，满足为True，不满足为False               | 如a=1,b=3，则(a!= b) 为True |
| >          | 判断运算符左侧内容是否大于右侧满足为True，不满足为False     | 如a=7,b=3，则(a> b)为 True  |
| <          | 判断运算符左侧内容是否小于右侧满足为True，不满足为False     | 如a=3,b=7，则(a< b)为 True  |
| >=         | 判断运算符左侧内容是否大于等于右侧满足为True，不满足为False | 如a=3,b=3，则(a>= b) 为True |
| <=         | 判断运算符左侧内容是否小于等于右侧满足为True，不满足为False | 如a=3,b=3，则(a<= b) 为True |

`if`语句的基本格式：判断条件的结果一定要是布尔类型。不要忘记判断条件后的`:`引号。归属于if语句的代码块，需在前方填充4个空格缩进。

```python
if 要判断的条件:
	条件成立的时候要做的事情
```

`if else`语句的基本格式：`else`后，不需要判断条件。和`if`的代码块一样，`else`的代码块同样需要4个空格作为缩进。

```python
if 要判断的条件:
	条件成立的时候要做的事情
else:
	条件不成立的时候执行
```

`if elif else`语句：`elif` 语句可以写多个。

```python
if 条件1:
	条件1成立的时候要做的事情
elif 条件2:
	条件1成立的时候要做的事情
else:
	条件都不成立的时候执行
```

## 1.3 循环语句

**while循环**

while循环只要是条件满足，那么一直循环。

```python
while 条件:
	条件满足的时候做的事情1
	条件满足的时候做的事情2
	...
```

**for循环**

while循环的循环条件是自定义的，自行控制循环条件。for循环是一种”轮询”机制，是对一批内容进行”逐个处理”。

```python
for 临时变量 in 待处理数据集: 
    循环满足条件时执行的代码
```

```python
# 定义字符串name
name = "linxuan"
# for循环处理字符串
for x in name:
    print(x)
```

```python
for 临时变量 in 待处理数据集(可迭代对象): 
    循环满足条件时执行的代码
```

for循环语句，本质上是遍历可迭代对象。语法中的待处理数据集，严格来说称之为可迭代类型。可迭代类型指，其内容可以一个个依次取出的一种类型，包括：字符串、列表、元组等。

range语句：获得一个数字序列（可迭代类型的一种）

* `range(num)`：获取一个从0开始，到num结束的数字序列（不含num本身）。如range(5)取得的数据是：[0, 1, 2, 3, 4]。
* `range(num1, num2)`：获得一个从num1开始，到num2结束的数字序列（不含num2本身）。如，range(5, 10)取得的数据是：[5, 6, 7, 8, 9]。
* `range(num1, num2), step`：获得一个从num1开始，到num2结束的数字序列（不含num2本身），数字之间的步长，以step为准（step默认为1）。如，range(5, 10, 2)取得的数据是：[5, 7, 9]

```python
num = 32
print("打印序列为：", end=" ")

for i in range(num):
    if i % 2 == 0:
        print(i, end=" ") # 打印序列为： 0 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 
```

Python提供continue和break关键字，用以对循环进行临时跳过和直接结束。

* continue关键字只可以控制：它所在的循环临时中断
* break关键字同样只可以控制：它所在的循环永久中断

```python
for i in range(5):
    if i == 3:
        continue
    else:
        print(i, end=" ") # 0 1 2 4 
```

```python
for i in range(5):
    if i == 3:
        break
    else:
        print(i, end=" ") # 0 1 2 
```

## 1.4 函数

### 1.4.1 函数基础

函数是组织好的，可重复使用的，用来实现特定功能的代码段。我们使用过的`input()`、`print()`、`str()`、`int()`等都是Python的内置函数。

函数的定义：

```python
def 函数名称(传入参数):
    函数体
    return 返回值
```

函数的调用：`函数名(参数)`。

- 参数如不需要，可以省略
- 返回值如不需要，可以省略
- 函数必须先定义后使用

```python
# 定义函数
def add(x, y):
    return x + y

# 调用函数
print(add(1, 2))
```

函数的返回值为none类型：如果函数没有使用`return`语句返回数据，那么函数有none类型的返回值。None可以主动使用return返回，效果等同于不写return语句。例如：`return None`。

Python中有一个特殊的字面量：`None`，其类型是：`<class 'NoneType'>`无返回值的函数，实际上就是返回了`None`这个字面量。`None`表示：空的、无实际意义的意思。函数返回的`None`，就表示，这个函数没有返回什么有意义的内容。也就是返回了空的意思。

None作为一个特殊的字面量，用于表示：空、无意义，其有非常多的应用场景。

* 用在函数无返回值上
* 用在if判断上。在if判断中，`None`等同于`False`。一般用于在函数中主动返回`None`，配合`if`判断做相关处理
* 用于声明无内容的变量上。定义变量，但暂时不需要变量有具体值，可以用`None`来代替。

函数是纯代码语言，想要理解其含义，就需要一行行的去阅读理解代码，效率比较低。我们可以给函数添加说明文档，辅助理解函数的作用。语法如下：

```python
# 定义函数
def func(x, y):
    # 通过多行注释的形式，对函数进行说明解释
    """
    :param x: 形参x的说明
    :param y: 形参y的说明
    :return: 返回值的说明
    两数相加
    """
    return 返回值
```

### 1.4.2 函数进阶

如果一个函数要有多个返回值，那么我们按照返回值的顺序，写对应顺序的多个变量接收即可。变量之间用逗号隔开、支持不同类型的数据return。

```python
def test_return():
    return 1, 2

x, y = test_return()
print(f"x的值是{x}, y的值是{y}") # x的值是1, y的值是2
```

**函数多种传参方式**

函数有4中常见参数使用方式：位置参数、关键字参数、缺省参数、不定长参数。

* 位置参数：调用函数时根据函数定义的参数位置来传递参数。 传递的参数和定义的参数的顺序及个数必须一致。

  ```python
  def username(name1, name2, name3):
      print(name1, end=" ")
      print(name2, end=" ")
      print(name3, end=" ")
  
  username("林炫", "陈沐阳", "云双端")  # 林炫 陈沐阳 云双端
  ```

* 关键字参数：函数调用时通过“键=值”形式传递参数。可以让函数更加清晰，同时也清除了参数的顺序需求。函数调用时，如果有位置参数时，位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序。

  ```python
  def username(name1, name2, name3):
      print(name1, end=" ")
      print(name2, end=" ")
      print(name3, end=" ")
  
  # 关键字传参，可以不按照固定顺序
  username(name1="林炫", name3="陈沐阳", name2="云双端")  # 林炫 云双端 陈沐阳 
  # 可以和位置参数混合使用，位置参数在前，匹配参数顺序
  username("林炫", name2="陈沐阳", name3="云双端")  # 林炫 陈沐阳 云双端 
  ```

* 缺省参数：缺省参数也叫默认参数。用于定义函数，为参数提供默认值，调用函数时可不传该默认参数的值（注意：所有位置参数必须出现在默认参数前，包括函数定义和调用）。当调用函数时没有传递参数, 就会使用默认是用缺省参数对应的值。

  ```python
  def user_info(name, age, gender='男'):
      print(f"您的名字是{name}, 年龄是{age}, 性别是{gender}")
  
  
  user_info('林炫', 20)  # 您的名字是林炫, 年龄是20, 性别是男
  user_info("Rose", 18, '女')  # 您的名字是Rose, 年龄是18, 性别是女
  ```

* 不定长参数：不定长参数也叫可变参数. 用于不确定调用的时候会传递多少个参数(不传参也可以)的场景。当调用函数时不确定参数个数时, 可以使用不定长参数。
  不定长参数的类型:

  1. 位置传递

     ```python
     def user_info(*args):
         print(args)
     
     user_info("TOM")  # ('TOM',)
     user_info("TOM", 18)  # ('TOM', 18)
     ```

     传进的所有参数都会被args变量收集，它会根据传进参数的位置合并为一个元组(tuple)，args是元组类型，这就是位置传递

  2. 关键字传递

     ```python
     def user_info(**kwargs):
         print(kwargs)
     
     user_info(name="TOM", age=18, id=110)  # {'name': 'TOM', 'age': 18, 'id': 110}
     ```

     参数是“键=值”形式的形式的情况下, 所有的“键=值”都会被kwargs接受, 同时会根据“键=值”组成字典.

**函数作为参数传递**

在前面的函数学习中，我们一直使用的函数，都是接受数据作为参数传入：数字、字符串、字典、列表、元组等。其实，我们学习的函数本身，也可以作为参数传入另一个函数内。

```python
def test_func(compute):
    result = compute(1, 2)
    print(result)

def compute(x, y):
    return x + y

test_func(compute)
```

函数`compute`，作为参数，传入了`test_func`函数中使用。这是一种计算逻辑的传递，而非数据的传递。

- `test_func`需要一个函数作为参数传入，这个函数需要接收2个数字进行计算，计算逻辑由这个被传入函数决定。
- `compute`函数接收2个数字对其进行计算，`compute`函数作为参数，传递给了`test_func`函数使用
- 最终，在`test_func`函数内部，由传入的`compute`函数，完成了对数字的计算操作

**lambda匿名函数**

函数的定义中：

- def关键字，可以定义带有名称的函数。有名称的函数，可以基于名称重复使用。
- lambda关键字，可以定义匿名函数（无名称）。无名称的匿名函数，只可临时使用一次。

匿名函数定义语法：`lambda 传入参数: 函数体(一行代码)`。

- lambda 是关键字，表示定义匿名函数。
- 传入参数表示匿名函数的形式参数，如：x, y 表示接收2个形式参数。
- 函数体，就是函数的执行逻辑，要注意：只能写一行，无法写多行代码。

```python
def test_func(compute):
    result = compute(1, 2)
    print(result)

test_func(lambda x, y: x + y)  # 3
```

## 1.5 数据容器

学习数据容器，就是为了批量存储或批量使用多份数据。

Python中的数据容器：一种可以容纳多份数据的数据类型，容纳的每一份数据称之为1个元素。每一个元素，可以是任意类型的数据，如字符串、数字、布尔等。

数据容器根据特点的不同，如是否支持重复元素、是否可以修改、是否有序等分为5类。分别是：列表（list）、元组（tuple）、字符串（str）、集合（set）、字典（dict）。

```python
type(数据/数据类型)查看数据类型
```

数据容器可以从以下视角进行简单的分类：

- 是否支持下标索引
  - 支持：列表、元组、字符串 - 序列类型
  - 不支持：集合、字典 - 非序列类型
- 是否支持重复元素：
  - 支持：列表、元组、字符串 - 序列类型
  - 不支持：集合、字典 - 非序列类型
- 是否可以修改
  - 支持：列表、集合、字典
  - 不支持：元组、字符串

|          | **列表** | **元组** | **字符串** | **集合** | **字典**                             |
| -------- | -------- | -------- | ---------- | -------- | ------------------------------------ |
| 元素数量 | 支持多个 | 支持多个 | 支持多个   | 支持多个 | 支持多个                             |
| 元素类型 | 任意     | 任意     | 仅字符     | 任意     | Key：除字典外任意类型Value：任意类型 |
| 下标索引 | 支持     | 支持     | 支持       | 不支持   | 不支持                               |
| 重复元素 | 支持     | 支持     | 支持       | 不支持   | 不支持                               |
| 可修改性 | 支持     | 不支持   | 不支持     | 支持     | 支持                                 |
| 数据有序 | 是       | 是       | 是         | 否       | 否                                   |

| **功能**                     | **描述**                                       |
| ---------------------------- | ---------------------------------------------- |
| 通用for循环                  | 遍历容器（字典是遍历key）                      |
| max                          | 容器内最大元素                                 |
| min()                        | 容器内最小元素                                 |
| len()                        | 容器元素个数                                   |
| list()                       | 转换为列表                                     |
| tuple()                      | 转换为元组                                     |
| str()                        | 转换为字符串                                   |
| set()                        | 转换为集合                                     |
| sorted(序列, [reverse=True]) | 排序，reverse=True表示降序得到一个排好序的列表 |

### 1.5.1 list列表

列表一次可以存储多个数据。列表以 `[]` 作为标识，列表内的每一个数据，称之为元素，每一个元素之间用`,` 逗号隔开。

```python
# 字面量
[元素1, 元素2, 元素3, 元素4, ...]

# 定义变量
变量名称 = [元素1, 元素2, 元素3, 元素4, ....]

# 定义空列表
变量名称 = []
变量名称 = list()
```

列表可以一次存储多个数据，且可以为不同的数据类型，支持嵌套。

我们可以使用下标索引从列表中取出特定位置的数据。列表中的每一个元素，都有其位置下标索引，从前向后的方向，从0开始依次递增。或者可以反向索引，也就是从后向前，从-1开始依次递减（-1、-2、-3......）。语法：`列表[下标索引]`

如果列表是嵌套的列表，同样支持下标索引。语法：`列表[下标索引][下标索引]`

```python
name_list = ['linxuan', 'chenmuyang', ['123', '321']]

print(name_list[0], end=" ")
print(name_list[1], end=" ")
print(name_list[2][0], end=" ")
print(name_list[2][1], end=" ")
# linxuan chenmuyang 123 321 
```

列表也提供了一系列功能：插入元素、删除元素、清空列表、修改元素、统计元素个数、等等功能，这些功能我们都称之为列表的方法。

函数是一个封装的代码单元，可以提供特定功能。在Python中，如果将函数定义为`class`（类）的成员，那么函数会称之为方法。方法和函数功能一样， 有传入参数，有返回值，只是方法的使用格式不同。和Java一样，生成对象，调用对象方法。

常用方法如下：

| **编号** | **使用方式**            | **作用**                                     |
| -------- | ----------------------- | -------------------------------------------- |
| 1        | 列表.append(元素)       | 向列表中追加一个元素                         |
| 2        | 列表.extend(容器)       | 将数据容器的内容依次取出，追加到列表尾部     |
| 3        | 列表.insert(下标, 元素) | 在指定下标处，插入指定的元素                 |
| 4        | del 列表[下标]          | 删除列表指定下标元素                         |
| 5        | 列表.pop(下标)          | 删除列表指定下标元素                         |
| 6        | 列表.remove(元素)       | 从前向后，删除此元素第一个匹配项             |
| 7        | 列表.clear()            | 清空列表                                     |
| 8        | 列表.count(元素)        | 统计此元素在列表中出现的次数                 |
| 9        | 列表.index(元素)        | 查找指定元素在列表的下标找不到报错ValueError |
| 10       | len(列表)               | 统计容器内有多少元素                         |

既然数据容器可以存储多个元素，那么，就会有需求从容器内依次取出元素进行操作。将容器内的元素依次取出进行处理的行为，称之为遍历、迭代。

```python
name_list = ['linxuan', 'chenmuyang', ['123', '321']]

for name in name_list:
    print(name, end=" ") # linxuan chenmuyang ['123', '321'] 
```

### 1.5.2 tuple元组

列表是可以修改的。如果想要传递的信息不被篡改，列表就不合适了。

元组同列表一样，都是可以封装多个、不同类型的元素在内。但最大的不同点在于：元组一旦定义完成，就不可修改。所以，当我们需要在程序内封装数据，又不希望封装的数据被篡改，那么元组就非常合适了。

元组定义：定义元组使用小括号，且使用逗号隔开各个数据，数据可以是不同的数据类型。

```python
# 定义元组字面量
(元素1, 元素2, 元素3, 元素4, ...)

# 定义元组变量
变量名称 = (元素1, 元素2, 元素3, 元素4, ....)

# 定义空元组
变量名称 = ()
变量名称 = tuple()
```

```python
# 定义三个元素的元组
t1 = (1, 'hello', True)

# 定义一个元素的元组 只有一个数据也要添加逗号
t2 = ('hello', )
```

```python
# 定义一个嵌套元组
t1 = ((1, 2, 3), (4, 5, 6))
print(t1[0][0]) # 结果为1
```

元组由于不可修改的特性，所以其操作方法非常少。

| **编号** | **方法**  | **作用**                                           |
| -------- | --------- | -------------------------------------------------- |
| 1        | index()   | 查找某个数据，如果数据存在返回对应的下标，否则报错 |
| 2        | count()   | 统计某个数据在当前元组出现的次数                   |
| 3        | len(元组) | 统计元组内的元素个数                               |

注意事项：

* 不可以修改元组的内容，否则会直接报错
* 可以修改元组内的list的内容（修改元素、增加、删除、反转等）
* 不可以替换list为其它list或其它类型

同列表一样，元组也可以被遍历。可以使用while循环和for循环遍历它。

### 1.5.3 str字符串

尽管字符串看起来并不像列表、元组那样，一看就是存放了许多数据的容器。但不可否认的是，字符串同样也是数据容器的一员。字符串是字符的容器，一个字符串可以存放任意数量的字符。

和其它容器列表、元组一样，字符串也可以通过下标进行访问。从前向后，下标从0开始。从后向前，下标从-1开始。

同元组一样，字符串是一个无法修改的数据容器。所以修改指定下标的字符、移除特定下标的字符、追加字符等均无法完成。如果必须要做，只能得到一个新的字符串，旧的字符串是无法修改。

常用操作：

| **编号** | **操作**                             | **说明**                                                     |
| -------- | ------------------------------------ | ------------------------------------------------------------ |
| 1        | 字符串[下标]                         | 根据下标索引取出特定位置字符                                 |
| 2        | 字符串.index(字符串）                | 查找给定字符的第一个匹配项的下标                             |
| 3        | 字符串.replace(字符串1, 字符串2)     | 将字符串内的全部字符串1，替换为字符串2  <br />不会修改原字符串，而是得到一个新的 |
| 4        | 字符串.split(字符串)                 | 按照给定字符串，对字符串进行分隔<br />不会修改原字符串，而是得到一个新的列表 |
| 5        | 字符串.strip()  字符串.strip(字符串) | 移除首尾的空格和换行符或指定字符串                           |
| 6        | 字符串.count(字符串)                 | 统计字符串内某字符串的出现次数                               |
| 7        | len(字符串)                          | 统计字符串的字符个数                                         |

### 1.5.4 序列的切片

序列是指：内容连续、有序，可使用下标索引的一类数据容器。列表、元组、字符串，均可以可以视为序列。

序列支持切片，即：列表、元组、字符串，均支持进行切片操作。

切片：从一个序列中，取出一个子序列。表示从序列中，从指定位置开始，依次取出元素，到指定位置结束，得到一个新序列。语法：`序列[起始下标:结束下标:步长]`

- 起始下标表示从何处开始，可以留空，留空视作从头开始
- 结束下标（不含）表示何处结束，可以留空，留空视作截取到结尾
- 步长表示，依次取元素的间隔。步长1表示，一个个取元素；步长2表示，每次跳过1个元素取；步长N表示，每次跳过N-1个元素取；步长为负数表示，反向取（注意，起始下标和结束下标也要反向标记）。

此操作不会影响序列本身，而是会得到一个新的序列（列表、元组、字符串）

```python
my_list = [1, 2, 3, 4, 5]
new_list1 = my_list[1:4]  # 下标1开始，下标4结束（不包含），步长1
new_list2 = my_list[::2]  # 从头开始到最后结束，步长2
new_list3 = my_list[3:1:-1]  # 从下标3开始，下标1结束（不包含），步长-1 倒序
print(new_list1)  # [2, 3, 4]
print(new_list2)  # [1, 3, 5]
print(new_list3)  # [4, 3]

my_tuple = (1, 2, 3, 4, 5)
new_tuple = my_tuple[:]  # 从头开始到最后结束，步长1
print(new_tuple)  # (1, 2, 3, 4, 5)

my_str = "12345"
new_str1 = my_str[:4:2]  # 从头开始，到下标4结束，步长2
new_str2 = my_str[::-1]  # 从头开始到最后结束，步长为-1，倒序
print(new_str1)  # 13
print(new_str2)  # 54321
```

### 1.5.5 set集合

集合最主要的特点就是：不支持元素的重复（自带去重功能）、并且内容无序。

基本语法如下：

```python
# 定义集合字面量
{元素, 元素, 元素, ..., 元素}
# 定义集合变量
变量名称 = {元素, 元素, 元素, ..., 元素}
# 定义空集合
变量名称 = set()
```

```python
my_set = {"linxuan", "chengmuyang", "yunshuangduan"}
print(my_set)  # {'chengmuyang', 'yunshuangduan', 'linxuan'}
# 结果中可见去重且无序。因为要对元素做去重处理，所以无法保证顺序和创建的时候一致
```

因为集合是无序的，所以集合不支持：下标索引访问。但是集合和列表一样，是允许修改的。

集合特点如下：可以容纳多个数据、可以容纳不同类型的数据（混装）、数据是无序存储的（不支持下标索引）、不允许重复数据存在、可以修改（增加或删除元素等）、支持for循环。

| **编号** | **操作**                       | **说明**                                                  |
| -------- | ------------------------------ | --------------------------------------------------------- |
| 1        | 集合.add(元素)                 | 集合内添加一个元素                                        |
| 2        | 集合.remove(元素)              | 移除集合内指定的元素                                      |
| 3        | 集合.pop()                     | 从集合中随机取出一个元素                                  |
| 4        | 集合.clear()                   | 将集合清空                                                |
| 5        | 集合1.difference(集合2)        | 得到一个新集合，内含2个集合的差集原有的2个集合内容不变    |
| 6        | 集合1.difference_update(集合2) | 在集合1中，删除集合2中存在的元素集合1被修改，集合2不变    |
| 7        | 集合1.union(集合2)             | 得到1个新集合，内含2个集合的全部元素原有的2个集合内容不变 |
| 8        | len(集合)                      | 得到一个整数，记录了集合的元素数量                        |

### 1.5.6 dict字典、映射

字典的定义，同样使用`{}`，不过存储的元素是一个个的键值对，如下语法：

- 使用{}存储原始，每一个元素是一个键值对
- 每一个键值对包含Key和Value（用冒号分隔）
- 键值对之间使用逗号分隔
- Key和Value可以是任意类型的数据（key不可为字典）
- Key不可重复，重复会对原有数据覆盖

```python
# 定义字典字面量
{key: value, key: value, ..., key: value}
# 定义字典变量
my_dict = {key: value, key: value, ..., key: value}
# 定义空字典
my_dict = {}
my_dict = dict() 
```

字典同集合一样，不可以使用下标索引，但是字典可以通过Key值来取得对应的Value。

字典的Key和Value可以是任意数据类型（Key不可为字典）。那么就表明字典是可以嵌套的：

```python
stu_score = {
    "林炫": {"语文": 100, "数学": 100, "英语": 100},
    "陈沐阳": {"语文": 90, "数学": 70, "英语": 89},
    "云双端": {"语文": 80, "数学": 100, "英语": 78},
}

print(stu_score["林炫"])  # {'语文': 100, '数学': 100, '英语': 100}
print(stu_score["林炫"]["语文"])  # 100
print(stu_score["林炫"]["中文"])  # KeyError: '中文'
```

| **编号** | **操作**          | **说明**                                      |
| -------- | ----------------- | --------------------------------------------- |
| 1        | 字典[Key]         | 获取指定Key对应的Value值                      |
| 2        | 字典[Key] = Value | 添加或更新键值对                              |
| 3        | 字典.pop(Key)     | 取出Key对应的Value并在字典内删除此Key的键值对 |
| 4        | 字典.clear()      | 清空字典                                      |
| 5        | 字典.keys()       | 获取字典的全部Key，可用于for循环遍历字典      |
| 6        | len(字典)         | 计算字典内的元素数量                          |

字典有如下特点：可以容纳多个数据、可以容纳不同类型的数据、每一份数据是KeyValue键值对、可以通过Key获取到Value，Key不可重复（重复会覆盖）、不支持下标索引、可以修改（增加或删除更新元素等）、支持for循环，不支持while循环。

## 1.6 文件操作

内存中存放的数据在计算机关机后就会消失。要长久保存数据，就要使用硬盘、光盘、U 盘等设备。为了便于数据的管理和检索，引入了“文件”的概念。

一篇文章、一段视频、一个可执行程序，都可以被保存为一个文件，并赋予一个文件名。操作系统以文件为单位管理磁盘中的数据。一般来说，文件可分为文本文件、视频文件、音频文件、图像文件、可执行文件等多种类别。

想想我们平常对文件的基本操作，大概可以分为三个步骤（简称文件操作三步走）：打开文件、读写文件、关闭文件。

**文件的读取**

| 操作                                 | 功能                                   |
| ------------------------------------ | -------------------------------------- |
| 文件对象= open(file, mode, encoding) | 打开文件获得文件对象                   |
| 文件对象.read(num)                   | 读取指定长度字节不指定num读取文件全部  |
| 文件对象.readline()                  | 读取一行                               |
| 文件对象.readlines()                 | 读取全部行，得到列表                   |
| for line in 文件对象                 | for循环文件行，一次循环得到一行数据    |
| 文件对象.close()                     | 关闭文件对象                           |
| with open() as f                     | 通过withopen语法打开文件，可以自动关闭 |

常用方法如下：

* `open()`打开函数：在Python，使用open函数，可以打开一个已经存在的文件，或者创建一个新文件，语法如下

  ```python
  open(file, mode, encoding)
  # file：是要打开的目标文件名的字符串(可以包含文件所在的具体路径)。
  # mode：设置打开文件的模式(访问模式)：只读、写入、追加等。
  # encoding:编码格式（推荐使用UTF-8）
  ```

  ```python
  f = open('python.txt', 'r', encoding=”UTF-8)
  # encoding的顺序不是第三位，所以不能用位置参数，用关键字参数直接指定
  ```

  | **模式** | **描述**                                                     |
  | -------- | ------------------------------------------------------------ |
  | r        | 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 |
  | w        | 打开一个文件只用于写入。如果该文件存在则打开文件，并从开头开始编辑，原有内容会被删除。<br />如果该文件不存在，创建新文件。 |
  | a        | 打开一个文件用于追加。如果该文件已存在，新的内容将会被写入到已有内容之后。<br />如果该文件不存在，创建新文件进行写入。 |

* `read()`方法：`文件对象.read(num)`。num表示要从文件中读取的数据的长度（单位是字节），如果没有传入num，那么就表示读取文件中所有的数据。

* `readlines()`方法：`readlines()`可以按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个列表，其中每一行的数据为一个元素。

  ```python
  f = open('python.txt')
  content = f.readlines()
  
  # ['hello world\n', 'abcdefg\n', 'aaa\n', 'bbb\n', 'ccc']
  print(content)
  
  # 关闭文件
  f.close()
  ```

* `readline()`方法：一次读取一行内容

  ```python
  f = open('python.txt')
  
  content = f.readline()
  print(f'第一行：{content}')
  
  content = f.readline()
  print(f'第二行：{content}')
  
  # 关闭文件
  f.close()
  ```

* `close()`：关闭文件对象

* `with open` 语法：

  ```python
  with open("python.txt", "r") as f:
      f.readlines()
  
  # 通过在with open的语句块中对文件进行操作
  # 可以在操作完成后自动关闭close文件，避免遗忘掉close方法
  ```

**文件的写入**

```python
# 1. 打开文件
f = open('python.txt', 'w')

# 2.文件写入
f.write('hello world')

# 3. 内容刷新
f.flush()
```

直接调用write，内容并未真正写入文件，而是会积攒在程序的内存中，称之为缓冲区。当调用flush的时候，内容会真正写入文件。这样做是避免频繁的操作硬盘，导致效率下降（攒一堆，一次性写磁盘）。

文件如果不存在，使用”w”模式，会创建新文件；文件如果存在，使用”w”模式，会将原有内容清空。

**文件的追加**

```python
# 1. 打开文件，通过a模式打开即可
f = open('python.txt', 'a')

# 2.文件写入
f.write('hello world')

# 3. 内容刷新
f.flush()
```

a模式，文件不存在会创建文件；a模式，文件存在会在最后，追加写入文件。

## 1.7 异常

异常就是程序运行的过程中出现了错误。bug就是指异常的意思，因为历史因为小虫子导致计算机失灵的案例，所以延续至今，bug就代表软件出现错误。

世界上没有完美的程序，任何程序在运行的过程中，都有可能出现异常，也就是出现bug。导致程序无法完美运行下去。我们要做的，不是力求程序完美运行。而是在力所能及的范围内，对可能出现的bug，进行提前准备、提前处理。这种行为我们称之为：异常处理（捕获异常）。

捕获异常的作用在于提前假设某处会出现异常，做好提前准备，当真的出现异常的时候，可以有后续手段。

异常是具有传递性的。利用异常具有传递性的特点, 当我们想要保证程序不会因为异常崩溃的时候, 就可以在main函数中设置异常捕获, 由于无论在整个程序哪里发生异常, 最终都会传递到main函数中, 这样就可以确保所有的异常都会被捕获。

**捕获常规异常**

```python
try:
    可能发生错误的代码
except:
    如果出现异常执行的代码
```

```python
try:
    f = open('linux.txt', 'r')
except:
    f = open('linux.txt', 'w')
```

**捕获指定异常**

```python
try:
    print(name)
except NameError as e:
    print('name变量名称未定义错误')
```

如果尝试执行的代码的异常类型和要捕获的异常类型不一致，则无法捕获异常。一般try下方只放一行尝试执行的代码。

**捕获多个异常**

当捕获多个异常时，可以把要捕获的异常类型的名字，放到except 后，并使用元组的方式进行书写。

```python
try:
    print(1/0)
except (NameError, ZeroDivisionError):
    print('ZeroDivision错误...')
```

**捕获异常并输出描述信息**

```python
try:
    print(num)
except (NameError, ZeroDivisionError) as e:
    print(e)
```

**捕获所有异常**

```python
try:
    print(name)
except Exception as e:
    print(e)
```

**异常else**

else表示的是如果没有异常要执行的代码。

```python
try:
    print(1)
except Exception as e:
    print(e)
else:
    print('我是else，是没有异常的时候执行的代码')
```

**异常的finally**

finally表示的是无论是否异常都要执行的代码，例如关闭文件。

```python
try:
    f = open('test.txt', 'r')
except Exception as e:
    f = open('test.txt', 'w')
else:
    print('没有异常，真开心')
finally:
    f.close()
```

## 1.8 模块和包

Python 模块(Module)，是一个 Python 文件，以 `.py` 结尾.  模块能定义函数，类和变量，模块里也能包含可执行的代码。

模块的作用:  python中有很多各种不同的模块, 每一个模块都可以帮助我们快速的实现一些功能, 比如实现和时间相关的功能就可以使用time模块我们可以认为一个模块就是一个工具包, 每一个工具包中都有各种不同的工具供我们使用进而实现各种不同的功能。

模块就是一个Python文件，里面有类、函数、变量等，我们可以拿过来用（导入模块去使用）。

模块在使用前需要先导入，语法如下：

```python
[from 模块名称] import [模块 | 类 | 变量 | 函数 | *] [as 别名] 
```

常用的组合形式如：

- `import 模块名`
- `from 模块名 import 类、变量、方法等`
- `from 模块名 import *`
- `import 模块名 as 别名`
- `from 模块名 import 功能名 as 别名`

**`import模块名`**

```python
import 模块名
import 模块名1，模块名2

模块名.功能名()
```

```python
# 导入时间模块
import time

print("开始")
# 让程序睡眠1秒(阻塞)
time.sleep(1)
print("结束")
```

**`from 模块名 import 功能名`**

```python
from 模块名 import 功能名

功能名()
```

```python
# 导入时间模块中的sleep方法
from time import sleep

print("开始")
# 让程序睡眠1秒(阻塞)
sleep(1)
print("结束")
```

**`from 模块名 import *`**

```python
from 模块名 import *

功能名()
```

**`as定义别名`**

```python
# 模块定义别名
import 模块名 as 别名

# 功能定义别名
from 模块名 import 功能 as 别名
```

Python中已经帮我们实现了很多的模块. 不过有时候我们需要一些个性化的模块, 这里就可以通过自定义模块实现, 也就是自己制作一个模块。

在实际开发中，当一个开发人员编写完一个模块后，为了让模块能够在项目中达到想要的效果，这个开发人员会自行在py文件中添加一些测试信息，例如，在`my_module1.py`文件中添加测试代码`test(1,1)`

```python
# my_module1.py
def test(a, b):
    print(a + b)

test(1, 1)
```

但是一旦其他文件导入该模块，那么将会立马执行test方法

```python
import my_module1
# 2
```

解决方案如下：

```python
def test(a, b):
    print(a + b)

# 只在当前文件中调用该函数，其他导入的文件内不符合该条件，则不执行test函数调用
# __name__是python内置变量，一旦是自己运行得，那么会赋值为__main__，这样if条件就是真了！
if __name__ == '__main__':
    test (1, 1)
```

如果一个模块文件中有`__all__`变量，当使用`from xxx import *`导入时，只能导入这个列表中的元素

**Python包**

从物理上看，包就是一个文件夹，在该文件夹下包含了一个 __init__.py 文件，该文件夹可用于包含多个模块文件。从逻辑上看，包的本质依然是模块。

当我们的模块文件越来越多时，包可以帮助我们管理这些模块，包的作用就是包含多个模块，但包的本质依然是模块。

新建包：[New]  ->  [Python Package]  ->  输入包名  ->   [OK]  -> 新建功能模块(有联系的模块)。新建包后，包内部会自动创建`__init__.py`文件，这个文件控制着包的导入行为

导入包：

1. 第一种方式：

   ```python
   import 包名.模块名
   
   包名.模块名.目标
   ```

2. 第二种方式：必须在`__init__.py`文件中添加`__all__ = []`，控制允许导入的模块列表

   ```python
   from 包名 import *
   模块名.目标
   ```

**安装第三方包**

我们知道，包可以包含一堆的Python模块，而每个模块又内含许多的功能。所以，我们可以认为：一个包，就是一堆同类型功能的集合体。

在Python程序的生态中，有许多非常多的第三方包（非Python官方），可以极大的帮助我们提高开发效率，如：

- 科学计算中常用的：numpy包
- 数据分析中常用的：pandas包
- 大数据计算中常用的：pyspark、apache-flink包
- 图形可视化常用的：matplotlib、pyecharts
- 人工智能常用的：tensorflow等

这些第三方的包，极大的丰富了Python的生态，提高了开发效率。但是由于是第三方，所以Python没有内置，所以我们需要安装它们才可以导入使用哦。

第三方包的安装非常简单，我们只需要使用Python内置的pip程序即可。打开我们许久未见的：命令提示符程序，在里面输入：`pip install 包名称`。即可通过网络快速安装第三方包。

由于pip是连接的国外的网站进行包的下载，所以有的时候会速度很慢。我们可以通过如下命令，让其连接国内的网站进行包的安装：`pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 包名称`。https://pypi.tuna.tsinghua.edu.cn/simple 是清华大学提供的一个网站，可供pip程序下载第三方包。

## 1.9 JSON数据格式

JSON是一种轻量级的数据交互格式。可以按照JSON指定的格式去组织和封装数据。JSON本质上是一个带有特定格式的字符串。

json就是一种在各个编程语言中流通的数据格式，负责不同编程语言中的数据传递和交互。类似于国际通用语言-英语。

```json
# json数据的格式可以是： 
{"name":"admin","age":18} 

# 也可以是：  
[{"name":"admin","age":18},{"name":"root","age":16},{"name":"张三","age":20}] 
```

lPython数据和Json数据的相互转化

```python
# 导入json模块 
import json 

# 准备符合格式json格式要求的python数据 
data = [{"name": "老王", "age": 16}, {"name": "张三", "age": 20}]
 
# 通过 json.dumps(data) 方法把python数据转化为了 json数据 
data = json.dumps(data) 

# 通过 json.loads(data) 方法把json数据转化为了 python数据 
data = json.loads(data)
```

# 第二章 面向对象

1. 在程序中设计表格，我们称之为：设计类（class）

   ```python
   class Student:
       name = None # 记录学生姓名
   ```

2. 在程序中打印生产表格，我们称之为：创建对象

   ```python
   # 基于类创建对象
   stu_1 = Student()
   stu_2 = Student()
   ```

3. 在程序中填写表格，我们称之为：对象属性赋值

   ```python
   stu_1.name = "林炫"
   stu_2.name = "陈沐阳"
   ```

现在我们来看看类的使用语法：

```python
class 类名称:
    类的属性
    类的行为
```

class是关键字，表示要定义类了。类的属性，即定义在类中的变量（成员变量）。类的行为，即定义在类中的函数（成员方法）。

创建类对象的语法：

```python
对象 = 类名称()
```

## 2.1 成员方法

在类中定义成员方法和定义函数基本一致，但仍有细微区别：

```python
def 方法名称(self, 形参1, ...， 形参N):
    方法体
```

可以看到，在方法定义的参数列表中，有一个`self`关键字。self关键字是成员方法定义的时候，必须填写的。它用来表示类对象自身的意思。

当我们使用类对象调用方法的是，`self`会自动被python传入。在方法内部，想要访问类的成员变量，必须使用`self`。

```python
def say_hi(self):
    print(f"hi, 我是{self.name}")
```

self关键字，尽管在参数列表中，但是传参的时候可以忽略它。

```python
class Student:
    name = None

    def say_hi(self):
        print("hi")

    def say_hi2(self, msg):
        print(f"hi, {msg}")


stu = Student()
stu.say_hi()
stu.say_hi2("你好呀")
```

## 2.2 构造方法

Python类可以使用：`__init__()`方法，称之为构造方法。

- 在创建类对象（构造类）的时候，会自动执行。
- 在创建类对象（构造类）的时候，将传入参数自动传递给`__init__()`方法使用。

```python
class Student:
    # 可以省略
    # name = None
    # age = None
    # tel = None

    def __init__(self, name, age, tel):
        self.name = name
        self.age = age
        self.tel = tel
        print("创建了一个对象")


stu = Student("林炫", 19, 111)
print(f"{stu.name}, {stu.age}, {stu.tel}")
```

## 2.3 魔术方法

| 方法         | 功能                                           |
| ------------ | ---------------------------------------------- |
| `__init__()` | 构造方法，可用于创建类对象的时候设置初始化行为 |
| `__str__()`  | 用于实现类对象转字符串的行为                   |
| `__lt__()`   | 用于2个类对象进行小于或大于比较                |
| `__le__()`   | 用于2个类对象进行小于等于或大于等于比较        |
| `__eq__()`   | 用于2个类对象进行相等比较                      |

**`__str__` 字符串方法**

```python
class Student:
    def __init__(self, name, age, tel):
        self.name = name
        self.age = age
        self.tel = tel
        print("创建了一个对象")

    def __str__(self):
        return f"Student类对象, name = {self.name}, age = {self.age}"


stu = Student("林炫", 19, 111) 
print(stu) # Student类对象, name = 林炫, age = 19
print(str(stu)) # Student类对象, name = 林炫, age = 19
```

## 2.4 面向对象三大特性

面向对象编程，是许多编程语言都支持的一种编程思想。简单理解是基于模板（类）去创建实体（对象），使用对象完成功能开发。

面向对象包含3大主要特性：封装、继承、多态。

**封装**

封装表示的是，将现实世界事物的属性和行为封装到类中，描述为成员变量和成员方法。从而完成程序对现实世界事物的描述

类中提供了私有成员的形式来支持私有成员变量和私有成员方法。

- 私有成员变量：变量名以`__`开头（2个下划线）。私有变量无法赋值，也无法获取值。
- 私有成员方法：方法名以`__`开头（2个下划线）。私有方法无法直接被类对象使用。    

私有成员无法被类对象使用，但是可以被该类其它的成员使用。

**继承**

继承表示将从父类那里继承（复制）来成员变量和成员方法（不含私有）

继承分为：单继承和多继承

```python
class 类名称(父类名称):
    类内容体
```

```python
class 类名称(父类1, 父类2, ..., 父类N):
    类内容体
```

多个父类中，如果有同名的成员，那么默认以继承顺序（从左到右）为优先级。先继承的保留，后继承的被覆盖

子类继承父类的成员属性和成员方法后，如果对其“不满意”，那么可以进行复写。在子类中重新定义同名的属性或方法即可。一旦复写父类成员，那么类对象调用成员的时候，就会调用复写后的新成员。如果需要使用被复写的父类的成员，需要特殊的调用方式：

- 方式一：调用父类成员
  - 使用成员变量：`父类名.成员变量`
  - 使用成员方法：`父类名.成员方法(self)`
- 方式二：使用`super()`调用父类成员
  - 使用成员变量：`super().成员变量`
  - 使用成员方法：`super().成员方法()`

只能在子类内调用父类的同名成员。子类的类对象直接调用会调用子类复写的成员。

**多态**

多态：多种状态，即完成某个行为时，使用不同的对象会得到不同的状态。

多态常作用在继承关系上。比如函数(方法)形参声明接收父类对象、实际传入父类的子类对象进行工作。

包含抽象方法的类，称之为抽象类。抽象方法是指：没有具体实现的方法（pass）称之为抽象方法。

```python
class Animal:
    def speak(self):
        pass
```

抽象类作用：多用于做顶层设计（设计标准），以便子类做具体实现。也是对子类的一种软性约束，要求子类必须复写（实现）父类的一些方法。并配合多态使用，获得不同的工作状态。

## 2.5 类型注解

Python在3.5版本的时候引入了类型注解，以方便静态类型检查工具，IDE等第三方工具。

类型注解：在代码中涉及数据交互的地方，提供数据类型的注解（显式的说明）。

主要功能：帮助第三方IDE工具（如PyCharm）对代码进行类型推断，协助做代码提示。帮助开发者自身对变量进行类型注释

**变量的类型注解**

语法如下：

```python
# 为变量设置类型注解
var_1: int = 123
var_2: str = "linxuan"

# 为对象设置类型注解
class Student:
    pass
stu: Student = Student()
```

```python
# 基础容器注解
my_list: list = [1, 2, 3]
my_tuple: tuple = (1, "linxuan", True)
my_dict: dict = {"linxuan": 19}

# 详细容器注解
my_list: list[int] = [1, 2, 3]
# 元组类型设置类型详细注解，需要将每一个元素都标记出来
my_tuple: tuple[int, str, bool] = (1, "linxuan", True) 
# 字典类型设置类型详细注解，需要2个类型，第一个是key第二个是value
my_dict: dict[str, int] = {"linxuan": 19}
```

除了使用 `变量: 类型`， 这种语法做注解外，也可以在注释中进行类型注解。`# type: 类型`

```python
var_1 = 123        # type: int
var_2 = "linxuan"  # type: str
```

类型注解主要功能在于：帮助第三方IDE工具（如PyCharm）对代码进行类型推断，协助做代码提示。帮助开发者自身对变量进行类型注释（备注）。并不会真正的对类型做验证和判断。也就是，类型注解仅仅是提示性的，不是决定性的。

```python
var_1: str = 123
var_2: int = "linxuan"
```


如图代码，是不会报错的哦。

**方法的类型注解**

方法的形参类型注解语法

```python
def 方法名称(参数1: 类型注解, 参数2: 类型注解):
    方法体
```

函数（方法）的返回值也是可以添加类型注解的，语法如下：

```python
def 方法名称(参数1: 类型注解, 参数2: 类型注解) -> 返回值类型注解:
    return 返回值
```

**Union类型**

使用`Union[类型, ......, 类型]`可以定义联合类型注解。

Union联合类型注解，在变量注解、函数（方法）形参和返回值注解中，均可使用。

```python
from typing import Union

my_list: list[Union[int, str]] = [1, 2, "linxuan"]
my_dict: dicc[str, Uninon[str, int]] = {"name": "linxuan", "age" : 19}

def func(data: Union[int, str]) -> Union[int, str]:
    pass
```

# 第三章 常用库以及框架

**常用库**

NumPy的前身Numeric最早是由吉姆.弗贾宁(Jim Hugunin)与其他协作者共同开发，2005年，特拉维斯.奥利芬特(TravisOliphant )在Numeric中结合了另一个同性质的程序库Numarray的特色，并加入了其他扩展而开发了NumPy。进行科学计算的基础软件包。更多高级扩展库的依赖库。内置函数处理数据的效率较高。

pandas的名称源自面板数据(paneldata)和Python数据分析(Data Analysis)，最初是被作为金融数据分析工具而开发出来，由AQR Capital Management 于2008年4月开发，并于2009年底开源。提供了快速、灵活、明确的数据结构。带有丰富的数据预处理函数。支持数据的增、删、改、查。

Matplotlib是约翰·亨特(John Hunter)在2008年左右的博士后研究中发明出来的，最初只是为了可视化癞痢病人的一些健康指标，慢慢的Matplotlib变成了Python上最广泛使用的可视化工具包。支持折线图、条形图、柱状图、饼图的绘制。支持交互式绘图和非交互式绘图。支持Linux， Windows， Mac Os x与Solaris的跨平台绘图。迁移学习的成本比较低。

scikit-learn是Python下强大的机器学习工具包，提供了完善的机器学习工具箱，是一种简单高效的数据分析和挖掘的工具。scikit-learn不仅提供了一些实例数据用于练习，还提供了很多功能接口：

- model.fit()：用于训练模型
- model.predict(X_new)： 预测新样本
- model.predict_proba(X_new) ： 预测概率
- model.score()：得分越高，模型拟合效果越好
- model.transform() ：在fit函数的基础上，进行标准化，降维，归一化等数据处理操作
- model.fit_transform() ： fit函数和transform函数的组合，既包括了训练又包含了数据处理操作。



**深度学习**

Tensorflow

Tensorflow是基于Google 2011年开发的深度学习基础框架DistBelief构建而成。主要用于搭建深度神经网络。TensorFlow即Tensor和Flow， Tensor意味着data， Flow意味着流动、计算、映射，即数据的流动、数据的计算、数据的映射，同时也体现数据是有向的流动、计算和映射的。

Keras

Keras是由Python编写而成并使用TensorFlow， Theano以及CNTK作为后端的一个深度学习框架，也是深度学习框架中最容易使用的一个。

- Keras具有高度模块化、用户友好性和易扩展特性。
- 支持卷积神经网络和循环神经网络，以及两者的组合。
- Keras可无缝衔接CPU和GPU的切换。

PyTorch

PyTorch可帮助构建深度学习项目，其强调灵活性，并允许用Python表达深度学习模型;命令式体验，直接使用nn.module封装便可使网络搭建更快速和方便;调试简单，调试PyTorch就像调试Python代码一样简单。除此之外，PyTorch中还存在着较为完备的应用领域所对应的库：
