# 第一章 网络体系介绍

计算机网络体系可以大致分为一下三种，OSI七层模型、TCP/IP四层模型和五层模型。

- OSI七层模型：大而全，但是比较复杂、而且是先有了理论模型，没有实际应用。
- TCP/IP四层模型：是由实际应用发展总结出来的，从实质上讲，TCP/IP只有最上面三层，最下面一层没有什么具体内容，TCP/IP参考模型没有真正描述这一层的实现。
- 五层模型：五层模型只出现在计算机网络教学过程中，这是对七层模型和四层模型的一个折中，既简洁又能将概念阐述清楚。

![](D:\Java\笔记\图片\5-13【网络模型-应用层】\1.1.png)

## 1.1 OSI网络七层模型

OSI网络七层模型是ISO组织定义的国际通用标准模型，其目的是为了制定全球统一的网络模型标准，让全球内的国家、组织可以实现网络互通。OSI网络七层模型分别为：**应用--表示--会话--传输--网络--数据链路--物理**

* **应用层**：给用户和抽象的网络之间提供一个接口，为应用程序提供交互服务。常见协议有：TELENT、HTTP、HTTPS、FTP、DNS、POP3、SMTP等。
* **表示层**：表示层提供各种数据的编码和转换功能，确保一个系统的应用层发送的数据能被另一个系统的应用层识别。例如：数据格式变化、数据加密与解密、数据压缩与解压等。常见协议有：Rlogin, SNMP, Gopher。
* **会话层**：会话层就是负责建立、管理和终止两个节点（应用程序）之间的通信会话。负责维护两个节点之间的传输联接，确保点到点传输不中断，以及管理数据交换等功能。
* **传输层**：传输层实现了网络中不同主机上的用户进程之间的数据通信，为用户提供了端到端的服务。定义了传输数据的协议端口号，以及流量控制和差错校验。常见协议有：TCP、UDP。
* **网络层**：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。IP协议是Internet的基础。常见协议有：IP, ICMP, ARP, RARP, AKP, UUCP。
* **数据链路层** ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。
* **物理层**：物理层的作用就是提供了网络的双向通讯，为双向传输提供了有保障的通路。考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

就像一个公司要分很多部门一样，每个部门各司其职，网络模型分层的目的也是为了这样，另外分层还能达到降低复杂性、统一标准、工程模块化、快速发展、易于学习掌握等目的。

公司的部门和部门之间肯定是有一定联系的。所以在OSI七层模型中，相邻层之间也都是有联系的，这个联系就叫做服务接入点，简称SA(service access)。所以正是因为相邻两层之间有SA，这两层之间才会有联系。相邻两层之间必须有服务接入点。

## 1.2 TCP/IP网络协议四层模型

**TCP/IP**（`Transmission Control Protocol/Internet Protocol`，传输控制协议/网际协议）指能够在多个不同网络间实现信息传输的协议簇。该协议具有很强的灵活性，支持任意规模的网络，几乎可连接所有服务器和工作站。定义了主机如何连入因特网及数据如何在它们之间传输的标准。

TCP/IP协议不仅仅指的是TCP 和IP两个协议，而是指一个由TCP、IP、UDP、FTP、SMTP等协议构成的协议簇， 只是因为在TCP/IP协议中TCP协议和IP协议最具代表性，所以被称为TCP/IP协议。

TCP/IP协议在一定程度上参考了OSI的体系结构。不同于ISO模型的七个分层，TCP/IP协议参考模型把所有的TCP/IP系列协议归类到四个抽象层中：**应用--传输--网络--网络接口层**。数据链路层和物理层合并为网络接口层。网络层也称为IP层。

TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。

![](D:\Java\笔记\图片\5-13【网络模型-应用层】\3.png)

接下来详细介绍一下TCP/IP网络协议四层模型。

# 第二章 应用层

“应用层”的作用，就是向**用户提供一组常用的应用程序，规定应用程序的数据格式**。比如电子邮件、文件传输访问、远程登录等。

TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了"应用层"。

我们常见应用层的网络服务协议有：HTTP、HTTPS、DNS、FTP、DHCP、TELNET、SMTP、POP3、IMAP、SNMP等。

|        应用        | 应用层协议 | 端口号  | 传输层协议 |            备注             |
| :----------------: | :--------: | :-----: | :--------: | :-------------------------: |
|   超文本传送协议   |    HTTP    |   80    |    TCP     |                             |
| 超文本传送安全协议 |   HTTPS    |   443   |    TCP     |                             |
|      域名解析      |    DNS     |   53    |  TCP/UDP   | 长度超过 512 字节时使用 TCP |
|    文件传送协议    |    FTP     |  20/21  |    TCP     |  控制连接 21，数据连接 20   |
|  动态主机配置协议  |    DHCP    |  67/68  |    UDP     |                             |
|    远程终端协议    |   TELNET   |   23    |    TCP     |                             |
|  简单邮件传送协议  |    SMTP    |   25    |    TCP     |                             |
|    邮件读取协议    |    POP3    |   110   |    TCP     |                             |
|  网际报文存取协议  |    IMAP    |   143   |    TCP     |                             |
|  简单网络管理协议  |    SNMP    | 161/162 |    UDP     |                             |

在这一层，数据的单位称为帧（frame）。

## 2.1 HTTP协议

HTTP协议是`Hyper Text Transfer Protocol`（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议，定义了客户端和服务器端通信的时候，发送数据的格式。HTTP协议就是TCP/IP协议中专门用于浏览器与Web服务器之间通信的应用层协议。

通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行，比如"HTTP/1.1 200 OK"，和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。HTTP使用TCP而不是UDP的原因在于（打开）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据和错误纠正。

浏览器与Web服务器之间的协议是应用层协议，当前，我们主要遵循的协议为HTTP/1.1。HTTP协议是Web开发的基础，这是一个无状态的协议，客户机与服务器之间通过请求和相应完成一次会话（Session）。

![](D:\Java\笔记\图片\5-13【网络模型-应用层】\1-1.png)

特点如下：

- 基于`TCP/IP`的高级协议。
- 默认端口号：`80`。
- 基于请求/响应模型的：一次请求对应一次响应。
- 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
- 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
- HTTP 允许传输任意类型的数据。传输的类型由 `Content-Type` 加以标记。
- 支持客户端/服务器模式。

HTTP 协议由HTTP 请求和HTTP 响应组成，当在浏览器中输入网址访问某个网站时，浏览器会将请求封装成一个HTTP 请求发送给服务器站点，服务器接收到请求后会组织响应数据封装成一个HTTP 响应返回给浏览器。即没有请求就没有响应。

### 2.1.1 URI和URL

- URI：统一资源标识符。相当于共和国，所以URI更大
- URL：统一资源定位符。相当于中华人民共和国

我们在浏览器的地址栏里输入的网站地址叫做URL (Uniform Resource Locator，统一资源定位符)。URL中描述了协议，用于检索资源和资源名称。如果是web上的资源，所用的协议就是http或者https。如果资源是文件类型的，那么使用的协议就是ftp。URL由七部分组成：

- 1：所使用的协议（http,ftp）
- 2：服务器的位置（IP号）
- 3：服务器上的端口号（0~65535）
- 4：资源所在的路径
- 5：参数（访问该资源所带的参数）
- 6：片段（发给http服务器的数据）

![](D:\Java\笔记\图片\5-13【网络模型-应用层】\1.2.png)

只要能唯一标识资源的就是URI，在URI的基础上给出其资源的访问方式的就是URL。

### 2.1.1 请求消息

请求消息：客户端发给服务器端的数据

```java
// 请求行
POST /login.html HTTP/1.1

// Chrome浏览器请求头
Host: localhost
Connection: keep-alive
Cache-Control: max-age=0

// 请求空行

// 请求体，只有POST有，是参数
username = zhangsan
```

数据格式如下：请求行、请求头、请求空行、请求体。

1. 请求行：`请求方式 请求URL 请求协议/版本`，实例：`GET /login.html HTTP/1.1`。包括请求方法，访问的资源 URL，使用的 HTTP 版本。`GET`和`POST`是最常见的 HTTP 方法，除此以外还包括`DELETE、HEAD、OPTIONS、PUT、TRACE`。新增POST、修改PUT。

2. 请求头：`请求头名称: 请求头值`。格式为“属性名:属性值”，服务端根据请求头获取客户端的信息，主要有`cookie、host、connection、accept-language、accept-encoding、user-agent`。

   `User-Agent`：浏览器告诉服务器，访问服务器使用的浏览器款式。这样可以让服务器获取头信息，解决浏览器的兼容性问题。

   `Referer`：`http://localhost/login.html`告诉服务器，当前请求从何而来。这样有两个好处：1. 防止盗链发生。2. 统计工作。

3. 请求空行

   空行，真的只是一个空行，它主要是起了分割的作用。分割请求头和请求体。

4. 请求体(请求正文)

   在GET方法中是没有请求体的，但是在POST中是有请求体的。这是因为POST的参数不显示，都在请求体中封装POST请求消息的请求参数。

`HTTP`协议一共有着7种请求方式`GET、POST、DELETE、HEAD、OPTIONS、PUT、TRACE`。，但是常用的只有两种GET和POST。

- GET 参数通过 URL也就是请求行传递，POST参数数据 放在 Request body请求体 中。
- GET 请求在 URL 中传送的参数是有长度限制的，而 POST没有，所以POST可以用于文件的上传。
- GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。
- GET 在浏览器回退时是无害的，而 POST 会再次提交请求。
- GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。
- GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。
- GET 请求只能进行 URL 编码，而 POST 支持多种编码方式。
- GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。
- 对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。

但是实际上 GET 和 POST 本质上没有区别：

- GET 和 POST 是HTTP 协议中的两种发送请求的方法，HTTP是基于 TCP/IP 的关于数据如何在万维网中如何通信的协议。

- HTTP 的底层是 TCP/IP，所以 GET 和 POST 的底层也是 TCP/IP，也就是说，GET/POST 都是 TCP 链接。GET 和 POST 能做的事情是一样一样的。要给 GET 加上 request body，给 POST 带上 url 参数，技术上是完全行的通的。


在万维网世界中，TCP 就像汽车，交通规则就是HTTP，浏览器和服务器就是运输公司。HTTP 给汽车运输设定了好几个服务类别，有 GET, POST, PUT, DELETE 等等。

HTTP 规定，执行 GET 请求时设置 method 为 GET，并且把传送的数据放在url 中以方便记录。如果是 POST 请求，就要设置 method 为 POST，并把传送数据放在方法体中。当然，也可以在 GET 的时候往方法体中放一些数据，在POST的时候往URL中放一些数据。HTTP 只是个行为准则，而 TCP 才是 GET 和 POST 怎么实现的基本。

上面说的是HTTP 对 GET 和 POST 参数的传送渠道（url 还是 requrest body）提出的要求，接下来说一下参数大小的限制。

浏览器和服务器就是运输公司，它们用来接收和传送数据，但是这也需要一些成本，因此会限制URL中的参数长度，不限制方法体中参数长度。如果是GET方式传数据，在方法体中放一些数据，不同的服务器处理方式不一样，有的会接收数据，有的忽略。GET 和 POST 本质上就是 TCP 链接，并无差别。但是由于 HTTP 的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。

GET 和 POST 还有一个重大区别，简单的说：GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。

- 对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；
- 而对于 POST，浏览器先发送 header，服务器响应 100（continue），浏览器再发送 data，服务器响应 200（返回数据）。

![](D:\Java\笔记\图片\5-13【网络模型-应用层】\应用层.jpg)

因为 POST 需要两步，时间上消耗的要多一点，看起来 GET 比 POST 更有效。但是GET并不能替换POST：

- GET 与 POST 都有自己的语义，不能随便混用。
- 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的 TCP 在验证数据包完整性上，有非常大的优点。
- 并不是所有浏览器都会在 POST 中发送两次包，比如 Firefox 就只发送一次。

### 2.1.2 响应消息

响应消息：服务器端发送给客户端的数据

```html
<!--响应行 协议/版本 响应状态码 状态码描述-->
HTTP/1.1 200
Content-Type: text/html;charset=UTF-8
Content-Length: 100
Date: Mon, 07 Mar 2022 08:01:01 GMT
Keep-Alive: timeout=20
Connection: keep-alive
```

数据格式如下：响应行、响应头、响应空行、响应体。

1. 响应行：`协议/版本 响应状态码 状态码描述 HTTP/1.1 200`。响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。

2. 响应头：格式：`响应头名称：值`。常见的响应头有：`connection、content-type、content-encoding、content-length、set-cookie、Last-Modified、Cache-Control、Expires`。

   `Content-Type`：服务器告诉客户端本次响应体数据格式以及编码格式

   `Content-disposition`：服务器告诉客户端以什么格式打开响应体数据。`in-line`：默认值，在当前页面内部打开。不经常使用。`attachment`：以附件的形式打开响应体，通常用于文件下载。

3. 相应空行：仅仅是一个空行

4. 响应体：响应体：传输的数据。

常用的相应状态码如下：

| 状态码 | 类别                             | 原因                       |
| ------ | -------------------------------- | -------------------------- |
| 1xx    | Informational(信息性状态码)      | 接收的请求正在处理         |
| 2xx    | Success（成功状态码）            | 请求正常处理完毕           |
| 3xx    | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4xx    | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5xx    | Server Error（服务器错误状态码） | 服务器处理请求错误         |

| 状态码 | 含义               | 解释                                                         |
| ------ | :----------------- | ------------------------------------------------------------ |
| 200    | 成功               | 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 |
| 300    | 多种选择           | 针对请求，服务器可执行多种操作。 <br />服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择 |
| 302    | 重定向             | 服务器目前从不同位置的网页响应请求，<br />但请求者应继续使用原有位置来进行以后的请求 |
| 304    | 未修改（请求缓存） | 自从上次请求后，请求的网页未修改过。 <br />服务器返回此响应时，不会返回网页内容 |
| 305    | 使用代理           | 请求者只能使用代理访问请求的网页。 <br />如果服务器返回此响应，还表示请求者应使用代理 |
| 400    | 错误请求           | 服务器不理解请求的语法                                       |
| 401    | 未授权             | 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应  |
| 403    | 禁止               | 服务器拒绝请求                                               |
| 404    | 未找到             | 服务器找不到请求的网页                                       |
| 405    | 方法禁用           | 禁用请求中指定的方法                                         |
| 500    | 服务器内部错误     | 服务器遇到错误，无法完成请求                                 |
| 502    | 错误网关           | 服务器作为网关或代理，从上游服务器收到无效响应               |
| 503    | 服务不可用施       | 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态 |
| 504    | 网关超时           | 服务器作为网关或代理，但是没有及时从上游服务器收到请求       |

### 2.1.3 HTTP1.0和HTTP1.1

区别如下：

- 长连接：HTTP1.0 默认使用短连接，每次请求都需要建立新的 TCP 连接，连接不能复用。HTTP1.1 支持长连接，复用 TCP 连接，允许客户端通过同一连接发送多个请求。不过，这个优化策略也存在问题，当一个队头的请求不能收到响应的资源时，它将会阻塞后面的请求。这就是“队头阻塞”问题。
- 断点续传：HTTP1.0 不支持断点续传。HTTP1.1 新增了 range 字段，用来指定数据字节位置，支持断点续传。
- 错误状态响应码：在 HTTP1.1 中新增了 24 个错误状态响应码，如`409（Conflict）`表示请求的资源与资源的当前状态发生冲突、`410（Gone）`表示服务器上的某个资源被永久性的地删除。
- Host 头处理：在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名。到了 HTTP1.1 时代，虚拟主机技术发展迅速，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个 IP 地址，故 HTTP1.1 增加了 HOST 信息。

### 2.1.4 HTTP1.1和HTTP2.0

- 新的二进制格式：HTTP1.1 基于文本格式传输数据；HTTP2.0 采用二进制格式传输数据，解析更高效。
- 多路复用：在一个连接里，允许同时发送多个请求或响应，并且这些请求或响应能够并行地传输而不被阻塞，避免 HTTP1.1 出现的“队头堵塞”问题。
- 头部压缩，HTTP1.1 的 header 带有大量信息，而且每次都要重复发送；HTTP2.0 把 header 从数据中分离，并封装成头帧和数据帧，使用特定算法压缩头帧，有效减少头信息大小。并且 HTTP2.0 在客户端和服务器端记录了之前发送的键值对，对于相同的数据，不会重复发送。比如请求 a 发送了所有的头信息字段，请求 b 则只需要发送差异数据，这样可以减少冗余数据，降低开销。
- 服务端推送：HTTP2.0 允许服务器向客户端推送资源，无需客户端发送请求到服务器获取。

## 2.2 HTTPS协议

HTTPS 原理：首先是 TCP 三次握手，然后客户端发起一个 HTTPS 连接建立请求，客户端先发一个`Client Hello`的包，然后服务端响应`Server Hello`，接着再给客户端发送它的证书，然后双方经过密钥交换，最后使用交换的密钥加解密数据。

- 协商加密算法 。在`Client Hello`里面客户端会告知服务端自己当前的一些信息，包括客户端要使用的 TLS 版本，支持的加密算法，要访问的域名，给服务端生成的一个随机数（Nonce）等。需要提前告知服务器想要访问的域名以便服务器发送相应的域名的证书过来。
- 服务端响应`Server Hello`，告诉客户端服务端选中的加密算法。

- 接着服务端给客户端发来了 2 个证书。第二个证书是第一个证书的签发机构（CA）的证书。

- 客户端使用证书的认证机构 CA 公开发布的 RSA 公钥对该证书进行验证。

- 验证通过之后，浏览器和服务器通过密钥交换算法产生共享的对称密钥。

- 开始传输数据，使用同一个对称密钥来加解密。

HTTP与HTTS区别如下：

1. HTTP 是超文本传输协议，信息是明文传输；HTTPS 则是具有安全性的 ssl 加密传输协议。
2. HTTP 和 HTTPS 用的端口不一样，HTTP 端口是 80，HTTPS 是 443。
3. HTTPS 协议需要到 CA 机构申请证书，一般需要一定的费用。
4. HTTP 运行在 TCP 协议之上；HTTPS 运行在 SSL 协议之上，SSL 运行在 TCP 协议之上。

## 2.3 DNS域名系统

DNS (域名系统)：端口号53，用于解析DNS。

DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。

域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。

![](D:\Java\笔记\图片\5-13【网络模型-应用层】\4-1.jpg)

DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：

- 如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。
- 区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。

## 2.4 FTP文件传送协议

FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：

- 控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。
- 数据连接：用来传送一个文件数据。

根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：

- 主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0\~1023 是熟知端口号。

  ![](D:\Java\笔记\图片\5-13【网络模型-应用层】\4-2.jpg)

- 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。

  ![](D:\Java\笔记\图片\5-13【网络模型-应用层】\4-3.jpg)

主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。

filezilla使用的就是FTP协议来传输文件。

## 2.5 DHCP动态主机配置协议

DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。

DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。

DHCP 工作过程如下：

1. 客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。

2. DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。

3. 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。

4. DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。

   ![](D:\Java\笔记\图片\5-13【网络模型-应用层】\5-1.jpg)

## 2.6 TELNET远程登录协议

TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。

TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。

## 2.7 电子邮件协议

一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。

邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。

![](D:\Java\笔记\图片\5-13【网络模型-应用层】\5-2.png)

### 2.7.1 SMTP

SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。

![](D:\Java\笔记\图片\5-13【网络模型-应用层】\5-3.png)

### 2.7.2 POP3

POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。

### 2.7.3 IMAP

IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。

## 2.8 Web 页面请求过程

### 2.8.1 DHCP 配置主机信息

- 假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。

- 主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。

- 该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。

- 该数据报则被放置在 MAC 帧中，将广播到与交换机连接的所有设备。

- 连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段被放入 IP 数据报中，最后放入 MAC 帧中。

- 该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。

- 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。

### 2.8.2 ARP 解析 MAC 地址

- 主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。

- 主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。

- 该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。

- 该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。

- DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。

- 主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。

- 网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。

### 2.8.3 DNS 解析域名

- 知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。

- 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。

- 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。

- 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。

- 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。

### 2.8.4 HTTP 请求页面

- 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。

- 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。

- HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。

- 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。

- HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。

- 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。

# 第三章 传输层

网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。

传输层：建立端口到端口的通信。在这一层，数据的单位称为 段 （segment）

传输层需要有两种不同的运输协议，即面向连接的 TCP 和无连接的 UDP。

## 3.1 端口

端口：我们通过IP和Mac找到了一台特定的主机，如何标识这台主机上的应用程序，答案就是端口，端口即应用程序与网卡关联的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。

“端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。

“传输层”的功能，就是建立“端口到端口”的通信，相比之下，“网络层”的功能是建立“主机到主机”的通信，只要确定主机和端口，我们就能实现程序之间的交流。

## 3.2 Socket

Socket，套接字。

Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。

![](D:\Java\笔记\图片\5-14【网络模型-传输层】\1.3.jpg)

 一个生活中的场景。你要打电话给一个朋友，先拨号，朋友听到电话铃声后提起电话，这时你和你的朋友就建立起了连接，就可以讲话了。等交流结束，挂断电话结束此次交谈。

![](D:\Java\笔记\图片\5-14【网络模型-传输层】\1.4.jpg)

服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。

使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket，而现在又是网络时代，网络中进程通信是无处不在，这就是“一切皆socket”。

socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –> 读写write/read –> 关闭close”模式来操作。socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）。

## 3.3 TCP协议

TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。

因为是面向连接的协议，也就是说：在收发数据前必须和对方建立可靠的连接。  一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，简单的说一下：

1. 主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；
2. 主机B向主机A发送同意连接和要求同步 （同步就是两台主机一个在发送，一个在接收，协调工作）的数据包 、“可以，你什么时候发？”，这是第二次对话；
3. 主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”， 这是第三次对话。

三次“对话”的目的是使数据包的发送和接收同步， 经过三次“对话”之后，主机A才向主机B正式发送数据。

接下来详细的介绍一下：TCP数据包的格式：

<img src="D:\Java\笔记\图片\5-14【网络模型-传输层】\1.5.png"/>

-   **序号seq** ：占4个字节也就是32个比特位，用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。

-   **确认号ack** ：占4个字节，期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。

-   **数据偏移**：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。

-   **确认 ACK**：占1个比特位，当 ACK=1时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。

-   **同步 SYN**：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。

-   **终止 FIN**：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。

-   **窗口**：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。

### 3.3.1 三次握手

![](D:\Java\笔记\图片\5-14【网络模型-传输层】\2-1.png)

假设 A 为客户端，B 为服务器端。

- 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。

- A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号seq=x，并进入SYN_SENT状态，等待服务器确认。

- B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，选择一个初始的序号 y，确认号ack为 x+1，此时B进入SYN_RCVD（SYN_RECEIVED接收）状态。

- A 收到 B 的确认连接报文后，还要向 B 发出确认报文，ACK=1，序号seq为 x+1，确认号ack为 y+1。

- B 收到 A 的确认后，进入ESTAB_LISHED（TCP连接成功状态），连接建立。

**第三次握手的原因**

第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

> 另外一个原因：第三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认

**如果已经建立了连接，但客户端出现故障**

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

### 3.3.2 四次挥手

序号seq、确认号ack、确认ACK、同步SYN、终止FIN。

![](D:\Java\笔记\图片\5-14【网络模型-传输层】\2-2四次挥手.jpg)

以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。

- A 发送连接释放报文，FIN=1，并且进入进入FIN-WAIT-1（终止等待1）状态。

- B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。B进入CLOSE-WAIT（关闭等待）状态，A进入FIN-WAIT-2（终止等待2）状态。

- 当 B 不再需要连接时，发送连接释放报文，FIN=1。B进入LAST-ACK（最后确认）状态。

- A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。

- B 收到 A 的确认后释放连接。

**四次挥手的原因**

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

**TIME_WAIT**  

客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：

- 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。

- 防止已失效的连接请求报文段出现在本连接中。等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

> 所谓的2MSL是两倍的MSL(`Maximum Segment Lifetime`)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。

### 3.3.3 TCP 可靠传输

TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。

一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：

![](D:\Java\笔记\图片\5-14【网络模型-传输层】\6-1gif.gif)

其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。

超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：

![](D:\Java\笔记\图片\5-14【网络模型-传输层】\6-2gif.gif)

其中 RTT<sub>d</sub> 为偏差的加权平均值。

### 3.3.4 TCP 滑动窗口

窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。

发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。

接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。

![](D:\Java\笔记\图片\5-14【网络模型-传输层】\7-1TCP滑动窗口.jpg)

### 3.3.5 TCP 流量控制

流量控制是为了控制发送方发送速率，保证接收方来得及接收。

接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

### 3.3.6 TCP 拥塞控制

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。

![](D:\Java\笔记\图片\5-14【网络模型-传输层】\7-2TCP拥塞控制.jpg)

TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。

发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。

为了便于讨论，做如下假设：

- 接收方有足够大的接收缓存，因此不会发生流量控制；

- 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。

  ![](D:\Java\笔记\图片\5-14【网络模型-传输层】\7-3TCP拥塞控制.png)

**慢开始与拥塞避免**

发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...

注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd \>= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。

如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。

**快重传与快恢复**

在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M<sub>1</sub> 和 M<sub>2</sub>，此时收到 M<sub>4</sub>，应当发送对 M<sub>2</sub> 的确认。

在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M<sub>2</sub>，则 M<sub>3</sub> 丢失，立即重传 M<sub>3</sub>。

在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。

慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。

![](D:\Java\笔记\图片\5-14【网络模型-传输层】\7-4.png)

## 3.4 UDP协议

<img src="D:\Java\笔记\图片\5-14【网络模型-传输层】\8-1.jpg" style="zoom:50%;" />

UDP（User Data Protocol，用户数据报协议），首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。

用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。

1. UDP是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。 在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、 计算机的能力和传输带宽的限制； 在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。
2. 由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等， 因此一台服务机可同时向多个客户机传输相同的消息。
3. UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。
4. 吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、 源端和终端主机性能的限制。
5. UDP使用尽最大努力交付，即不保证可靠交付， 因此主机不需要维持复杂的链接状态表（这里面有许多参数）。
6. UDP是面向报文的。发送方的UDP对应用程序交下来的报文， 在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界， 因此，应用程序需要选择合适的报文大小。

## 3.5 TCP和UDP区别

|              | UDP                                        | TCP                                      |
| ------------ | ------------------------------------------ | ---------------------------------------- |
| 是否连接     | 无连接                                     | 面向连接                                 |
| 是否可靠     | 不可靠传输，不使用流量控制和拥塞控制       | 可靠传输，使用流量控制和拥塞控制         |
| 是否有序     | 无序                                       | 有序，消息在传输过程中乱序 TCP会重新排序 |
| 传输速度     | 快                                         | 慢                                       |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信 | 只能是一对一通信                         |
| 传输方式     | 面向报文                                   | 面向字节流                               |
| 首部开销     | 首部开销小，仅8字节                        | 首部最小20字节，最大60字节               |
| 适用场景     | 适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的应用，例如文件传输   |

1. 基于连接与无连接；
2. 对系统资源的要求（TCP较多，UDP少）；
3. UDP程序结构较简单；
4. 流模式与数据报模式 ；
5. TCP保证数据正确性，UDP可能丢包；
6. TCP保证数据顺序，UDP不保证。